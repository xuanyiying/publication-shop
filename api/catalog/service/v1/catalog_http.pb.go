// Code generated by protoc-gen-go-http. DO NOT EDIT.
// versions:
// - protoc-gen-go-http v2.7.3
// - protoc             v5.26.1
// source: api/catalog/v1/catalog.proto

package v1

import (
	context "context"
	http "github.com/go-kratos/kratos/v2/transport/http"
	binding "github.com/go-kratos/kratos/v2/transport/http/binding"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the kratos package it is being compiled against.
var _ = new(context.Context)
var _ = binding.EncodeURL

const _ = http.SupportPackageIsVersion1

const OperationCatalogCreateCatalog = "/api.catalog.v1.Catalog/CreateCatalog"
const OperationCatalogDeleteCatalog = "/api.catalog.v1.Catalog/DeleteCatalog"
const OperationCatalogGetCatalog = "/api.catalog.v1.Catalog/GetCatalog"
const OperationCatalogListCatalog = "/api.catalog.v1.Catalog/ListCatalog"
const OperationCatalogUpdateCatalog = "/api.catalog.v1.Catalog/UpdateCatalog"

type CatalogHTTPServer interface {
	CreateCatalog(context.Context, *CreateCatalogRequest) (*CreateCatalogReply, error)
	DeleteCatalog(context.Context, *DeleteCatalogRequest) (*DeleteCatalogReply, error)
	GetCatalog(context.Context, *GetCatalogRequest) (*GetCatalogReply, error)
	ListCatalog(context.Context, *ListCatalogRequest) (*ListCatalogReply, error)
	UpdateCatalog(context.Context, *UpdateCatalogRequest) (*UpdateCatalogReply, error)
}

func RegisterCatalogHTTPServer(s *http.Server, srv CatalogHTTPServer) {
	r := s.Route("/")
	r.POST("/api.catalog.v1.Catalog/CreateCatalog", _Catalog_CreateCatalog0_HTTP_Handler(srv))
	r.POST("/api.catalog.v1.Catalog/UpdateCatalog", _Catalog_UpdateCatalog0_HTTP_Handler(srv))
	r.POST("/api.catalog.v1.Catalog/DeleteCatalog", _Catalog_DeleteCatalog0_HTTP_Handler(srv))
	r.POST("/api.catalog.v1.Catalog/GetCatalog", _Catalog_GetCatalog0_HTTP_Handler(srv))
	r.POST("/api.catalog.v1.Catalog/ListCatalog", _Catalog_ListCatalog0_HTTP_Handler(srv))
}

func _Catalog_CreateCatalog0_HTTP_Handler(srv CatalogHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in CreateCatalogRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationCatalogCreateCatalog)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.CreateCatalog(ctx, req.(*CreateCatalogRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*CreateCatalogReply)
		return ctx.Result(200, reply)
	}
}

func _Catalog_UpdateCatalog0_HTTP_Handler(srv CatalogHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in UpdateCatalogRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationCatalogUpdateCatalog)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.UpdateCatalog(ctx, req.(*UpdateCatalogRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*UpdateCatalogReply)
		return ctx.Result(200, reply)
	}
}

func _Catalog_DeleteCatalog0_HTTP_Handler(srv CatalogHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in DeleteCatalogRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationCatalogDeleteCatalog)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.DeleteCatalog(ctx, req.(*DeleteCatalogRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*DeleteCatalogReply)
		return ctx.Result(200, reply)
	}
}

func _Catalog_GetCatalog0_HTTP_Handler(srv CatalogHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in GetCatalogRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationCatalogGetCatalog)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.GetCatalog(ctx, req.(*GetCatalogRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*GetCatalogReply)
		return ctx.Result(200, reply)
	}
}

func _Catalog_ListCatalog0_HTTP_Handler(srv CatalogHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in ListCatalogRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationCatalogListCatalog)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.ListCatalog(ctx, req.(*ListCatalogRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*ListCatalogReply)
		return ctx.Result(200, reply)
	}
}

type CatalogHTTPClient interface {
	CreateCatalog(ctx context.Context, req *CreateCatalogRequest, opts ...http.CallOption) (rsp *CreateCatalogReply, err error)
	DeleteCatalog(ctx context.Context, req *DeleteCatalogRequest, opts ...http.CallOption) (rsp *DeleteCatalogReply, err error)
	GetCatalog(ctx context.Context, req *GetCatalogRequest, opts ...http.CallOption) (rsp *GetCatalogReply, err error)
	ListCatalog(ctx context.Context, req *ListCatalogRequest, opts ...http.CallOption) (rsp *ListCatalogReply, err error)
	UpdateCatalog(ctx context.Context, req *UpdateCatalogRequest, opts ...http.CallOption) (rsp *UpdateCatalogReply, err error)
}

type CatalogHTTPClientImpl struct {
	cc *http.Client
}

func NewCatalogHTTPClient(client *http.Client) CatalogHTTPClient {
	return &CatalogHTTPClientImpl{client}
}

func (c *CatalogHTTPClientImpl) CreateCatalog(ctx context.Context, in *CreateCatalogRequest, opts ...http.CallOption) (*CreateCatalogReply, error) {
	var out CreateCatalogReply
	pattern := "/api.catalog.v1.Catalog/CreateCatalog"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationCatalogCreateCatalog))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *CatalogHTTPClientImpl) DeleteCatalog(ctx context.Context, in *DeleteCatalogRequest, opts ...http.CallOption) (*DeleteCatalogReply, error) {
	var out DeleteCatalogReply
	pattern := "/api.catalog.v1.Catalog/DeleteCatalog"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationCatalogDeleteCatalog))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *CatalogHTTPClientImpl) GetCatalog(ctx context.Context, in *GetCatalogRequest, opts ...http.CallOption) (*GetCatalogReply, error) {
	var out GetCatalogReply
	pattern := "/api.catalog.v1.Catalog/GetCatalog"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationCatalogGetCatalog))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *CatalogHTTPClientImpl) ListCatalog(ctx context.Context, in *ListCatalogRequest, opts ...http.CallOption) (*ListCatalogReply, error) {
	var out ListCatalogReply
	pattern := "/api.catalog.v1.Catalog/ListCatalog"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationCatalogListCatalog))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *CatalogHTTPClientImpl) UpdateCatalog(ctx context.Context, in *UpdateCatalogRequest, opts ...http.CallOption) (*UpdateCatalogReply, error) {
	var out UpdateCatalogReply
	pattern := "/api.catalog.v1.Catalog/UpdateCatalog"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationCatalogUpdateCatalog))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}
