// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"log"
	"reflect"

	"github.com/xuanyiying/publication-shop/app/book/internal/data/ent/migrate"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"github.com/xuanyiying/publication-shop/app/book/internal/data/ent/author"
	"github.com/xuanyiying/publication-shop/app/book/internal/data/ent/book"
	"github.com/xuanyiying/publication-shop/app/book/internal/data/ent/bookauthor"
	"github.com/xuanyiying/publication-shop/app/book/internal/data/ent/bookdetail"
	"github.com/xuanyiying/publication-shop/app/book/internal/data/ent/bookimage"
	"github.com/xuanyiying/publication-shop/app/book/internal/data/ent/bookstock"
	"github.com/xuanyiying/publication-shop/app/book/internal/data/ent/bookxcatalog"
	"github.com/xuanyiying/publication-shop/app/book/internal/data/ent/bookxclassic"
	"github.com/xuanyiying/publication-shop/app/book/internal/data/ent/bookxlanguage"
	"github.com/xuanyiying/publication-shop/app/book/internal/data/ent/category"
	"github.com/xuanyiying/publication-shop/app/book/internal/data/ent/classic"
	"github.com/xuanyiying/publication-shop/app/book/internal/data/ent/language"
	"github.com/xuanyiying/publication-shop/app/book/internal/data/ent/publisher"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// Author is the client for interacting with the Author builders.
	Author *AuthorClient
	// Book is the client for interacting with the Book builders.
	Book *BookClient
	// BookAuthor is the client for interacting with the BookAuthor builders.
	BookAuthor *BookAuthorClient
	// BookDetail is the client for interacting with the BookDetail builders.
	BookDetail *BookDetailClient
	// BookImage is the client for interacting with the BookImage builders.
	BookImage *BookImageClient
	// BookStock is the client for interacting with the BookStock builders.
	BookStock *BookStockClient
	// BookXCatalog is the client for interacting with the BookXCatalog builders.
	BookXCatalog *BookXCatalogClient
	// BookXClassic is the client for interacting with the BookXClassic builders.
	BookXClassic *BookXClassicClient
	// BookXLanguage is the client for interacting with the BookXLanguage builders.
	BookXLanguage *BookXLanguageClient
	// Category is the client for interacting with the Category builders.
	Category *CategoryClient
	// Classic is the client for interacting with the Classic builders.
	Classic *ClassicClient
	// Language is the client for interacting with the Language builders.
	Language *LanguageClient
	// Publisher is the client for interacting with the Publisher builders.
	Publisher *PublisherClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	client := &Client{config: newConfig(opts...)}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.Author = NewAuthorClient(c.config)
	c.Book = NewBookClient(c.config)
	c.BookAuthor = NewBookAuthorClient(c.config)
	c.BookDetail = NewBookDetailClient(c.config)
	c.BookImage = NewBookImageClient(c.config)
	c.BookStock = NewBookStockClient(c.config)
	c.BookXCatalog = NewBookXCatalogClient(c.config)
	c.BookXClassic = NewBookXClassicClient(c.config)
	c.BookXLanguage = NewBookXLanguageClient(c.config)
	c.Category = NewCategoryClient(c.config)
	c.Classic = NewClassicClient(c.config)
	c.Language = NewLanguageClient(c.config)
	c.Publisher = NewPublisherClient(c.config)
}

type (
	// config is the configuration for the client and its builder.
	config struct {
		// driver used for executing database requests.
		driver dialect.Driver
		// debug enable a debug logging.
		debug bool
		// log used for logging on debug mode.
		log func(...any)
		// hooks to execute on mutations.
		hooks *hooks
		// interceptors to execute on queries.
		inters *inters
	}
	// Option function to configure the client.
	Option func(*config)
)

// newConfig creates a new config for the client.
func newConfig(opts ...Option) config {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	return cfg
}

// options applies the options on the config object.
func (c *config) options(opts ...Option) {
	for _, opt := range opts {
		opt(c)
	}
	if c.debug {
		c.driver = dialect.Debug(c.driver, c.log)
	}
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option {
	return func(c *config) {
		c.debug = true
	}
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option {
	return func(c *config) {
		c.log = fn
	}
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option {
	return func(c *config) {
		c.driver = driver
	}
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// ErrTxStarted is returned when trying to start a new transaction from a transactional client.
var ErrTxStarted = errors.New("ent: cannot start a transaction within a transaction")

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, ErrTxStarted
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:           ctx,
		config:        cfg,
		Author:        NewAuthorClient(cfg),
		Book:          NewBookClient(cfg),
		BookAuthor:    NewBookAuthorClient(cfg),
		BookDetail:    NewBookDetailClient(cfg),
		BookImage:     NewBookImageClient(cfg),
		BookStock:     NewBookStockClient(cfg),
		BookXCatalog:  NewBookXCatalogClient(cfg),
		BookXClassic:  NewBookXClassicClient(cfg),
		BookXLanguage: NewBookXLanguageClient(cfg),
		Category:      NewCategoryClient(cfg),
		Classic:       NewClassicClient(cfg),
		Language:      NewLanguageClient(cfg),
		Publisher:     NewPublisherClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:           ctx,
		config:        cfg,
		Author:        NewAuthorClient(cfg),
		Book:          NewBookClient(cfg),
		BookAuthor:    NewBookAuthorClient(cfg),
		BookDetail:    NewBookDetailClient(cfg),
		BookImage:     NewBookImageClient(cfg),
		BookStock:     NewBookStockClient(cfg),
		BookXCatalog:  NewBookXCatalogClient(cfg),
		BookXClassic:  NewBookXClassicClient(cfg),
		BookXLanguage: NewBookXLanguageClient(cfg),
		Category:      NewCategoryClient(cfg),
		Classic:       NewClassicClient(cfg),
		Language:      NewLanguageClient(cfg),
		Publisher:     NewPublisherClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		Author.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	for _, n := range []interface{ Use(...Hook) }{
		c.Author, c.Book, c.BookAuthor, c.BookDetail, c.BookImage, c.BookStock,
		c.BookXCatalog, c.BookXClassic, c.BookXLanguage, c.Category, c.Classic,
		c.Language, c.Publisher,
	} {
		n.Use(hooks...)
	}
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	for _, n := range []interface{ Intercept(...Interceptor) }{
		c.Author, c.Book, c.BookAuthor, c.BookDetail, c.BookImage, c.BookStock,
		c.BookXCatalog, c.BookXClassic, c.BookXLanguage, c.Category, c.Classic,
		c.Language, c.Publisher,
	} {
		n.Intercept(interceptors...)
	}
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *AuthorMutation:
		return c.Author.mutate(ctx, m)
	case *BookMutation:
		return c.Book.mutate(ctx, m)
	case *BookAuthorMutation:
		return c.BookAuthor.mutate(ctx, m)
	case *BookDetailMutation:
		return c.BookDetail.mutate(ctx, m)
	case *BookImageMutation:
		return c.BookImage.mutate(ctx, m)
	case *BookStockMutation:
		return c.BookStock.mutate(ctx, m)
	case *BookXCatalogMutation:
		return c.BookXCatalog.mutate(ctx, m)
	case *BookXClassicMutation:
		return c.BookXClassic.mutate(ctx, m)
	case *BookXLanguageMutation:
		return c.BookXLanguage.mutate(ctx, m)
	case *CategoryMutation:
		return c.Category.mutate(ctx, m)
	case *ClassicMutation:
		return c.Classic.mutate(ctx, m)
	case *LanguageMutation:
		return c.Language.mutate(ctx, m)
	case *PublisherMutation:
		return c.Publisher.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("ent: unknown mutation type %T", m)
	}
}

// AuthorClient is a client for the Author schema.
type AuthorClient struct {
	config
}

// NewAuthorClient returns a client for the Author from the given config.
func NewAuthorClient(c config) *AuthorClient {
	return &AuthorClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `author.Hooks(f(g(h())))`.
func (c *AuthorClient) Use(hooks ...Hook) {
	c.hooks.Author = append(c.hooks.Author, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `author.Intercept(f(g(h())))`.
func (c *AuthorClient) Intercept(interceptors ...Interceptor) {
	c.inters.Author = append(c.inters.Author, interceptors...)
}

// Create returns a builder for creating a Author entity.
func (c *AuthorClient) Create() *AuthorCreate {
	mutation := newAuthorMutation(c.config, OpCreate)
	return &AuthorCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Author entities.
func (c *AuthorClient) CreateBulk(builders ...*AuthorCreate) *AuthorCreateBulk {
	return &AuthorCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AuthorClient) MapCreateBulk(slice any, setFunc func(*AuthorCreate, int)) *AuthorCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AuthorCreateBulk{err: fmt.Errorf("calling to AuthorClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AuthorCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AuthorCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Author.
func (c *AuthorClient) Update() *AuthorUpdate {
	mutation := newAuthorMutation(c.config, OpUpdate)
	return &AuthorUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AuthorClient) UpdateOne(a *Author) *AuthorUpdateOne {
	mutation := newAuthorMutation(c.config, OpUpdateOne, withAuthor(a))
	return &AuthorUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AuthorClient) UpdateOneID(id int32) *AuthorUpdateOne {
	mutation := newAuthorMutation(c.config, OpUpdateOne, withAuthorID(id))
	return &AuthorUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Author.
func (c *AuthorClient) Delete() *AuthorDelete {
	mutation := newAuthorMutation(c.config, OpDelete)
	return &AuthorDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AuthorClient) DeleteOne(a *Author) *AuthorDeleteOne {
	return c.DeleteOneID(a.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AuthorClient) DeleteOneID(id int32) *AuthorDeleteOne {
	builder := c.Delete().Where(author.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AuthorDeleteOne{builder}
}

// Query returns a query builder for Author.
func (c *AuthorClient) Query() *AuthorQuery {
	return &AuthorQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAuthor},
		inters: c.Interceptors(),
	}
}

// Get returns a Author entity by its id.
func (c *AuthorClient) Get(ctx context.Context, id int32) (*Author, error) {
	return c.Query().Where(author.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AuthorClient) GetX(ctx context.Context, id int32) *Author {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *AuthorClient) Hooks() []Hook {
	return c.hooks.Author
}

// Interceptors returns the client interceptors.
func (c *AuthorClient) Interceptors() []Interceptor {
	return c.inters.Author
}

func (c *AuthorClient) mutate(ctx context.Context, m *AuthorMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AuthorCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AuthorUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AuthorUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AuthorDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Author mutation op: %q", m.Op())
	}
}

// BookClient is a client for the Book schema.
type BookClient struct {
	config
}

// NewBookClient returns a client for the Book from the given config.
func NewBookClient(c config) *BookClient {
	return &BookClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `book.Hooks(f(g(h())))`.
func (c *BookClient) Use(hooks ...Hook) {
	c.hooks.Book = append(c.hooks.Book, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `book.Intercept(f(g(h())))`.
func (c *BookClient) Intercept(interceptors ...Interceptor) {
	c.inters.Book = append(c.inters.Book, interceptors...)
}

// Create returns a builder for creating a Book entity.
func (c *BookClient) Create() *BookCreate {
	mutation := newBookMutation(c.config, OpCreate)
	return &BookCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Book entities.
func (c *BookClient) CreateBulk(builders ...*BookCreate) *BookCreateBulk {
	return &BookCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *BookClient) MapCreateBulk(slice any, setFunc func(*BookCreate, int)) *BookCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &BookCreateBulk{err: fmt.Errorf("calling to BookClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*BookCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &BookCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Book.
func (c *BookClient) Update() *BookUpdate {
	mutation := newBookMutation(c.config, OpUpdate)
	return &BookUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *BookClient) UpdateOne(b *Book) *BookUpdateOne {
	mutation := newBookMutation(c.config, OpUpdateOne, withBook(b))
	return &BookUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *BookClient) UpdateOneID(id int) *BookUpdateOne {
	mutation := newBookMutation(c.config, OpUpdateOne, withBookID(id))
	return &BookUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Book.
func (c *BookClient) Delete() *BookDelete {
	mutation := newBookMutation(c.config, OpDelete)
	return &BookDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *BookClient) DeleteOne(b *Book) *BookDeleteOne {
	return c.DeleteOneID(b.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *BookClient) DeleteOneID(id int64) *BookDeleteOne {
	builder := c.Delete().Where(book.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &BookDeleteOne{builder}
}

// Query returns a query builder for Book.
func (c *BookClient) Query() *BookQuery {
	return &BookQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeBook},
		inters: c.Interceptors(),
	}
}

// Get returns a Book entity by its id.
func (c *BookClient) Get(ctx context.Context, id int64) (*Book, error) {
	return c.Query().Where(book.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *BookClient) GetX(ctx context.Context, id int64) *Book {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *BookClient) Hooks() []Hook {
	return c.hooks.Book
}

// Interceptors returns the client interceptors.
func (c *BookClient) Interceptors() []Interceptor {
	return c.inters.Book
}

func (c *BookClient) mutate(ctx context.Context, m *BookMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&BookCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&BookUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&BookUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&BookDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Book mutation op: %q", m.Op())
	}
}

// BookAuthorClient is a client for the BookAuthor schema.
type BookAuthorClient struct {
	config
}

// NewBookAuthorClient returns a client for the BookAuthor from the given config.
func NewBookAuthorClient(c config) *BookAuthorClient {
	return &BookAuthorClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `bookauthor.Hooks(f(g(h())))`.
func (c *BookAuthorClient) Use(hooks ...Hook) {
	c.hooks.BookAuthor = append(c.hooks.BookAuthor, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `bookauthor.Intercept(f(g(h())))`.
func (c *BookAuthorClient) Intercept(interceptors ...Interceptor) {
	c.inters.BookAuthor = append(c.inters.BookAuthor, interceptors...)
}

// Create returns a builder for creating a BookAuthor entity.
func (c *BookAuthorClient) Create() *BookAuthorCreate {
	mutation := newBookAuthorMutation(c.config, OpCreate)
	return &BookAuthorCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of BookAuthor entities.
func (c *BookAuthorClient) CreateBulk(builders ...*BookAuthorCreate) *BookAuthorCreateBulk {
	return &BookAuthorCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *BookAuthorClient) MapCreateBulk(slice any, setFunc func(*BookAuthorCreate, int)) *BookAuthorCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &BookAuthorCreateBulk{err: fmt.Errorf("calling to BookAuthorClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*BookAuthorCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &BookAuthorCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for BookAuthor.
func (c *BookAuthorClient) Update() *BookAuthorUpdate {
	mutation := newBookAuthorMutation(c.config, OpUpdate)
	return &BookAuthorUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *BookAuthorClient) UpdateOne(ba *BookAuthor) *BookAuthorUpdateOne {
	mutation := newBookAuthorMutation(c.config, OpUpdateOne, withBookAuthor(ba))
	return &BookAuthorUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *BookAuthorClient) UpdateOneID(id int) *BookAuthorUpdateOne {
	mutation := newBookAuthorMutation(c.config, OpUpdateOne, withBookAuthorID(id))
	return &BookAuthorUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for BookAuthor.
func (c *BookAuthorClient) Delete() *BookAuthorDelete {
	mutation := newBookAuthorMutation(c.config, OpDelete)
	return &BookAuthorDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *BookAuthorClient) DeleteOne(ba *BookAuthor) *BookAuthorDeleteOne {
	return c.DeleteOneID(ba.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *BookAuthorClient) DeleteOneID(id int) *BookAuthorDeleteOne {
	builder := c.Delete().Where(bookauthor.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &BookAuthorDeleteOne{builder}
}

// Query returns a query builder for BookAuthor.
func (c *BookAuthorClient) Query() *BookAuthorQuery {
	return &BookAuthorQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeBookAuthor},
		inters: c.Interceptors(),
	}
}

// Get returns a BookAuthor entity by its id.
func (c *BookAuthorClient) Get(ctx context.Context, id int) (*BookAuthor, error) {
	return c.Query().Where(bookauthor.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *BookAuthorClient) GetX(ctx context.Context, id int) *BookAuthor {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *BookAuthorClient) Hooks() []Hook {
	return c.hooks.BookAuthor
}

// Interceptors returns the client interceptors.
func (c *BookAuthorClient) Interceptors() []Interceptor {
	return c.inters.BookAuthor
}

func (c *BookAuthorClient) mutate(ctx context.Context, m *BookAuthorMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&BookAuthorCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&BookAuthorUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&BookAuthorUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&BookAuthorDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown BookAuthor mutation op: %q", m.Op())
	}
}

// BookDetailClient is a client for the BookDetail schema.
type BookDetailClient struct {
	config
}

// NewBookDetailClient returns a client for the BookDetail from the given config.
func NewBookDetailClient(c config) *BookDetailClient {
	return &BookDetailClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `bookdetail.Hooks(f(g(h())))`.
func (c *BookDetailClient) Use(hooks ...Hook) {
	c.hooks.BookDetail = append(c.hooks.BookDetail, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `bookdetail.Intercept(f(g(h())))`.
func (c *BookDetailClient) Intercept(interceptors ...Interceptor) {
	c.inters.BookDetail = append(c.inters.BookDetail, interceptors...)
}

// Create returns a builder for creating a BookDetail entity.
func (c *BookDetailClient) Create() *BookDetailCreate {
	mutation := newBookDetailMutation(c.config, OpCreate)
	return &BookDetailCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of BookDetail entities.
func (c *BookDetailClient) CreateBulk(builders ...*BookDetailCreate) *BookDetailCreateBulk {
	return &BookDetailCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *BookDetailClient) MapCreateBulk(slice any, setFunc func(*BookDetailCreate, int)) *BookDetailCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &BookDetailCreateBulk{err: fmt.Errorf("calling to BookDetailClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*BookDetailCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &BookDetailCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for BookDetail.
func (c *BookDetailClient) Update() *BookDetailUpdate {
	mutation := newBookDetailMutation(c.config, OpUpdate)
	return &BookDetailUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *BookDetailClient) UpdateOne(bd *BookDetail) *BookDetailUpdateOne {
	mutation := newBookDetailMutation(c.config, OpUpdateOne, withBookDetail(bd))
	return &BookDetailUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *BookDetailClient) UpdateOneID(id int) *BookDetailUpdateOne {
	mutation := newBookDetailMutation(c.config, OpUpdateOne, withBookDetailID(id))
	return &BookDetailUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for BookDetail.
func (c *BookDetailClient) Delete() *BookDetailDelete {
	mutation := newBookDetailMutation(c.config, OpDelete)
	return &BookDetailDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *BookDetailClient) DeleteOne(bd *BookDetail) *BookDetailDeleteOne {
	return c.DeleteOneID(bd.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *BookDetailClient) DeleteOneID(id int) *BookDetailDeleteOne {
	builder := c.Delete().Where(bookdetail.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &BookDetailDeleteOne{builder}
}

// Query returns a query builder for BookDetail.
func (c *BookDetailClient) Query() *BookDetailQuery {
	return &BookDetailQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeBookDetail},
		inters: c.Interceptors(),
	}
}

// Get returns a BookDetail entity by its id.
func (c *BookDetailClient) Get(ctx context.Context, id int) (*BookDetail, error) {
	return c.Query().Where(bookdetail.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *BookDetailClient) GetX(ctx context.Context, id int) *BookDetail {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *BookDetailClient) Hooks() []Hook {
	return c.hooks.BookDetail
}

// Interceptors returns the client interceptors.
func (c *BookDetailClient) Interceptors() []Interceptor {
	return c.inters.BookDetail
}

func (c *BookDetailClient) mutate(ctx context.Context, m *BookDetailMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&BookDetailCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&BookDetailUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&BookDetailUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&BookDetailDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown BookDetail mutation op: %q", m.Op())
	}
}

// BookImageClient is a client for the BookImage schema.
type BookImageClient struct {
	config
}

// NewBookImageClient returns a client for the BookImage from the given config.
func NewBookImageClient(c config) *BookImageClient {
	return &BookImageClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `bookimage.Hooks(f(g(h())))`.
func (c *BookImageClient) Use(hooks ...Hook) {
	c.hooks.BookImage = append(c.hooks.BookImage, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `bookimage.Intercept(f(g(h())))`.
func (c *BookImageClient) Intercept(interceptors ...Interceptor) {
	c.inters.BookImage = append(c.inters.BookImage, interceptors...)
}

// Create returns a builder for creating a BookImage entity.
func (c *BookImageClient) Create() *BookImageCreate {
	mutation := newBookImageMutation(c.config, OpCreate)
	return &BookImageCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of BookImage entities.
func (c *BookImageClient) CreateBulk(builders ...*BookImageCreate) *BookImageCreateBulk {
	return &BookImageCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *BookImageClient) MapCreateBulk(slice any, setFunc func(*BookImageCreate, int)) *BookImageCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &BookImageCreateBulk{err: fmt.Errorf("calling to BookImageClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*BookImageCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &BookImageCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for BookImage.
func (c *BookImageClient) Update() *BookImageUpdate {
	mutation := newBookImageMutation(c.config, OpUpdate)
	return &BookImageUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *BookImageClient) UpdateOne(bi *BookImage) *BookImageUpdateOne {
	mutation := newBookImageMutation(c.config, OpUpdateOne, withBookImage(bi))
	return &BookImageUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *BookImageClient) UpdateOneID(id int) *BookImageUpdateOne {
	mutation := newBookImageMutation(c.config, OpUpdateOne, withBookImageID(id))
	return &BookImageUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for BookImage.
func (c *BookImageClient) Delete() *BookImageDelete {
	mutation := newBookImageMutation(c.config, OpDelete)
	return &BookImageDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *BookImageClient) DeleteOne(bi *BookImage) *BookImageDeleteOne {
	return c.DeleteOneID(bi.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *BookImageClient) DeleteOneID(id int) *BookImageDeleteOne {
	builder := c.Delete().Where(bookimage.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &BookImageDeleteOne{builder}
}

// Query returns a query builder for BookImage.
func (c *BookImageClient) Query() *BookImageQuery {
	return &BookImageQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeBookImage},
		inters: c.Interceptors(),
	}
}

// Get returns a BookImage entity by its id.
func (c *BookImageClient) Get(ctx context.Context, id int) (*BookImage, error) {
	return c.Query().Where(bookimage.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *BookImageClient) GetX(ctx context.Context, id int) *BookImage {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *BookImageClient) Hooks() []Hook {
	return c.hooks.BookImage
}

// Interceptors returns the client interceptors.
func (c *BookImageClient) Interceptors() []Interceptor {
	return c.inters.BookImage
}

func (c *BookImageClient) mutate(ctx context.Context, m *BookImageMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&BookImageCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&BookImageUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&BookImageUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&BookImageDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown BookImage mutation op: %q", m.Op())
	}
}

// BookStockClient is a client for the BookStock schema.
type BookStockClient struct {
	config
}

// NewBookStockClient returns a client for the BookStock from the given config.
func NewBookStockClient(c config) *BookStockClient {
	return &BookStockClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `bookstock.Hooks(f(g(h())))`.
func (c *BookStockClient) Use(hooks ...Hook) {
	c.hooks.BookStock = append(c.hooks.BookStock, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `bookstock.Intercept(f(g(h())))`.
func (c *BookStockClient) Intercept(interceptors ...Interceptor) {
	c.inters.BookStock = append(c.inters.BookStock, interceptors...)
}

// Create returns a builder for creating a BookStock entity.
func (c *BookStockClient) Create() *BookStockCreate {
	mutation := newBookStockMutation(c.config, OpCreate)
	return &BookStockCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of BookStock entities.
func (c *BookStockClient) CreateBulk(builders ...*BookStockCreate) *BookStockCreateBulk {
	return &BookStockCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *BookStockClient) MapCreateBulk(slice any, setFunc func(*BookStockCreate, int)) *BookStockCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &BookStockCreateBulk{err: fmt.Errorf("calling to BookStockClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*BookStockCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &BookStockCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for BookStock.
func (c *BookStockClient) Update() *BookStockUpdate {
	mutation := newBookStockMutation(c.config, OpUpdate)
	return &BookStockUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *BookStockClient) UpdateOne(bs *BookStock) *BookStockUpdateOne {
	mutation := newBookStockMutation(c.config, OpUpdateOne, withBookStock(bs))
	return &BookStockUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *BookStockClient) UpdateOneID(id int) *BookStockUpdateOne {
	mutation := newBookStockMutation(c.config, OpUpdateOne, withBookStockID(id))
	return &BookStockUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for BookStock.
func (c *BookStockClient) Delete() *BookStockDelete {
	mutation := newBookStockMutation(c.config, OpDelete)
	return &BookStockDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *BookStockClient) DeleteOne(bs *BookStock) *BookStockDeleteOne {
	return c.DeleteOneID(bs.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *BookStockClient) DeleteOneID(id int64) *BookStockDeleteOne {
	builder := c.Delete().Where(bookstock.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &BookStockDeleteOne{builder}
}

// Query returns a query builder for BookStock.
func (c *BookStockClient) Query() *BookStockQuery {
	return &BookStockQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeBookStock},
		inters: c.Interceptors(),
	}
}

// Get returns a BookStock entity by its id.
func (c *BookStockClient) Get(ctx context.Context, id int64) (*BookStock, error) {
	return c.Query().Where(bookstock.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *BookStockClient) GetX(ctx context.Context, id int64) *BookStock {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *BookStockClient) Hooks() []Hook {
	return c.hooks.BookStock
}

// Interceptors returns the client interceptors.
func (c *BookStockClient) Interceptors() []Interceptor {
	return c.inters.BookStock
}

func (c *BookStockClient) mutate(ctx context.Context, m *BookStockMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&BookStockCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&BookStockUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&BookStockUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&BookStockDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown BookStock mutation op: %q", m.Op())
	}
}

// BookXCatalogClient is a client for the BookXCatalog schema.
type BookXCatalogClient struct {
	config
}

// NewBookXCatalogClient returns a client for the BookXCatalog from the given config.
func NewBookXCatalogClient(c config) *BookXCatalogClient {
	return &BookXCatalogClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `bookxcatalog.Hooks(f(g(h())))`.
func (c *BookXCatalogClient) Use(hooks ...Hook) {
	c.hooks.BookXCatalog = append(c.hooks.BookXCatalog, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `bookxcatalog.Intercept(f(g(h())))`.
func (c *BookXCatalogClient) Intercept(interceptors ...Interceptor) {
	c.inters.BookXCatalog = append(c.inters.BookXCatalog, interceptors...)
}

// Create returns a builder for creating a BookXCatalog entity.
func (c *BookXCatalogClient) Create() *BookXCatalogCreate {
	mutation := newBookXCatalogMutation(c.config, OpCreate)
	return &BookXCatalogCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of BookXCatalog entities.
func (c *BookXCatalogClient) CreateBulk(builders ...*BookXCatalogCreate) *BookXCatalogCreateBulk {
	return &BookXCatalogCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *BookXCatalogClient) MapCreateBulk(slice any, setFunc func(*BookXCatalogCreate, int)) *BookXCatalogCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &BookXCatalogCreateBulk{err: fmt.Errorf("calling to BookXCatalogClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*BookXCatalogCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &BookXCatalogCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for BookXCatalog.
func (c *BookXCatalogClient) Update() *BookXCatalogUpdate {
	mutation := newBookXCatalogMutation(c.config, OpUpdate)
	return &BookXCatalogUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *BookXCatalogClient) UpdateOne(bx *BookXCatalog) *BookXCatalogUpdateOne {
	mutation := newBookXCatalogMutation(c.config, OpUpdateOne, withBookXCatalog(bx))
	return &BookXCatalogUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *BookXCatalogClient) UpdateOneID(id int) *BookXCatalogUpdateOne {
	mutation := newBookXCatalogMutation(c.config, OpUpdateOne, withBookXCatalogID(id))
	return &BookXCatalogUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for BookXCatalog.
func (c *BookXCatalogClient) Delete() *BookXCatalogDelete {
	mutation := newBookXCatalogMutation(c.config, OpDelete)
	return &BookXCatalogDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *BookXCatalogClient) DeleteOne(bx *BookXCatalog) *BookXCatalogDeleteOne {
	return c.DeleteOneID(bx.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *BookXCatalogClient) DeleteOneID(id int) *BookXCatalogDeleteOne {
	builder := c.Delete().Where(bookxcatalog.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &BookXCatalogDeleteOne{builder}
}

// Query returns a query builder for BookXCatalog.
func (c *BookXCatalogClient) Query() *BookXCatalogQuery {
	return &BookXCatalogQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeBookXCatalog},
		inters: c.Interceptors(),
	}
}

// Get returns a BookXCatalog entity by its id.
func (c *BookXCatalogClient) Get(ctx context.Context, id int) (*BookXCatalog, error) {
	return c.Query().Where(bookxcatalog.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *BookXCatalogClient) GetX(ctx context.Context, id int) *BookXCatalog {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *BookXCatalogClient) Hooks() []Hook {
	return c.hooks.BookXCatalog
}

// Interceptors returns the client interceptors.
func (c *BookXCatalogClient) Interceptors() []Interceptor {
	return c.inters.BookXCatalog
}

func (c *BookXCatalogClient) mutate(ctx context.Context, m *BookXCatalogMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&BookXCatalogCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&BookXCatalogUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&BookXCatalogUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&BookXCatalogDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown BookXCatalog mutation op: %q", m.Op())
	}
}

// BookXClassicClient is a client for the BookXClassic schema.
type BookXClassicClient struct {
	config
}

// NewBookXClassicClient returns a client for the BookXClassic from the given config.
func NewBookXClassicClient(c config) *BookXClassicClient {
	return &BookXClassicClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `bookxclassic.Hooks(f(g(h())))`.
func (c *BookXClassicClient) Use(hooks ...Hook) {
	c.hooks.BookXClassic = append(c.hooks.BookXClassic, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `bookxclassic.Intercept(f(g(h())))`.
func (c *BookXClassicClient) Intercept(interceptors ...Interceptor) {
	c.inters.BookXClassic = append(c.inters.BookXClassic, interceptors...)
}

// Create returns a builder for creating a BookXClassic entity.
func (c *BookXClassicClient) Create() *BookXClassicCreate {
	mutation := newBookXClassicMutation(c.config, OpCreate)
	return &BookXClassicCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of BookXClassic entities.
func (c *BookXClassicClient) CreateBulk(builders ...*BookXClassicCreate) *BookXClassicCreateBulk {
	return &BookXClassicCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *BookXClassicClient) MapCreateBulk(slice any, setFunc func(*BookXClassicCreate, int)) *BookXClassicCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &BookXClassicCreateBulk{err: fmt.Errorf("calling to BookXClassicClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*BookXClassicCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &BookXClassicCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for BookXClassic.
func (c *BookXClassicClient) Update() *BookXClassicUpdate {
	mutation := newBookXClassicMutation(c.config, OpUpdate)
	return &BookXClassicUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *BookXClassicClient) UpdateOne(bx *BookXClassic) *BookXClassicUpdateOne {
	mutation := newBookXClassicMutation(c.config, OpUpdateOne, withBookXClassic(bx))
	return &BookXClassicUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *BookXClassicClient) UpdateOneID(id int) *BookXClassicUpdateOne {
	mutation := newBookXClassicMutation(c.config, OpUpdateOne, withBookXClassicID(id))
	return &BookXClassicUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for BookXClassic.
func (c *BookXClassicClient) Delete() *BookXClassicDelete {
	mutation := newBookXClassicMutation(c.config, OpDelete)
	return &BookXClassicDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *BookXClassicClient) DeleteOne(bx *BookXClassic) *BookXClassicDeleteOne {
	return c.DeleteOneID(bx.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *BookXClassicClient) DeleteOneID(id int) *BookXClassicDeleteOne {
	builder := c.Delete().Where(bookxclassic.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &BookXClassicDeleteOne{builder}
}

// Query returns a query builder for BookXClassic.
func (c *BookXClassicClient) Query() *BookXClassicQuery {
	return &BookXClassicQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeBookXClassic},
		inters: c.Interceptors(),
	}
}

// Get returns a BookXClassic entity by its id.
func (c *BookXClassicClient) Get(ctx context.Context, id int) (*BookXClassic, error) {
	return c.Query().Where(bookxclassic.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *BookXClassicClient) GetX(ctx context.Context, id int) *BookXClassic {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *BookXClassicClient) Hooks() []Hook {
	return c.hooks.BookXClassic
}

// Interceptors returns the client interceptors.
func (c *BookXClassicClient) Interceptors() []Interceptor {
	return c.inters.BookXClassic
}

func (c *BookXClassicClient) mutate(ctx context.Context, m *BookXClassicMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&BookXClassicCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&BookXClassicUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&BookXClassicUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&BookXClassicDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown BookXClassic mutation op: %q", m.Op())
	}
}

// BookXLanguageClient is a client for the BookXLanguage schema.
type BookXLanguageClient struct {
	config
}

// NewBookXLanguageClient returns a client for the BookXLanguage from the given config.
func NewBookXLanguageClient(c config) *BookXLanguageClient {
	return &BookXLanguageClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `bookxlanguage.Hooks(f(g(h())))`.
func (c *BookXLanguageClient) Use(hooks ...Hook) {
	c.hooks.BookXLanguage = append(c.hooks.BookXLanguage, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `bookxlanguage.Intercept(f(g(h())))`.
func (c *BookXLanguageClient) Intercept(interceptors ...Interceptor) {
	c.inters.BookXLanguage = append(c.inters.BookXLanguage, interceptors...)
}

// Create returns a builder for creating a BookXLanguage entity.
func (c *BookXLanguageClient) Create() *BookXLanguageCreate {
	mutation := newBookXLanguageMutation(c.config, OpCreate)
	return &BookXLanguageCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of BookXLanguage entities.
func (c *BookXLanguageClient) CreateBulk(builders ...*BookXLanguageCreate) *BookXLanguageCreateBulk {
	return &BookXLanguageCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *BookXLanguageClient) MapCreateBulk(slice any, setFunc func(*BookXLanguageCreate, int)) *BookXLanguageCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &BookXLanguageCreateBulk{err: fmt.Errorf("calling to BookXLanguageClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*BookXLanguageCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &BookXLanguageCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for BookXLanguage.
func (c *BookXLanguageClient) Update() *BookXLanguageUpdate {
	mutation := newBookXLanguageMutation(c.config, OpUpdate)
	return &BookXLanguageUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *BookXLanguageClient) UpdateOne(bx *BookXLanguage) *BookXLanguageUpdateOne {
	mutation := newBookXLanguageMutation(c.config, OpUpdateOne, withBookXLanguage(bx))
	return &BookXLanguageUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *BookXLanguageClient) UpdateOneID(id int) *BookXLanguageUpdateOne {
	mutation := newBookXLanguageMutation(c.config, OpUpdateOne, withBookXLanguageID(id))
	return &BookXLanguageUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for BookXLanguage.
func (c *BookXLanguageClient) Delete() *BookXLanguageDelete {
	mutation := newBookXLanguageMutation(c.config, OpDelete)
	return &BookXLanguageDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *BookXLanguageClient) DeleteOne(bx *BookXLanguage) *BookXLanguageDeleteOne {
	return c.DeleteOneID(bx.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *BookXLanguageClient) DeleteOneID(id int) *BookXLanguageDeleteOne {
	builder := c.Delete().Where(bookxlanguage.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &BookXLanguageDeleteOne{builder}
}

// Query returns a query builder for BookXLanguage.
func (c *BookXLanguageClient) Query() *BookXLanguageQuery {
	return &BookXLanguageQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeBookXLanguage},
		inters: c.Interceptors(),
	}
}

// Get returns a BookXLanguage entity by its id.
func (c *BookXLanguageClient) Get(ctx context.Context, id int) (*BookXLanguage, error) {
	return c.Query().Where(bookxlanguage.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *BookXLanguageClient) GetX(ctx context.Context, id int) *BookXLanguage {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *BookXLanguageClient) Hooks() []Hook {
	return c.hooks.BookXLanguage
}

// Interceptors returns the client interceptors.
func (c *BookXLanguageClient) Interceptors() []Interceptor {
	return c.inters.BookXLanguage
}

func (c *BookXLanguageClient) mutate(ctx context.Context, m *BookXLanguageMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&BookXLanguageCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&BookXLanguageUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&BookXLanguageUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&BookXLanguageDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown BookXLanguage mutation op: %q", m.Op())
	}
}

// CategoryClient is a client for the Category schema.
type CategoryClient struct {
	config
}

// NewCategoryClient returns a client for the Category from the given config.
func NewCategoryClient(c config) *CategoryClient {
	return &CategoryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `category.Hooks(f(g(h())))`.
func (c *CategoryClient) Use(hooks ...Hook) {
	c.hooks.Category = append(c.hooks.Category, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `category.Intercept(f(g(h())))`.
func (c *CategoryClient) Intercept(interceptors ...Interceptor) {
	c.inters.Category = append(c.inters.Category, interceptors...)
}

// Create returns a builder for creating a Category entity.
func (c *CategoryClient) Create() *CategoryCreate {
	mutation := newCategoryMutation(c.config, OpCreate)
	return &CategoryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Category entities.
func (c *CategoryClient) CreateBulk(builders ...*CategoryCreate) *CategoryCreateBulk {
	return &CategoryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CategoryClient) MapCreateBulk(slice any, setFunc func(*CategoryCreate, int)) *CategoryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CategoryCreateBulk{err: fmt.Errorf("calling to CategoryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CategoryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CategoryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Category.
func (c *CategoryClient) Update() *CategoryUpdate {
	mutation := newCategoryMutation(c.config, OpUpdate)
	return &CategoryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CategoryClient) UpdateOne(ca *Category) *CategoryUpdateOne {
	mutation := newCategoryMutation(c.config, OpUpdateOne, withCategory(ca))
	return &CategoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CategoryClient) UpdateOneID(id int) *CategoryUpdateOne {
	mutation := newCategoryMutation(c.config, OpUpdateOne, withCategoryID(id))
	return &CategoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Category.
func (c *CategoryClient) Delete() *CategoryDelete {
	mutation := newCategoryMutation(c.config, OpDelete)
	return &CategoryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CategoryClient) DeleteOne(ca *Category) *CategoryDeleteOne {
	return c.DeleteOneID(ca.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CategoryClient) DeleteOneID(id int) *CategoryDeleteOne {
	builder := c.Delete().Where(category.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CategoryDeleteOne{builder}
}

// Query returns a query builder for Category.
func (c *CategoryClient) Query() *CategoryQuery {
	return &CategoryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCategory},
		inters: c.Interceptors(),
	}
}

// Get returns a Category entity by its id.
func (c *CategoryClient) Get(ctx context.Context, id int) (*Category, error) {
	return c.Query().Where(category.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CategoryClient) GetX(ctx context.Context, id int) *Category {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *CategoryClient) Hooks() []Hook {
	return c.hooks.Category
}

// Interceptors returns the client interceptors.
func (c *CategoryClient) Interceptors() []Interceptor {
	return c.inters.Category
}

func (c *CategoryClient) mutate(ctx context.Context, m *CategoryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CategoryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CategoryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CategoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CategoryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Category mutation op: %q", m.Op())
	}
}

// ClassicClient is a client for the Classic schema.
type ClassicClient struct {
	config
}

// NewClassicClient returns a client for the Classic from the given config.
func NewClassicClient(c config) *ClassicClient {
	return &ClassicClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `classic.Hooks(f(g(h())))`.
func (c *ClassicClient) Use(hooks ...Hook) {
	c.hooks.Classic = append(c.hooks.Classic, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `classic.Intercept(f(g(h())))`.
func (c *ClassicClient) Intercept(interceptors ...Interceptor) {
	c.inters.Classic = append(c.inters.Classic, interceptors...)
}

// Create returns a builder for creating a Classic entity.
func (c *ClassicClient) Create() *ClassicCreate {
	mutation := newClassicMutation(c.config, OpCreate)
	return &ClassicCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Classic entities.
func (c *ClassicClient) CreateBulk(builders ...*ClassicCreate) *ClassicCreateBulk {
	return &ClassicCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ClassicClient) MapCreateBulk(slice any, setFunc func(*ClassicCreate, int)) *ClassicCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ClassicCreateBulk{err: fmt.Errorf("calling to ClassicClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ClassicCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ClassicCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Classic.
func (c *ClassicClient) Update() *ClassicUpdate {
	mutation := newClassicMutation(c.config, OpUpdate)
	return &ClassicUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ClassicClient) UpdateOne(cl *Classic) *ClassicUpdateOne {
	mutation := newClassicMutation(c.config, OpUpdateOne, withClassic(cl))
	return &ClassicUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ClassicClient) UpdateOneID(id int) *ClassicUpdateOne {
	mutation := newClassicMutation(c.config, OpUpdateOne, withClassicID(id))
	return &ClassicUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Classic.
func (c *ClassicClient) Delete() *ClassicDelete {
	mutation := newClassicMutation(c.config, OpDelete)
	return &ClassicDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ClassicClient) DeleteOne(cl *Classic) *ClassicDeleteOne {
	return c.DeleteOneID(cl.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ClassicClient) DeleteOneID(id int) *ClassicDeleteOne {
	builder := c.Delete().Where(classic.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ClassicDeleteOne{builder}
}

// Query returns a query builder for Classic.
func (c *ClassicClient) Query() *ClassicQuery {
	return &ClassicQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeClassic},
		inters: c.Interceptors(),
	}
}

// Get returns a Classic entity by its id.
func (c *ClassicClient) Get(ctx context.Context, id int) (*Classic, error) {
	return c.Query().Where(classic.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ClassicClient) GetX(ctx context.Context, id int) *Classic {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *ClassicClient) Hooks() []Hook {
	return c.hooks.Classic
}

// Interceptors returns the client interceptors.
func (c *ClassicClient) Interceptors() []Interceptor {
	return c.inters.Classic
}

func (c *ClassicClient) mutate(ctx context.Context, m *ClassicMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ClassicCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ClassicUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ClassicUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ClassicDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Classic mutation op: %q", m.Op())
	}
}

// LanguageClient is a client for the Language schema.
type LanguageClient struct {
	config
}

// NewLanguageClient returns a client for the Language from the given config.
func NewLanguageClient(c config) *LanguageClient {
	return &LanguageClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `language.Hooks(f(g(h())))`.
func (c *LanguageClient) Use(hooks ...Hook) {
	c.hooks.Language = append(c.hooks.Language, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `language.Intercept(f(g(h())))`.
func (c *LanguageClient) Intercept(interceptors ...Interceptor) {
	c.inters.Language = append(c.inters.Language, interceptors...)
}

// Create returns a builder for creating a Language entity.
func (c *LanguageClient) Create() *LanguageCreate {
	mutation := newLanguageMutation(c.config, OpCreate)
	return &LanguageCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Language entities.
func (c *LanguageClient) CreateBulk(builders ...*LanguageCreate) *LanguageCreateBulk {
	return &LanguageCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *LanguageClient) MapCreateBulk(slice any, setFunc func(*LanguageCreate, int)) *LanguageCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &LanguageCreateBulk{err: fmt.Errorf("calling to LanguageClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*LanguageCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &LanguageCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Language.
func (c *LanguageClient) Update() *LanguageUpdate {
	mutation := newLanguageMutation(c.config, OpUpdate)
	return &LanguageUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *LanguageClient) UpdateOne(l *Language) *LanguageUpdateOne {
	mutation := newLanguageMutation(c.config, OpUpdateOne, withLanguage(l))
	return &LanguageUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *LanguageClient) UpdateOneID(id int) *LanguageUpdateOne {
	mutation := newLanguageMutation(c.config, OpUpdateOne, withLanguageID(id))
	return &LanguageUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Language.
func (c *LanguageClient) Delete() *LanguageDelete {
	mutation := newLanguageMutation(c.config, OpDelete)
	return &LanguageDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *LanguageClient) DeleteOne(l *Language) *LanguageDeleteOne {
	return c.DeleteOneID(l.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *LanguageClient) DeleteOneID(id int) *LanguageDeleteOne {
	builder := c.Delete().Where(language.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &LanguageDeleteOne{builder}
}

// Query returns a query builder for Language.
func (c *LanguageClient) Query() *LanguageQuery {
	return &LanguageQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeLanguage},
		inters: c.Interceptors(),
	}
}

// Get returns a Language entity by its id.
func (c *LanguageClient) Get(ctx context.Context, id int) (*Language, error) {
	return c.Query().Where(language.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *LanguageClient) GetX(ctx context.Context, id int) *Language {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *LanguageClient) Hooks() []Hook {
	return c.hooks.Language
}

// Interceptors returns the client interceptors.
func (c *LanguageClient) Interceptors() []Interceptor {
	return c.inters.Language
}

func (c *LanguageClient) mutate(ctx context.Context, m *LanguageMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&LanguageCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&LanguageUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&LanguageUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&LanguageDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Language mutation op: %q", m.Op())
	}
}

// PublisherClient is a client for the Publisher schema.
type PublisherClient struct {
	config
}

// NewPublisherClient returns a client for the Publisher from the given config.
func NewPublisherClient(c config) *PublisherClient {
	return &PublisherClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `publisher.Hooks(f(g(h())))`.
func (c *PublisherClient) Use(hooks ...Hook) {
	c.hooks.Publisher = append(c.hooks.Publisher, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `publisher.Intercept(f(g(h())))`.
func (c *PublisherClient) Intercept(interceptors ...Interceptor) {
	c.inters.Publisher = append(c.inters.Publisher, interceptors...)
}

// Create returns a builder for creating a Publisher entity.
func (c *PublisherClient) Create() *PublisherCreate {
	mutation := newPublisherMutation(c.config, OpCreate)
	return &PublisherCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Publisher entities.
func (c *PublisherClient) CreateBulk(builders ...*PublisherCreate) *PublisherCreateBulk {
	return &PublisherCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PublisherClient) MapCreateBulk(slice any, setFunc func(*PublisherCreate, int)) *PublisherCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PublisherCreateBulk{err: fmt.Errorf("calling to PublisherClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PublisherCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PublisherCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Publisher.
func (c *PublisherClient) Update() *PublisherUpdate {
	mutation := newPublisherMutation(c.config, OpUpdate)
	return &PublisherUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PublisherClient) UpdateOne(pu *Publisher) *PublisherUpdateOne {
	mutation := newPublisherMutation(c.config, OpUpdateOne, withPublisher(pu))
	return &PublisherUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PublisherClient) UpdateOneID(id int) *PublisherUpdateOne {
	mutation := newPublisherMutation(c.config, OpUpdateOne, withPublisherID(id))
	return &PublisherUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Publisher.
func (c *PublisherClient) Delete() *PublisherDelete {
	mutation := newPublisherMutation(c.config, OpDelete)
	return &PublisherDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PublisherClient) DeleteOne(pu *Publisher) *PublisherDeleteOne {
	return c.DeleteOneID(pu.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PublisherClient) DeleteOneID(id int) *PublisherDeleteOne {
	builder := c.Delete().Where(publisher.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PublisherDeleteOne{builder}
}

// Query returns a query builder for Publisher.
func (c *PublisherClient) Query() *PublisherQuery {
	return &PublisherQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePublisher},
		inters: c.Interceptors(),
	}
}

// Get returns a Publisher entity by its id.
func (c *PublisherClient) Get(ctx context.Context, id int) (*Publisher, error) {
	return c.Query().Where(publisher.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PublisherClient) GetX(ctx context.Context, id int) *Publisher {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *PublisherClient) Hooks() []Hook {
	return c.hooks.Publisher
}

// Interceptors returns the client interceptors.
func (c *PublisherClient) Interceptors() []Interceptor {
	return c.inters.Publisher
}

func (c *PublisherClient) mutate(ctx context.Context, m *PublisherMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PublisherCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PublisherUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PublisherUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PublisherDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Publisher mutation op: %q", m.Op())
	}
}

// hooks and interceptors per client, for fast access.
type (
	hooks struct {
		Author, Book, BookAuthor, BookDetail, BookImage, BookStock, BookXCatalog,
		BookXClassic, BookXLanguage, Category, Classic, Language, Publisher []ent.Hook
	}
	inters struct {
		Author, Book, BookAuthor, BookDetail, BookImage, BookStock, BookXCatalog,
		BookXClassic, BookXLanguage, Category, Classic, Language,
		Publisher []ent.Interceptor
	}
)
