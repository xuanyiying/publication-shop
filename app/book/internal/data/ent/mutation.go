// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/xuanyiying/publication-shop/app/book/internal/data/ent/author"
	"github.com/xuanyiying/publication-shop/app/book/internal/data/ent/book"
	"github.com/xuanyiying/publication-shop/app/book/internal/data/ent/bookauthor"
	"github.com/xuanyiying/publication-shop/app/book/internal/data/ent/bookdetail"
	"github.com/xuanyiying/publication-shop/app/book/internal/data/ent/bookimage"
	"github.com/xuanyiying/publication-shop/app/book/internal/data/ent/bookstock"
	"github.com/xuanyiying/publication-shop/app/book/internal/data/ent/bookxcatalog"
	"github.com/xuanyiying/publication-shop/app/book/internal/data/ent/bookxclassic"
	"github.com/xuanyiying/publication-shop/app/book/internal/data/ent/bookxlanguage"
	"github.com/xuanyiying/publication-shop/app/book/internal/data/ent/category"
	"github.com/xuanyiying/publication-shop/app/book/internal/data/ent/classic"
	"github.com/xuanyiying/publication-shop/app/book/internal/data/ent/language"
	"github.com/xuanyiying/publication-shop/app/book/internal/data/ent/predicate"
	"github.com/xuanyiying/publication-shop/app/book/internal/data/ent/publisher"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAuthor        = "Author"
	TypeBook          = "Book"
	TypeBookAuthor    = "BookAuthor"
	TypeBookDetail    = "BookDetail"
	TypeBookImage     = "BookImage"
	TypeBookStock     = "BookStock"
	TypeBookXCatalog  = "BookXCatalog"
	TypeBookXClassic  = "BookXClassic"
	TypeBookXLanguage = "BookXLanguage"
	TypeCategory      = "Category"
	TypeClassic       = "Classic"
	TypeLanguage      = "Language"
	TypePublisher     = "Publisher"
)

// AuthorMutation represents an operation that mutates the Author nodes in the graph.
type AuthorMutation struct {
	config
	op            Op
	typ           string
	id            *int32
	name          *string
	biography     *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Author, error)
	predicates    []predicate.Author
}

var _ ent.Mutation = (*AuthorMutation)(nil)

// authorOption allows management of the mutation configuration using functional options.
type authorOption func(*AuthorMutation)

// newAuthorMutation creates new mutation for the Author entity.
func newAuthorMutation(c config, op Op, opts ...authorOption) *AuthorMutation {
	m := &AuthorMutation{
		config:        c,
		op:            op,
		typ:           TypeAuthor,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAuthorID sets the ID field of the mutation.
func withAuthorID(id int32) authorOption {
	return func(m *AuthorMutation) {
		var (
			err   error
			once  sync.Once
			value *Author
		)
		m.oldValue = func(ctx context.Context) (*Author, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Author.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAuthor sets the old Author of the mutation.
func withAuthor(node *Author) authorOption {
	return func(m *AuthorMutation) {
		m.oldValue = func(context.Context) (*Author, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AuthorMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AuthorMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Author entities.
func (m *AuthorMutation) SetID(id int32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AuthorMutation) ID() (id int32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AuthorMutation) IDs(ctx context.Context) ([]int32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Author.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *AuthorMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AuthorMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Author entity.
// If the Author object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthorMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *AuthorMutation) ResetName() {
	m.name = nil
}

// SetBiography sets the "biography" field.
func (m *AuthorMutation) SetBiography(s string) {
	m.biography = &s
}

// Biography returns the value of the "biography" field in the mutation.
func (m *AuthorMutation) Biography() (r string, exists bool) {
	v := m.biography
	if v == nil {
		return
	}
	return *v, true
}

// OldBiography returns the old "biography" field's value of the Author entity.
// If the Author object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthorMutation) OldBiography(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBiography is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBiography requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBiography: %w", err)
	}
	return oldValue.Biography, nil
}

// ClearBiography clears the value of the "biography" field.
func (m *AuthorMutation) ClearBiography() {
	m.biography = nil
	m.clearedFields[author.FieldBiography] = struct{}{}
}

// BiographyCleared returns if the "biography" field was cleared in this mutation.
func (m *AuthorMutation) BiographyCleared() bool {
	_, ok := m.clearedFields[author.FieldBiography]
	return ok
}

// ResetBiography resets all changes to the "biography" field.
func (m *AuthorMutation) ResetBiography() {
	m.biography = nil
	delete(m.clearedFields, author.FieldBiography)
}

// Where appends a list predicates to the AuthorMutation builder.
func (m *AuthorMutation) Where(ps ...predicate.Author) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AuthorMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AuthorMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Author, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AuthorMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AuthorMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Author).
func (m *AuthorMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AuthorMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.name != nil {
		fields = append(fields, author.FieldName)
	}
	if m.biography != nil {
		fields = append(fields, author.FieldBiography)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AuthorMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case author.FieldName:
		return m.Name()
	case author.FieldBiography:
		return m.Biography()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AuthorMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case author.FieldName:
		return m.OldName(ctx)
	case author.FieldBiography:
		return m.OldBiography(ctx)
	}
	return nil, fmt.Errorf("unknown Author field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuthorMutation) SetField(name string, value ent.Value) error {
	switch name {
	case author.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case author.FieldBiography:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBiography(v)
		return nil
	}
	return fmt.Errorf("unknown Author field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AuthorMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AuthorMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuthorMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Author numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AuthorMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(author.FieldBiography) {
		fields = append(fields, author.FieldBiography)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AuthorMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AuthorMutation) ClearField(name string) error {
	switch name {
	case author.FieldBiography:
		m.ClearBiography()
		return nil
	}
	return fmt.Errorf("unknown Author nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AuthorMutation) ResetField(name string) error {
	switch name {
	case author.FieldName:
		m.ResetName()
		return nil
	case author.FieldBiography:
		m.ResetBiography()
		return nil
	}
	return fmt.Errorf("unknown Author field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AuthorMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AuthorMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AuthorMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AuthorMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AuthorMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AuthorMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AuthorMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Author unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AuthorMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Author edge %s", name)
}

// BookMutation represents an operation that mutates the Book nodes in the graph.
type BookMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int64
	isbn                *string
	title               *string
	author              *string
	translator          *string
	publisher_id        *int
	addpublisher_id     *int
	publisher           *string
	publication_year    *int16
	addpublication_year *int16
	publication_date    *time.Time
	edition             *int8
	addedition          *int8
	category            *string
	price               *float64
	addprice            *float64
	quantity            *int
	addquantity         *int
	description         *string
	added_on            *time.Time
	cover_image         *string
	page_count          *int
	addpage_count       *int
	language_id         *int
	addlanguage_id      *int
	language            *string
	author_id           *int
	addauthor_id        *int
	category_id         *int
	addcategory_id      *int
	clearedFields       map[string]struct{}
	done                bool
	oldValue            func(context.Context) (*Book, error)
	predicates          []predicate.Book
}

var _ ent.Mutation = (*BookMutation)(nil)

// bookOption allows management of the mutation configuration using functional options.
type bookOption func(*BookMutation)

// newBookMutation creates new mutation for the Book entity.
func newBookMutation(c config, op Op, opts ...bookOption) *BookMutation {
	m := &BookMutation{
		config:        c,
		op:            op,
		typ:           TypeBook,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBookID sets the ID field of the mutation.
func withBookID(id int) bookOption {
	return func(m *BookMutation) {
		var (
			err   error
			once  sync.Once
			value *Book
		)
		m.oldValue = func(ctx context.Context) (*Book, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Book.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBook sets the old Book of the mutation.
func withBook(node *Book) bookOption {
	return func(m *BookMutation) {
		m.oldValue = func(context.Context) (*Book, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BookMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BookMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Book entities.
func (m *BookMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BookMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BookMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Book.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetIsbn sets the "isbn" field.
func (m *BookMutation) SetIsbn(s string) {
	m.isbn = &s
}

// Isbn returns the value of the "isbn" field in the mutation.
func (m *BookMutation) Isbn() (r string, exists bool) {
	v := m.isbn
	if v == nil {
		return
	}
	return *v, true
}

// OldIsbn returns the old "isbn" field's value of the Book entity.
// If the Book object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookMutation) OldIsbn(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsbn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsbn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsbn: %w", err)
	}
	return oldValue.Isbn, nil
}

// ResetIsbn resets all changes to the "isbn" field.
func (m *BookMutation) ResetIsbn() {
	m.isbn = nil
}

// SetTitle sets the "title" field.
func (m *BookMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *BookMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Book entity.
// If the Book object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *BookMutation) ResetTitle() {
	m.title = nil
}

// SetAuthor sets the "author" field.
func (m *BookMutation) SetAuthor(s string) {
	m.author = &s
}

// Author returns the value of the "author" field in the mutation.
func (m *BookMutation) Author() (r string, exists bool) {
	v := m.author
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthor returns the old "author" field's value of the Book entity.
// If the Book object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookMutation) OldAuthor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthor: %w", err)
	}
	return oldValue.Author, nil
}

// ResetAuthor resets all changes to the "author" field.
func (m *BookMutation) ResetAuthor() {
	m.author = nil
}

// SetTranslator sets the "translator" field.
func (m *BookMutation) SetTranslator(s string) {
	m.translator = &s
}

// Translator returns the value of the "translator" field in the mutation.
func (m *BookMutation) Translator() (r string, exists bool) {
	v := m.translator
	if v == nil {
		return
	}
	return *v, true
}

// OldTranslator returns the old "translator" field's value of the Book entity.
// If the Book object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookMutation) OldTranslator(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTranslator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTranslator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTranslator: %w", err)
	}
	return oldValue.Translator, nil
}

// ClearTranslator clears the value of the "translator" field.
func (m *BookMutation) ClearTranslator() {
	m.translator = nil
	m.clearedFields[book.FieldTranslator] = struct{}{}
}

// TranslatorCleared returns if the "translator" field was cleared in this mutation.
func (m *BookMutation) TranslatorCleared() bool {
	_, ok := m.clearedFields[book.FieldTranslator]
	return ok
}

// ResetTranslator resets all changes to the "translator" field.
func (m *BookMutation) ResetTranslator() {
	m.translator = nil
	delete(m.clearedFields, book.FieldTranslator)
}

// SetPublisherID sets the "publisher_id" field.
func (m *BookMutation) SetPublisherID(i int) {
	m.publisher_id = &i
	m.addpublisher_id = nil
}

// PublisherID returns the value of the "publisher_id" field in the mutation.
func (m *BookMutation) PublisherID() (r int, exists bool) {
	v := m.publisher_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPublisherID returns the old "publisher_id" field's value of the Book entity.
// If the Book object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookMutation) OldPublisherID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPublisherID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPublisherID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublisherID: %w", err)
	}
	return oldValue.PublisherID, nil
}

// AddPublisherID adds i to the "publisher_id" field.
func (m *BookMutation) AddPublisherID(i int) {
	if m.addpublisher_id != nil {
		*m.addpublisher_id += i
	} else {
		m.addpublisher_id = &i
	}
}

// AddedPublisherID returns the value that was added to the "publisher_id" field in this mutation.
func (m *BookMutation) AddedPublisherID() (r int, exists bool) {
	v := m.addpublisher_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearPublisherID clears the value of the "publisher_id" field.
func (m *BookMutation) ClearPublisherID() {
	m.publisher_id = nil
	m.addpublisher_id = nil
	m.clearedFields[book.FieldPublisherID] = struct{}{}
}

// PublisherIDCleared returns if the "publisher_id" field was cleared in this mutation.
func (m *BookMutation) PublisherIDCleared() bool {
	_, ok := m.clearedFields[book.FieldPublisherID]
	return ok
}

// ResetPublisherID resets all changes to the "publisher_id" field.
func (m *BookMutation) ResetPublisherID() {
	m.publisher_id = nil
	m.addpublisher_id = nil
	delete(m.clearedFields, book.FieldPublisherID)
}

// SetPublisher sets the "publisher" field.
func (m *BookMutation) SetPublisher(s string) {
	m.publisher = &s
}

// Publisher returns the value of the "publisher" field in the mutation.
func (m *BookMutation) Publisher() (r string, exists bool) {
	v := m.publisher
	if v == nil {
		return
	}
	return *v, true
}

// OldPublisher returns the old "publisher" field's value of the Book entity.
// If the Book object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookMutation) OldPublisher(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPublisher is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPublisher requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublisher: %w", err)
	}
	return oldValue.Publisher, nil
}

// ClearPublisher clears the value of the "publisher" field.
func (m *BookMutation) ClearPublisher() {
	m.publisher = nil
	m.clearedFields[book.FieldPublisher] = struct{}{}
}

// PublisherCleared returns if the "publisher" field was cleared in this mutation.
func (m *BookMutation) PublisherCleared() bool {
	_, ok := m.clearedFields[book.FieldPublisher]
	return ok
}

// ResetPublisher resets all changes to the "publisher" field.
func (m *BookMutation) ResetPublisher() {
	m.publisher = nil
	delete(m.clearedFields, book.FieldPublisher)
}

// SetPublicationYear sets the "publication_year" field.
func (m *BookMutation) SetPublicationYear(i int16) {
	m.publication_year = &i
	m.addpublication_year = nil
}

// PublicationYear returns the value of the "publication_year" field in the mutation.
func (m *BookMutation) PublicationYear() (r int16, exists bool) {
	v := m.publication_year
	if v == nil {
		return
	}
	return *v, true
}

// OldPublicationYear returns the old "publication_year" field's value of the Book entity.
// If the Book object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookMutation) OldPublicationYear(ctx context.Context) (v int16, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPublicationYear is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPublicationYear requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublicationYear: %w", err)
	}
	return oldValue.PublicationYear, nil
}

// AddPublicationYear adds i to the "publication_year" field.
func (m *BookMutation) AddPublicationYear(i int16) {
	if m.addpublication_year != nil {
		*m.addpublication_year += i
	} else {
		m.addpublication_year = &i
	}
}

// AddedPublicationYear returns the value that was added to the "publication_year" field in this mutation.
func (m *BookMutation) AddedPublicationYear() (r int16, exists bool) {
	v := m.addpublication_year
	if v == nil {
		return
	}
	return *v, true
}

// ClearPublicationYear clears the value of the "publication_year" field.
func (m *BookMutation) ClearPublicationYear() {
	m.publication_year = nil
	m.addpublication_year = nil
	m.clearedFields[book.FieldPublicationYear] = struct{}{}
}

// PublicationYearCleared returns if the "publication_year" field was cleared in this mutation.
func (m *BookMutation) PublicationYearCleared() bool {
	_, ok := m.clearedFields[book.FieldPublicationYear]
	return ok
}

// ResetPublicationYear resets all changes to the "publication_year" field.
func (m *BookMutation) ResetPublicationYear() {
	m.publication_year = nil
	m.addpublication_year = nil
	delete(m.clearedFields, book.FieldPublicationYear)
}

// SetPublicationDate sets the "publication_date" field.
func (m *BookMutation) SetPublicationDate(t time.Time) {
	m.publication_date = &t
}

// PublicationDate returns the value of the "publication_date" field in the mutation.
func (m *BookMutation) PublicationDate() (r time.Time, exists bool) {
	v := m.publication_date
	if v == nil {
		return
	}
	return *v, true
}

// OldPublicationDate returns the old "publication_date" field's value of the Book entity.
// If the Book object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookMutation) OldPublicationDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPublicationDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPublicationDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublicationDate: %w", err)
	}
	return oldValue.PublicationDate, nil
}

// ResetPublicationDate resets all changes to the "publication_date" field.
func (m *BookMutation) ResetPublicationDate() {
	m.publication_date = nil
}

// SetEdition sets the "edition" field.
func (m *BookMutation) SetEdition(i int8) {
	m.edition = &i
	m.addedition = nil
}

// Edition returns the value of the "edition" field in the mutation.
func (m *BookMutation) Edition() (r int8, exists bool) {
	v := m.edition
	if v == nil {
		return
	}
	return *v, true
}

// OldEdition returns the old "edition" field's value of the Book entity.
// If the Book object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookMutation) OldEdition(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEdition is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEdition requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEdition: %w", err)
	}
	return oldValue.Edition, nil
}

// AddEdition adds i to the "edition" field.
func (m *BookMutation) AddEdition(i int8) {
	if m.addedition != nil {
		*m.addedition += i
	} else {
		m.addedition = &i
	}
}

// AddedEdition returns the value that was added to the "edition" field in this mutation.
func (m *BookMutation) AddedEdition() (r int8, exists bool) {
	v := m.addedition
	if v == nil {
		return
	}
	return *v, true
}

// ClearEdition clears the value of the "edition" field.
func (m *BookMutation) ClearEdition() {
	m.edition = nil
	m.addedition = nil
	m.clearedFields[book.FieldEdition] = struct{}{}
}

// EditionCleared returns if the "edition" field was cleared in this mutation.
func (m *BookMutation) EditionCleared() bool {
	_, ok := m.clearedFields[book.FieldEdition]
	return ok
}

// ResetEdition resets all changes to the "edition" field.
func (m *BookMutation) ResetEdition() {
	m.edition = nil
	m.addedition = nil
	delete(m.clearedFields, book.FieldEdition)
}

// SetCategory sets the "category" field.
func (m *BookMutation) SetCategory(s string) {
	m.category = &s
}

// Category returns the value of the "category" field in the mutation.
func (m *BookMutation) Category() (r string, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategory returns the old "category" field's value of the Book entity.
// If the Book object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookMutation) OldCategory(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategory: %w", err)
	}
	return oldValue.Category, nil
}

// ClearCategory clears the value of the "category" field.
func (m *BookMutation) ClearCategory() {
	m.category = nil
	m.clearedFields[book.FieldCategory] = struct{}{}
}

// CategoryCleared returns if the "category" field was cleared in this mutation.
func (m *BookMutation) CategoryCleared() bool {
	_, ok := m.clearedFields[book.FieldCategory]
	return ok
}

// ResetCategory resets all changes to the "category" field.
func (m *BookMutation) ResetCategory() {
	m.category = nil
	delete(m.clearedFields, book.FieldCategory)
}

// SetPrice sets the "price" field.
func (m *BookMutation) SetPrice(f float64) {
	m.price = &f
	m.addprice = nil
}

// Price returns the value of the "price" field in the mutation.
func (m *BookMutation) Price() (r float64, exists bool) {
	v := m.price
	if v == nil {
		return
	}
	return *v, true
}

// OldPrice returns the old "price" field's value of the Book entity.
// If the Book object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookMutation) OldPrice(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrice: %w", err)
	}
	return oldValue.Price, nil
}

// AddPrice adds f to the "price" field.
func (m *BookMutation) AddPrice(f float64) {
	if m.addprice != nil {
		*m.addprice += f
	} else {
		m.addprice = &f
	}
}

// AddedPrice returns the value that was added to the "price" field in this mutation.
func (m *BookMutation) AddedPrice() (r float64, exists bool) {
	v := m.addprice
	if v == nil {
		return
	}
	return *v, true
}

// ClearPrice clears the value of the "price" field.
func (m *BookMutation) ClearPrice() {
	m.price = nil
	m.addprice = nil
	m.clearedFields[book.FieldPrice] = struct{}{}
}

// PriceCleared returns if the "price" field was cleared in this mutation.
func (m *BookMutation) PriceCleared() bool {
	_, ok := m.clearedFields[book.FieldPrice]
	return ok
}

// ResetPrice resets all changes to the "price" field.
func (m *BookMutation) ResetPrice() {
	m.price = nil
	m.addprice = nil
	delete(m.clearedFields, book.FieldPrice)
}

// SetStockQuantity sets the "stock_quantity" field.
func (m *BookMutation) SetStockQuantity(i int32) {
	m.stock_quantity = &i
	m.addstock_quantity = nil
}

// StockQuantity returns the value of the "stock_quantity" field in the mutation.
func (m *BookMutation) StockQuantity() (r int32, exists bool) {
	v := m.stock_quantity
	if v == nil {
		return
	}
	return *v, true
}

// OldStockQuantity returns the old "stock_quantity" field's value of the Book entity.
// If the Book object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookMutation) OldStockQuantity(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStockQuantity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStockQuantity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStockQuantity: %w", err)
	}
	return oldValue.StockQuantity, nil
}

// AddStockQuantity adds i to the "stock_quantity" field.
func (m *BookMutation) AddStockQuantity(i int32) {
	if m.addstock_quantity != nil {
		*m.addstock_quantity += i
	} else {
		m.addstock_quantity = &i
	}
}

// AddedStockQuantity returns the value that was added to the "stock_quantity" field in this mutation.
func (m *BookMutation) AddedStockQuantity() (r int32, exists bool) {
	v := m.addstock_quantity
	if v == nil {
		return
	}
	return *v, true
}

// ClearStockQuantity clears the value of the "stock_quantity" field.
func (m *BookMutation) ClearStockQuantity() {
	m.stock_quantity = nil
	m.addstock_quantity = nil
	m.clearedFields[book.FieldStockQuantity] = struct{}{}
}

// StockQuantityCleared returns if the "stock_quantity" field was cleared in this mutation.
func (m *BookMutation) StockQuantityCleared() bool {
	_, ok := m.clearedFields[book.FieldStockQuantity]
	return ok
}

// ResetStockQuantity resets all changes to the "stock_quantity" field.
func (m *BookMutation) ResetStockQuantity() {
	m.stock_quantity = nil
	m.addstock_quantity = nil
	delete(m.clearedFields, book.FieldStockQuantity)
}

// SetDescription sets the "description" field.
func (m *BookMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *BookMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Book entity.
// If the Book object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *BookMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[book.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *BookMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[book.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *BookMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, book.FieldDescription)
}

// SetAddedOn sets the "added_on" field.
func (m *BookMutation) SetAddedOn(t time.Time) {
	m.added_on = &t
}

// AddedOn returns the value of the "added_on" field in the mutation.
func (m *BookMutation) AddedOn() (r time.Time, exists bool) {
	v := m.added_on
	if v == nil {
		return
	}
	return *v, true
}

// OldAddedOn returns the old "added_on" field's value of the Book entity.
// If the Book object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookMutation) OldAddedOn(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddedOn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddedOn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddedOn: %w", err)
	}
	return oldValue.AddedOn, nil
}

// ClearAddedOn clears the value of the "added_on" field.
func (m *BookMutation) ClearAddedOn() {
	m.added_on = nil
	m.clearedFields[book.FieldAddedOn] = struct{}{}
}

// AddedOnCleared returns if the "added_on" field was cleared in this mutation.
func (m *BookMutation) AddedOnCleared() bool {
	_, ok := m.clearedFields[book.FieldAddedOn]
	return ok
}

// ResetAddedOn resets all changes to the "added_on" field.
func (m *BookMutation) ResetAddedOn() {
	m.added_on = nil
	delete(m.clearedFields, book.FieldAddedOn)
}

// SetCoverImage sets the "cover_image" field.
func (m *BookMutation) SetCoverImage(s string) {
	m.cover_image = &s
}

// CoverImage returns the value of the "cover_image" field in the mutation.
func (m *BookMutation) CoverImage() (r string, exists bool) {
	v := m.cover_image
	if v == nil {
		return
	}
	return *v, true
}

// OldCoverImage returns the old "cover_image" field's value of the Book entity.
// If the Book object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookMutation) OldCoverImage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCoverImage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCoverImage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCoverImage: %w", err)
	}
	return oldValue.CoverImage, nil
}

// ClearCoverImage clears the value of the "cover_image" field.
func (m *BookMutation) ClearCoverImage() {
	m.cover_image = nil
	m.clearedFields[book.FieldCoverImage] = struct{}{}
}

// CoverImageCleared returns if the "cover_image" field was cleared in this mutation.
func (m *BookMutation) CoverImageCleared() bool {
	_, ok := m.clearedFields[book.FieldCoverImage]
	return ok
}

// ResetCoverImage resets all changes to the "cover_image" field.
func (m *BookMutation) ResetCoverImage() {
	m.cover_image = nil
	delete(m.clearedFields, book.FieldCoverImage)
}

// SetPageCount sets the "page_count" field.
func (m *BookMutation) SetPageCount(i int) {
	m.page_count = &i
	m.addpage_count = nil
}

// PageCount returns the value of the "page_count" field in the mutation.
func (m *BookMutation) PageCount() (r int32, exists bool) {
	v := m.page_count
	if v == nil {
		return
	}
	return *v, true
}

// OldPageCount returns the old "page_count" field's value of the Book entity.
// If the Book object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookMutation) OldPageCount(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPageCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPageCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPageCount: %w", err)
	}
	return oldValue.PageCount, nil
}

// AddPageCount adds i to the "page_count" field.
func (m *BookMutation) AddPageCount(i int32) {
	if m.addpage_count != nil {
		*m.addpage_count += i
	} else {
		m.addpage_count = &i
	}
}

// AddedPageCount returns the value that was added to the "page_count" field in this mutation.
func (m *BookMutation) AddedPageCount() (r int32, exists bool) {
	v := m.addpage_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetPageCount resets all changes to the "page_count" field.
func (m *BookMutation) ResetPageCount() {
	m.page_count = nil
	m.addpage_count = nil
}

// SetLanguageID sets the "language_id" field.
func (m *BookMutation) SetLanguageID(i int) {
	m.language_id = &i
	m.addlanguage_id = nil
}

// LanguageID returns the value of the "language_id" field in the mutation.
func (m *BookMutation) LanguageID() (r int, exists bool) {
	v := m.language_id
	if v == nil {
		return
	}
	return *v, true
}

// OldLanguageID returns the old "language_id" field's value of the Book entity.
// If the Book object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookMutation) OldLanguageID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLanguageID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLanguageID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLanguageID: %w", err)
	}
	return oldValue.LanguageID, nil
}

// AddLanguageID adds i to the "language_id" field.
func (m *BookMutation) AddLanguageID(i int) {
	if m.addlanguage_id != nil {
		*m.addlanguage_id += i
	} else {
		m.addlanguage_id = &i
	}
}

// AddedLanguageID returns the value that was added to the "language_id" field in this mutation.
func (m *BookMutation) AddedLanguageID() (r int, exists bool) {
	v := m.addlanguage_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetLanguageID resets all changes to the "language_id" field.
func (m *BookMutation) ResetLanguageID() {
	m.language_id = nil
	m.addlanguage_id = nil
}

// SetLanguage sets the "language" field.
func (m *BookMutation) SetLanguage(s string) {
	m.language = &s
}

// Language returns the value of the "language" field in the mutation.
func (m *BookMutation) Language() (r string, exists bool) {
	v := m.language
	if v == nil {
		return
	}
	return *v, true
}

// OldLanguage returns the old "language" field's value of the Book entity.
// If the Book object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookMutation) OldLanguage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLanguage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLanguage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLanguage: %w", err)
	}
	return oldValue.Language, nil
}

// ResetLanguage resets all changes to the "language" field.
func (m *BookMutation) ResetLanguage() {
	m.language = nil
}

// SetAuthorID sets the "author_id" field.
func (m *BookMutation) SetAuthorID(i int) {
	m.author_id = &i
	m.addauthor_id = nil
}

// AuthorID returns the value of the "author_id" field in the mutation.
func (m *BookMutation) AuthorID() (r int, exists bool) {
	v := m.author_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthorID returns the old "author_id" field's value of the Book entity.
// If the Book object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookMutation) OldAuthorID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthorID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthorID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthorID: %w", err)
	}
	return oldValue.AuthorID, nil
}

// AddAuthorID adds i to the "author_id" field.
func (m *BookMutation) AddAuthorID(i int) {
	if m.addauthor_id != nil {
		*m.addauthor_id += i
	} else {
		m.addauthor_id = &i
	}
}

// AddedAuthorID returns the value that was added to the "author_id" field in this mutation.
func (m *BookMutation) AddedAuthorID() (r int, exists bool) {
	v := m.addauthor_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetAuthorID resets all changes to the "author_id" field.
func (m *BookMutation) ResetAuthorID() {
	m.author_id = nil
	m.addauthor_id = nil
}

// SetCategoryID sets the "category_id" field.
func (m *BookMutation) SetCategoryID(i int) {
	m.category_id = &i
	m.addcategory_id = nil
}

// CategoryID returns the value of the "category_id" field in the mutation.
func (m *BookMutation) CategoryID() (r int, exists bool) {
	v := m.category_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCategoryID returns the old "category_id" field's value of the Book entity.
// If the Book object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookMutation) OldCategoryID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategoryID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategoryID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategoryID: %w", err)
	}
	return oldValue.CategoryID, nil
}

// AddCategoryID adds i to the "category_id" field.
func (m *BookMutation) AddCategoryID(i int) {
	if m.addcategory_id != nil {
		*m.addcategory_id += i
	} else {
		m.addcategory_id = &i
	}
}

// AddedCategoryID returns the value that was added to the "category_id" field in this mutation.
func (m *BookMutation) AddedCategoryID() (r int, exists bool) {
	v := m.addcategory_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetCategoryID resets all changes to the "category_id" field.
func (m *BookMutation) ResetCategoryID() {
	m.category_id = nil
	m.addcategory_id = nil
}

// Where appends a list predicates to the BookMutation builder.
func (m *BookMutation) Where(ps ...predicate.Book) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BookMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BookMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Book, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BookMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BookMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Book).
func (m *BookMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BookMutation) Fields() []string {
	fields := make([]string, 0, 20)
	if m.isbn != nil {
		fields = append(fields, book.FieldIsbn)
	}
	if m.title != nil {
		fields = append(fields, book.FieldTitle)
	}
	if m.author != nil {
		fields = append(fields, book.FieldAuthor)
	}
	if m.translator != nil {
		fields = append(fields, book.FieldTranslator)
	}
	if m.publisher_id != nil {
		fields = append(fields, book.FieldPublisherID)
	}
	if m.publisher != nil {
		fields = append(fields, book.FieldPublisher)
	}
	if m.publication_year != nil {
		fields = append(fields, book.FieldPublicationYear)
	}
	if m.publication_date != nil {
		fields = append(fields, book.FieldPublicationDate)
	}
	if m.edition != nil {
		fields = append(fields, book.FieldEdition)
	}
	if m.category != nil {
		fields = append(fields, book.FieldCategory)
	}
	if m.price != nil {
		fields = append(fields, book.FieldPrice)
	}
	if m.stock_quantity != nil {
		fields = append(fields, book.FieldStockQuantity)
	}
	if m.description != nil {
		fields = append(fields, book.FieldDescription)
	}
	if m.added_on != nil {
		fields = append(fields, book.FieldAddedOn)
	}
	if m.cover_image != nil {
		fields = append(fields, book.FieldCoverImage)
	}
	if m.page_count != nil {
		fields = append(fields, book.FieldPageCount)
	}
	if m.language_id != nil {
		fields = append(fields, book.FieldLanguageID)
	}
	if m.language != nil {
		fields = append(fields, book.FieldLanguage)
	}
	if m.author_id != nil {
		fields = append(fields, book.FieldAuthorID)
	}
	if m.category_id != nil {
		fields = append(fields, book.FieldCategoryID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BookMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case book.FieldIsbn:
		return m.Isbn()
	case book.FieldTitle:
		return m.Title()
	case book.FieldAuthor:
		return m.Author()
	case book.FieldTranslator:
		return m.Translator()
	case book.FieldPublisherID:
		return m.PublisherID()
	case book.FieldPublisher:
		return m.Publisher()
	case book.FieldPublicationYear:
		return m.PublicationYear()
	case book.FieldPublicationDate:
		return m.PublicationDate()
	case book.FieldEdition:
		return m.Edition()
	case book.FieldCategory:
		return m.Category()
	case book.FieldPrice:
		return m.Price()
	case book.FieldStockQuantity:
		return m.StockQuantity()
	case book.FieldDescription:
		return m.Description()
	case book.FieldAddedOn:
		return m.AddedOn()
	case book.FieldCoverImage:
		return m.CoverImage()
	case book.FieldPageCount:
		return m.PageCount()
	case book.FieldLanguageID:
		return m.LanguageID()
	case book.FieldLanguage:
		return m.Language()
	case book.FieldAuthorID:
		return m.AuthorID()
	case book.FieldCategoryID:
		return m.CategoryID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BookMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case book.FieldIsbn:
		return m.OldIsbn(ctx)
	case book.FieldTitle:
		return m.OldTitle(ctx)
	case book.FieldAuthor:
		return m.OldAuthor(ctx)
	case book.FieldTranslator:
		return m.OldTranslator(ctx)
	case book.FieldPublisherID:
		return m.OldPublisherID(ctx)
	case book.FieldPublisher:
		return m.OldPublisher(ctx)
	case book.FieldPublicationYear:
		return m.OldPublicationYear(ctx)
	case book.FieldPublicationDate:
		return m.OldPublicationDate(ctx)
	case book.FieldEdition:
		return m.OldEdition(ctx)
	case book.FieldCategory:
		return m.OldCategory(ctx)
	case book.FieldPrice:
		return m.OldPrice(ctx)
	case book.FieldStockQuantity:
		return m.OldStockQuantity(ctx)
	case book.FieldDescription:
		return m.OldDescription(ctx)
	case book.FieldAddedOn:
		return m.OldAddedOn(ctx)
	case book.FieldCoverImage:
		return m.OldCoverImage(ctx)
	case book.FieldPageCount:
		return m.OldPageCount(ctx)
	case book.FieldLanguageID:
		return m.OldLanguageID(ctx)
	case book.FieldLanguage:
		return m.OldLanguage(ctx)
	case book.FieldAuthorID:
		return m.OldAuthorID(ctx)
	case book.FieldCategoryID:
		return m.OldCategoryID(ctx)
	}
	return nil, fmt.Errorf("unknown Book field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BookMutation) SetField(name string, value ent.Value) error {
	switch name {
	case book.FieldIsbn:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsbn(v)
		return nil
	case book.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case book.FieldAuthor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthor(v)
		return nil
	case book.FieldTranslator:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTranslator(v)
		return nil
	case book.FieldPublisherID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublisherID(v)
		return nil
	case book.FieldPublisher:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublisher(v)
		return nil
	case book.FieldPublicationYear:
		v, ok := value.(int16)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublicationYear(v)
		return nil
	case book.FieldPublicationDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublicationDate(v)
		return nil
	case book.FieldEdition:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEdition(v)
		return nil
	case book.FieldCategory:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategory(v)
		return nil
	case book.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrice(v)
		return nil
	case book.FieldStockQuantity:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStockQuantity(v)
		return nil
	case book.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case book.FieldAddedOn:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddedOn(v)
		return nil
	case book.FieldCoverImage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCoverImage(v)
		return nil
	case book.FieldPageCount:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPageCount(v)
		return nil
	case book.FieldLanguageID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLanguageID(v)
		return nil
	case book.FieldLanguage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLanguage(v)
		return nil
	case book.FieldAuthorID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthorID(v)
		return nil
	case book.FieldCategoryID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategoryID(v)
		return nil
	}
	return fmt.Errorf("unknown Book field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BookMutation) AddedFields() []string {
	var fields []string
	if m.addpublisher_id != nil {
		fields = append(fields, book.FieldPublisherID)
	}
	if m.addpublication_year != nil {
		fields = append(fields, book.FieldPublicationYear)
	}
	if m.addedition != nil {
		fields = append(fields, book.FieldEdition)
	}
	if m.addprice != nil {
		fields = append(fields, book.FieldPrice)
	}
	if m.addstock_quantity != nil {
		fields = append(fields, book.FieldStockQuantity)
	}
	if m.addpage_count != nil {
		fields = append(fields, book.FieldPageCount)
	}
	if m.addlanguage_id != nil {
		fields = append(fields, book.FieldLanguageID)
	}
	if m.addauthor_id != nil {
		fields = append(fields, book.FieldAuthorID)
	}
	if m.addcategory_id != nil {
		fields = append(fields, book.FieldCategoryID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BookMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case book.FieldPublisherID:
		return m.AddedPublisherID()
	case book.FieldPublicationYear:
		return m.AddedPublicationYear()
	case book.FieldEdition:
		return m.AddedEdition()
	case book.FieldPrice:
		return m.AddedPrice()
	case book.FieldStockQuantity:
		return m.AddedStockQuantity()
	case book.FieldPageCount:
		return m.AddedPageCount()
	case book.FieldLanguageID:
		return m.AddedLanguageID()
	case book.FieldAuthorID:
		return m.AddedAuthorID()
	case book.FieldCategoryID:
		return m.AddedCategoryID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BookMutation) AddField(name string, value ent.Value) error {
	switch name {
	case book.FieldPublisherID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPublisherID(v)
		return nil
	case book.FieldPublicationYear:
		v, ok := value.(int16)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPublicationYear(v)
		return nil
	case book.FieldEdition:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEdition(v)
		return nil
	case book.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPrice(v)
		return nil
	case book.FieldStockQuantity:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStockQuantity(v)
		return nil
	case book.FieldPageCount:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPageCount(v)
		return nil
	case book.FieldLanguageID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLanguageID(v)
		return nil
	case book.FieldAuthorID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAuthorID(v)
		return nil
	case book.FieldCategoryID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCategoryID(v)
		return nil
	}
	return fmt.Errorf("unknown Book numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BookMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(book.FieldTranslator) {
		fields = append(fields, book.FieldTranslator)
	}
	if m.FieldCleared(book.FieldPublisherID) {
		fields = append(fields, book.FieldPublisherID)
	}
	if m.FieldCleared(book.FieldPublisher) {
		fields = append(fields, book.FieldPublisher)
	}
	if m.FieldCleared(book.FieldPublicationYear) {
		fields = append(fields, book.FieldPublicationYear)
	}
	if m.FieldCleared(book.FieldEdition) {
		fields = append(fields, book.FieldEdition)
	}
	if m.FieldCleared(book.FieldCategory) {
		fields = append(fields, book.FieldCategory)
	}
	if m.FieldCleared(book.FieldPrice) {
		fields = append(fields, book.FieldPrice)
	}
	if m.FieldCleared(book.FieldStockQuantity) {
		fields = append(fields, book.FieldStockQuantity)
	}
	if m.FieldCleared(book.FieldDescription) {
		fields = append(fields, book.FieldDescription)
	}
	if m.FieldCleared(book.FieldAddedOn) {
		fields = append(fields, book.FieldAddedOn)
	}
	if m.FieldCleared(book.FieldCoverImage) {
		fields = append(fields, book.FieldCoverImage)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BookMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BookMutation) ClearField(name string) error {
	switch name {
	case book.FieldTranslator:
		m.ClearTranslator()
		return nil
	case book.FieldPublisherID:
		m.ClearPublisherID()
		return nil
	case book.FieldPublisher:
		m.ClearPublisher()
		return nil
	case book.FieldPublicationYear:
		m.ClearPublicationYear()
		return nil
	case book.FieldEdition:
		m.ClearEdition()
		return nil
	case book.FieldCategory:
		m.ClearCategory()
		return nil
	case book.FieldPrice:
		m.ClearPrice()
		return nil
	case book.FieldStockQuantity:
		m.ClearStockQuantity()
		return nil
	case book.FieldDescription:
		m.ClearDescription()
		return nil
	case book.FieldAddedOn:
		m.ClearAddedOn()
		return nil
	case book.FieldCoverImage:
		m.ClearCoverImage()
		return nil
	}
	return fmt.Errorf("unknown Book nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BookMutation) ResetField(name string) error {
	switch name {
	case book.FieldIsbn:
		m.ResetIsbn()
		return nil
	case book.FieldTitle:
		m.ResetTitle()
		return nil
	case book.FieldAuthor:
		m.ResetAuthor()
		return nil
	case book.FieldTranslator:
		m.ResetTranslator()
		return nil
	case book.FieldPublisherID:
		m.ResetPublisherID()
		return nil
	case book.FieldPublisher:
		m.ResetPublisher()
		return nil
	case book.FieldPublicationYear:
		m.ResetPublicationYear()
		return nil
	case book.FieldPublicationDate:
		m.ResetPublicationDate()
		return nil
	case book.FieldEdition:
		m.ResetEdition()
		return nil
	case book.FieldCategory:
		m.ResetCategory()
		return nil
	case book.FieldPrice:
		m.ResetPrice()
		return nil
	case book.FieldStockQuantity:
		m.ResetStockQuantity()
		return nil
	case book.FieldDescription:
		m.ResetDescription()
		return nil
	case book.FieldAddedOn:
		m.ResetAddedOn()
		return nil
	case book.FieldCoverImage:
		m.ResetCoverImage()
		return nil
	case book.FieldPageCount:
		m.ResetPageCount()
		return nil
	case book.FieldLanguageID:
		m.ResetLanguageID()
		return nil
	case book.FieldLanguage:
		m.ResetLanguage()
		return nil
	case book.FieldAuthorID:
		m.ResetAuthorID()
		return nil
	case book.FieldCategoryID:
		m.ResetCategoryID()
		return nil
	}
	return fmt.Errorf("unknown Book field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BookMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BookMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BookMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BookMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BookMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BookMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BookMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Book unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BookMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Book edge %s", name)
}

// BookAuthorMutation represents an operation that mutates the BookAuthor nodes in the graph.
type BookAuthorMutation struct {
	config
	op            Op
	typ           string
	id            *int
	author_id     *int
	addauthor_id  *int
	isbn          *string
	book_id       *int
	addbook_id    *int
	author        *string
	author_about  *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*BookAuthor, error)
	predicates    []predicate.BookAuthor
}

var _ ent.Mutation = (*BookAuthorMutation)(nil)

// bookauthorOption allows management of the mutation configuration using functional options.
type bookauthorOption func(*BookAuthorMutation)

// newBookAuthorMutation creates new mutation for the BookAuthor entity.
func newBookAuthorMutation(c config, op Op, opts ...bookauthorOption) *BookAuthorMutation {
	m := &BookAuthorMutation{
		config:        c,
		op:            op,
		typ:           TypeBookAuthor,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBookAuthorID sets the ID field of the mutation.
func withBookAuthorID(id int) bookauthorOption {
	return func(m *BookAuthorMutation) {
		var (
			err   error
			once  sync.Once
			value *BookAuthor
		)
		m.oldValue = func(ctx context.Context) (*BookAuthor, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BookAuthor.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBookAuthor sets the old BookAuthor of the mutation.
func withBookAuthor(node *BookAuthor) bookauthorOption {
	return func(m *BookAuthorMutation) {
		m.oldValue = func(context.Context) (*BookAuthor, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BookAuthorMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BookAuthorMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of BookAuthor entities.
func (m *BookAuthorMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BookAuthorMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BookAuthorMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BookAuthor.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetAuthorID sets the "author_id" field.
func (m *BookAuthorMutation) SetAuthorID(i int) {
	m.author_id = &i
	m.addauthor_id = nil
}

// AuthorID returns the value of the "author_id" field in the mutation.
func (m *BookAuthorMutation) AuthorID() (r int, exists bool) {
	v := m.author_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthorID returns the old "author_id" field's value of the BookAuthor entity.
// If the BookAuthor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookAuthorMutation) OldAuthorID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthorID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthorID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthorID: %w", err)
	}
	return oldValue.AuthorID, nil
}

// AddAuthorID adds i to the "author_id" field.
func (m *BookAuthorMutation) AddAuthorID(i int) {
	if m.addauthor_id != nil {
		*m.addauthor_id += i
	} else {
		m.addauthor_id = &i
	}
}

// AddedAuthorID returns the value that was added to the "author_id" field in this mutation.
func (m *BookAuthorMutation) AddedAuthorID() (r int, exists bool) {
	v := m.addauthor_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetAuthorID resets all changes to the "author_id" field.
func (m *BookAuthorMutation) ResetAuthorID() {
	m.author_id = nil
	m.addauthor_id = nil
}

// SetIsbn sets the "isbn" field.
func (m *BookAuthorMutation) SetIsbn(s string) {
	m.isbn = &s
}

// Isbn returns the value of the "isbn" field in the mutation.
func (m *BookAuthorMutation) Isbn() (r string, exists bool) {
	v := m.isbn
	if v == nil {
		return
	}
	return *v, true
}

// OldIsbn returns the old "isbn" field's value of the BookAuthor entity.
// If the BookAuthor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookAuthorMutation) OldIsbn(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsbn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsbn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsbn: %w", err)
	}
	return oldValue.Isbn, nil
}

// ResetIsbn resets all changes to the "isbn" field.
func (m *BookAuthorMutation) ResetIsbn() {
	m.isbn = nil
}

// SetBookID sets the "book_id" field.
func (m *BookAuthorMutation) SetBookID(i int) {
	m.book_id = &i
	m.addbook_id = nil
}

// BookID returns the value of the "book_id" field in the mutation.
func (m *BookAuthorMutation) BookID() (r int, exists bool) {
	v := m.book_id
	if v == nil {
		return
	}
	return *v, true
}

// OldBookID returns the old "book_id" field's value of the BookAuthor entity.
// If the BookAuthor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookAuthorMutation) OldBookID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBookID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBookID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBookID: %w", err)
	}
	return oldValue.BookID, nil
}

// AddBookID adds i to the "book_id" field.
func (m *BookAuthorMutation) AddBookID(i int) {
	if m.addbook_id != nil {
		*m.addbook_id += i
	} else {
		m.addbook_id = &i
	}
}

// AddedBookID returns the value that was added to the "book_id" field in this mutation.
func (m *BookAuthorMutation) AddedBookID() (r int, exists bool) {
	v := m.addbook_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearBookID clears the value of the "book_id" field.
func (m *BookAuthorMutation) ClearBookID() {
	m.book_id = nil
	m.addbook_id = nil
	m.clearedFields[bookauthor.FieldBookID] = struct{}{}
}

// BookIDCleared returns if the "book_id" field was cleared in this mutation.
func (m *BookAuthorMutation) BookIDCleared() bool {
	_, ok := m.clearedFields[bookauthor.FieldBookID]
	return ok
}

// ResetBookID resets all changes to the "book_id" field.
func (m *BookAuthorMutation) ResetBookID() {
	m.book_id = nil
	m.addbook_id = nil
	delete(m.clearedFields, bookauthor.FieldBookID)
}

// SetAuthor sets the "author" field.
func (m *BookAuthorMutation) SetAuthor(s string) {
	m.author = &s
}

// Author returns the value of the "author" field in the mutation.
func (m *BookAuthorMutation) Author() (r string, exists bool) {
	v := m.author
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthor returns the old "author" field's value of the BookAuthor entity.
// If the BookAuthor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookAuthorMutation) OldAuthor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthor: %w", err)
	}
	return oldValue.Author, nil
}

// ClearAuthor clears the value of the "author" field.
func (m *BookAuthorMutation) ClearAuthor() {
	m.author = nil
	m.clearedFields[bookauthor.FieldAuthor] = struct{}{}
}

// AuthorCleared returns if the "author" field was cleared in this mutation.
func (m *BookAuthorMutation) AuthorCleared() bool {
	_, ok := m.clearedFields[bookauthor.FieldAuthor]
	return ok
}

// ResetAuthor resets all changes to the "author" field.
func (m *BookAuthorMutation) ResetAuthor() {
	m.author = nil
	delete(m.clearedFields, bookauthor.FieldAuthor)
}

// SetAuthorAbout sets the "author_about" field.
func (m *BookAuthorMutation) SetAuthorAbout(s string) {
	m.author_about = &s
}

// AuthorAbout returns the value of the "author_about" field in the mutation.
func (m *BookAuthorMutation) AuthorAbout() (r string, exists bool) {
	v := m.author_about
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthorAbout returns the old "author_about" field's value of the BookAuthor entity.
// If the BookAuthor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookAuthorMutation) OldAuthorAbout(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthorAbout is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthorAbout requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthorAbout: %w", err)
	}
	return oldValue.AuthorAbout, nil
}

// ClearAuthorAbout clears the value of the "author_about" field.
func (m *BookAuthorMutation) ClearAuthorAbout() {
	m.author_about = nil
	m.clearedFields[bookauthor.FieldAuthorAbout] = struct{}{}
}

// AuthorAboutCleared returns if the "author_about" field was cleared in this mutation.
func (m *BookAuthorMutation) AuthorAboutCleared() bool {
	_, ok := m.clearedFields[bookauthor.FieldAuthorAbout]
	return ok
}

// ResetAuthorAbout resets all changes to the "author_about" field.
func (m *BookAuthorMutation) ResetAuthorAbout() {
	m.author_about = nil
	delete(m.clearedFields, bookauthor.FieldAuthorAbout)
}

// Where appends a list predicates to the BookAuthorMutation builder.
func (m *BookAuthorMutation) Where(ps ...predicate.BookAuthor) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BookAuthorMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BookAuthorMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.BookAuthor, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BookAuthorMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BookAuthorMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (BookAuthor).
func (m *BookAuthorMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BookAuthorMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.author_id != nil {
		fields = append(fields, bookauthor.FieldAuthorID)
	}
	if m.isbn != nil {
		fields = append(fields, bookauthor.FieldIsbn)
	}
	if m.book_id != nil {
		fields = append(fields, bookauthor.FieldBookID)
	}
	if m.author != nil {
		fields = append(fields, bookauthor.FieldAuthor)
	}
	if m.author_about != nil {
		fields = append(fields, bookauthor.FieldAuthorAbout)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BookAuthorMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case bookauthor.FieldAuthorID:
		return m.AuthorID()
	case bookauthor.FieldIsbn:
		return m.Isbn()
	case bookauthor.FieldBookID:
		return m.BookID()
	case bookauthor.FieldAuthor:
		return m.Author()
	case bookauthor.FieldAuthorAbout:
		return m.AuthorAbout()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BookAuthorMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case bookauthor.FieldAuthorID:
		return m.OldAuthorID(ctx)
	case bookauthor.FieldIsbn:
		return m.OldIsbn(ctx)
	case bookauthor.FieldBookID:
		return m.OldBookID(ctx)
	case bookauthor.FieldAuthor:
		return m.OldAuthor(ctx)
	case bookauthor.FieldAuthorAbout:
		return m.OldAuthorAbout(ctx)
	}
	return nil, fmt.Errorf("unknown BookAuthor field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BookAuthorMutation) SetField(name string, value ent.Value) error {
	switch name {
	case bookauthor.FieldAuthorID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthorID(v)
		return nil
	case bookauthor.FieldIsbn:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsbn(v)
		return nil
	case bookauthor.FieldBookID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBookID(v)
		return nil
	case bookauthor.FieldAuthor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthor(v)
		return nil
	case bookauthor.FieldAuthorAbout:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthorAbout(v)
		return nil
	}
	return fmt.Errorf("unknown BookAuthor field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BookAuthorMutation) AddedFields() []string {
	var fields []string
	if m.addauthor_id != nil {
		fields = append(fields, bookauthor.FieldAuthorID)
	}
	if m.addbook_id != nil {
		fields = append(fields, bookauthor.FieldBookID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BookAuthorMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case bookauthor.FieldAuthorID:
		return m.AddedAuthorID()
	case bookauthor.FieldBookID:
		return m.AddedBookID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BookAuthorMutation) AddField(name string, value ent.Value) error {
	switch name {
	case bookauthor.FieldAuthorID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAuthorID(v)
		return nil
	case bookauthor.FieldBookID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBookID(v)
		return nil
	}
	return fmt.Errorf("unknown BookAuthor numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BookAuthorMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(bookauthor.FieldBookID) {
		fields = append(fields, bookauthor.FieldBookID)
	}
	if m.FieldCleared(bookauthor.FieldAuthor) {
		fields = append(fields, bookauthor.FieldAuthor)
	}
	if m.FieldCleared(bookauthor.FieldAuthorAbout) {
		fields = append(fields, bookauthor.FieldAuthorAbout)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BookAuthorMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BookAuthorMutation) ClearField(name string) error {
	switch name {
	case bookauthor.FieldBookID:
		m.ClearBookID()
		return nil
	case bookauthor.FieldAuthor:
		m.ClearAuthor()
		return nil
	case bookauthor.FieldAuthorAbout:
		m.ClearAuthorAbout()
		return nil
	}
	return fmt.Errorf("unknown BookAuthor nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BookAuthorMutation) ResetField(name string) error {
	switch name {
	case bookauthor.FieldAuthorID:
		m.ResetAuthorID()
		return nil
	case bookauthor.FieldIsbn:
		m.ResetIsbn()
		return nil
	case bookauthor.FieldBookID:
		m.ResetBookID()
		return nil
	case bookauthor.FieldAuthor:
		m.ResetAuthor()
		return nil
	case bookauthor.FieldAuthorAbout:
		m.ResetAuthorAbout()
		return nil
	}
	return fmt.Errorf("unknown BookAuthor field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BookAuthorMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BookAuthorMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BookAuthorMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BookAuthorMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BookAuthorMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BookAuthorMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BookAuthorMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown BookAuthor unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BookAuthorMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown BookAuthor edge %s", name)
}

// BookDetailMutation represents an operation that mutates the BookDetail nodes in the graph.
type BookDetailMutation struct {
	config
	op            Op
	typ           string
	id            *int
	isbn          *string
	detail_html   *string
	detail_img    *string
	book_id       *int
	addbook_id    *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*BookDetail, error)
	predicates    []predicate.BookDetail
}

var _ ent.Mutation = (*BookDetailMutation)(nil)

// bookdetailOption allows management of the mutation configuration using functional options.
type bookdetailOption func(*BookDetailMutation)

// newBookDetailMutation creates new mutation for the BookDetail entity.
func newBookDetailMutation(c config, op Op, opts ...bookdetailOption) *BookDetailMutation {
	m := &BookDetailMutation{
		config:        c,
		op:            op,
		typ:           TypeBookDetail,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBookDetailID sets the ID field of the mutation.
func withBookDetailID(id int) bookdetailOption {
	return func(m *BookDetailMutation) {
		var (
			err   error
			once  sync.Once
			value *BookDetail
		)
		m.oldValue = func(ctx context.Context) (*BookDetail, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BookDetail.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBookDetail sets the old BookDetail of the mutation.
func withBookDetail(node *BookDetail) bookdetailOption {
	return func(m *BookDetailMutation) {
		m.oldValue = func(context.Context) (*BookDetail, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BookDetailMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BookDetailMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of BookDetail entities.
func (m *BookDetailMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BookDetailMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BookDetailMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BookDetail.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetIsbn sets the "isbn" field.
func (m *BookDetailMutation) SetIsbn(s string) {
	m.isbn = &s
}

// Isbn returns the value of the "isbn" field in the mutation.
func (m *BookDetailMutation) Isbn() (r string, exists bool) {
	v := m.isbn
	if v == nil {
		return
	}
	return *v, true
}

// OldIsbn returns the old "isbn" field's value of the BookDetail entity.
// If the BookDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookDetailMutation) OldIsbn(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsbn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsbn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsbn: %w", err)
	}
	return oldValue.Isbn, nil
}

// ResetIsbn resets all changes to the "isbn" field.
func (m *BookDetailMutation) ResetIsbn() {
	m.isbn = nil
}

// SetDetailHTML sets the "detail_html" field.
func (m *BookDetailMutation) SetDetailHTML(s string) {
	m.detail_html = &s
}

// DetailHTML returns the value of the "detail_html" field in the mutation.
func (m *BookDetailMutation) DetailHTML() (r string, exists bool) {
	v := m.detail_html
	if v == nil {
		return
	}
	return *v, true
}

// OldDetailHTML returns the old "detail_html" field's value of the BookDetail entity.
// If the BookDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookDetailMutation) OldDetailHTML(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDetailHTML is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDetailHTML requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDetailHTML: %w", err)
	}
	return oldValue.DetailHTML, nil
}

// ClearDetailHTML clears the value of the "detail_html" field.
func (m *BookDetailMutation) ClearDetailHTML() {
	m.detail_html = nil
	m.clearedFields[bookdetail.FieldDetailHTML] = struct{}{}
}

// DetailHTMLCleared returns if the "detail_html" field was cleared in this mutation.
func (m *BookDetailMutation) DetailHTMLCleared() bool {
	_, ok := m.clearedFields[bookdetail.FieldDetailHTML]
	return ok
}

// ResetDetailHTML resets all changes to the "detail_html" field.
func (m *BookDetailMutation) ResetDetailHTML() {
	m.detail_html = nil
	delete(m.clearedFields, bookdetail.FieldDetailHTML)
}

// SetDetailImg sets the "detail_img" field.
func (m *BookDetailMutation) SetDetailImg(s string) {
	m.detail_img = &s
}

// DetailImg returns the value of the "detail_img" field in the mutation.
func (m *BookDetailMutation) DetailImg() (r string, exists bool) {
	v := m.detail_img
	if v == nil {
		return
	}
	return *v, true
}

// OldDetailImg returns the old "detail_img" field's value of the BookDetail entity.
// If the BookDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookDetailMutation) OldDetailImg(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDetailImg is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDetailImg requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDetailImg: %w", err)
	}
	return oldValue.DetailImg, nil
}

// ClearDetailImg clears the value of the "detail_img" field.
func (m *BookDetailMutation) ClearDetailImg() {
	m.detail_img = nil
	m.clearedFields[bookdetail.FieldDetailImg] = struct{}{}
}

// DetailImgCleared returns if the "detail_img" field was cleared in this mutation.
func (m *BookDetailMutation) DetailImgCleared() bool {
	_, ok := m.clearedFields[bookdetail.FieldDetailImg]
	return ok
}

// ResetDetailImg resets all changes to the "detail_img" field.
func (m *BookDetailMutation) ResetDetailImg() {
	m.detail_img = nil
	delete(m.clearedFields, bookdetail.FieldDetailImg)
}

// SetBookID sets the "book_id" field.
func (m *BookDetailMutation) SetBookID(i int) {
	m.book_id = &i
	m.addbook_id = nil
}

// BookID returns the value of the "book_id" field in the mutation.
func (m *BookDetailMutation) BookID() (r int, exists bool) {
	v := m.book_id
	if v == nil {
		return
	}
	return *v, true
}

// OldBookID returns the old "book_id" field's value of the BookDetail entity.
// If the BookDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookDetailMutation) OldBookID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBookID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBookID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBookID: %w", err)
	}
	return oldValue.BookID, nil
}

// AddBookID adds i to the "book_id" field.
func (m *BookDetailMutation) AddBookID(i int) {
	if m.addbook_id != nil {
		*m.addbook_id += i
	} else {
		m.addbook_id = &i
	}
}

// AddedBookID returns the value that was added to the "book_id" field in this mutation.
func (m *BookDetailMutation) AddedBookID() (r int, exists bool) {
	v := m.addbook_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearBookID clears the value of the "book_id" field.
func (m *BookDetailMutation) ClearBookID() {
	m.book_id = nil
	m.addbook_id = nil
	m.clearedFields[bookdetail.FieldBookID] = struct{}{}
}

// BookIDCleared returns if the "book_id" field was cleared in this mutation.
func (m *BookDetailMutation) BookIDCleared() bool {
	_, ok := m.clearedFields[bookdetail.FieldBookID]
	return ok
}

// ResetBookID resets all changes to the "book_id" field.
func (m *BookDetailMutation) ResetBookID() {
	m.book_id = nil
	m.addbook_id = nil
	delete(m.clearedFields, bookdetail.FieldBookID)
}

// Where appends a list predicates to the BookDetailMutation builder.
func (m *BookDetailMutation) Where(ps ...predicate.BookDetail) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BookDetailMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BookDetailMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.BookDetail, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BookDetailMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BookDetailMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (BookDetail).
func (m *BookDetailMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BookDetailMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.isbn != nil {
		fields = append(fields, bookdetail.FieldIsbn)
	}
	if m.detail_html != nil {
		fields = append(fields, bookdetail.FieldDetailHTML)
	}
	if m.detail_img != nil {
		fields = append(fields, bookdetail.FieldDetailImg)
	}
	if m.book_id != nil {
		fields = append(fields, bookdetail.FieldBookID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BookDetailMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case bookdetail.FieldIsbn:
		return m.Isbn()
	case bookdetail.FieldDetailHTML:
		return m.DetailHTML()
	case bookdetail.FieldDetailImg:
		return m.DetailImg()
	case bookdetail.FieldBookID:
		return m.BookID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BookDetailMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case bookdetail.FieldIsbn:
		return m.OldIsbn(ctx)
	case bookdetail.FieldDetailHTML:
		return m.OldDetailHTML(ctx)
	case bookdetail.FieldDetailImg:
		return m.OldDetailImg(ctx)
	case bookdetail.FieldBookID:
		return m.OldBookID(ctx)
	}
	return nil, fmt.Errorf("unknown BookDetail field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BookDetailMutation) SetField(name string, value ent.Value) error {
	switch name {
	case bookdetail.FieldIsbn:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsbn(v)
		return nil
	case bookdetail.FieldDetailHTML:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDetailHTML(v)
		return nil
	case bookdetail.FieldDetailImg:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDetailImg(v)
		return nil
	case bookdetail.FieldBookID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBookID(v)
		return nil
	}
	return fmt.Errorf("unknown BookDetail field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BookDetailMutation) AddedFields() []string {
	var fields []string
	if m.addbook_id != nil {
		fields = append(fields, bookdetail.FieldBookID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BookDetailMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case bookdetail.FieldBookID:
		return m.AddedBookID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BookDetailMutation) AddField(name string, value ent.Value) error {
	switch name {
	case bookdetail.FieldBookID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBookID(v)
		return nil
	}
	return fmt.Errorf("unknown BookDetail numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BookDetailMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(bookdetail.FieldDetailHTML) {
		fields = append(fields, bookdetail.FieldDetailHTML)
	}
	if m.FieldCleared(bookdetail.FieldDetailImg) {
		fields = append(fields, bookdetail.FieldDetailImg)
	}
	if m.FieldCleared(bookdetail.FieldBookID) {
		fields = append(fields, bookdetail.FieldBookID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BookDetailMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BookDetailMutation) ClearField(name string) error {
	switch name {
	case bookdetail.FieldDetailHTML:
		m.ClearDetailHTML()
		return nil
	case bookdetail.FieldDetailImg:
		m.ClearDetailImg()
		return nil
	case bookdetail.FieldBookID:
		m.ClearBookID()
		return nil
	}
	return fmt.Errorf("unknown BookDetail nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BookDetailMutation) ResetField(name string) error {
	switch name {
	case bookdetail.FieldIsbn:
		m.ResetIsbn()
		return nil
	case bookdetail.FieldDetailHTML:
		m.ResetDetailHTML()
		return nil
	case bookdetail.FieldDetailImg:
		m.ResetDetailImg()
		return nil
	case bookdetail.FieldBookID:
		m.ResetBookID()
		return nil
	}
	return fmt.Errorf("unknown BookDetail field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BookDetailMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BookDetailMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BookDetailMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BookDetailMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BookDetailMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BookDetailMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BookDetailMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown BookDetail unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BookDetailMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown BookDetail edge %s", name)
}

// BookImageMutation represents an operation that mutates the BookImage nodes in the graph.
type BookImageMutation struct {
	config
	op            Op
	typ           string
	id            *int
	img_url       *string
	isbn          *int
	addisbn       *int
	img_encode    *string
	book_id       *int
	addbook_id    *int
	mainFlag      *int32
	addmainFlag   *int32
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*BookImage, error)
	predicates    []predicate.BookImage
}

var _ ent.Mutation = (*BookImageMutation)(nil)

// bookimageOption allows management of the mutation configuration using functional options.
type bookimageOption func(*BookImageMutation)

// newBookImageMutation creates new mutation for the BookImage entity.
func newBookImageMutation(c config, op Op, opts ...bookimageOption) *BookImageMutation {
	m := &BookImageMutation{
		config:        c,
		op:            op,
		typ:           TypeBookImage,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBookImageID sets the ID field of the mutation.
func withBookImageID(id int) bookimageOption {
	return func(m *BookImageMutation) {
		var (
			err   error
			once  sync.Once
			value *BookImage
		)
		m.oldValue = func(ctx context.Context) (*BookImage, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BookImage.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBookImage sets the old BookImage of the mutation.
func withBookImage(node *BookImage) bookimageOption {
	return func(m *BookImageMutation) {
		m.oldValue = func(context.Context) (*BookImage, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BookImageMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BookImageMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of BookImage entities.
func (m *BookImageMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BookImageMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BookImageMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BookImage.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetImgURL sets the "img_url" field.
func (m *BookImageMutation) SetImgURL(s string) {
	m.img_url = &s
}

// ImgURL returns the value of the "img_url" field in the mutation.
func (m *BookImageMutation) ImgURL() (r string, exists bool) {
	v := m.img_url
	if v == nil {
		return
	}
	return *v, true
}

// OldImgURL returns the old "img_url" field's value of the BookImage entity.
// If the BookImage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookImageMutation) OldImgURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImgURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImgURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImgURL: %w", err)
	}
	return oldValue.ImgURL, nil
}

// ClearImgURL clears the value of the "img_url" field.
func (m *BookImageMutation) ClearImgURL() {
	m.img_url = nil
	m.clearedFields[bookimage.FieldImgURL] = struct{}{}
}

// ImgURLCleared returns if the "img_url" field was cleared in this mutation.
func (m *BookImageMutation) ImgURLCleared() bool {
	_, ok := m.clearedFields[bookimage.FieldImgURL]
	return ok
}

// ResetImgURL resets all changes to the "img_url" field.
func (m *BookImageMutation) ResetImgURL() {
	m.img_url = nil
	delete(m.clearedFields, bookimage.FieldImgURL)
}

// SetIsbn sets the "isbn" field.
func (m *BookImageMutation) SetIsbn(i int) {
	m.isbn = &i
	m.addisbn = nil
}

// Isbn returns the value of the "isbn" field in the mutation.
func (m *BookImageMutation) Isbn() (r int, exists bool) {
	v := m.isbn
	if v == nil {
		return
	}
	return *v, true
}

// OldIsbn returns the old "isbn" field's value of the BookImage entity.
// If the BookImage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookImageMutation) OldIsbn(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsbn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsbn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsbn: %w", err)
	}
	return oldValue.Isbn, nil
}

// AddIsbn adds i to the "isbn" field.
func (m *BookImageMutation) AddIsbn(i int) {
	if m.addisbn != nil {
		*m.addisbn += i
	} else {
		m.addisbn = &i
	}
}

// AddedIsbn returns the value that was added to the "isbn" field in this mutation.
func (m *BookImageMutation) AddedIsbn() (r int, exists bool) {
	v := m.addisbn
	if v == nil {
		return
	}
	return *v, true
}

// ResetIsbn resets all changes to the "isbn" field.
func (m *BookImageMutation) ResetIsbn() {
	m.isbn = nil
	m.addisbn = nil
}

// SetImgEncode sets the "img_encode" field.
func (m *BookImageMutation) SetImgEncode(s string) {
	m.img_encode = &s
}

// ImgEncode returns the value of the "img_encode" field in the mutation.
func (m *BookImageMutation) ImgEncode() (r string, exists bool) {
	v := m.img_encode
	if v == nil {
		return
	}
	return *v, true
}

// OldImgEncode returns the old "img_encode" field's value of the BookImage entity.
// If the BookImage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookImageMutation) OldImgEncode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImgEncode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImgEncode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImgEncode: %w", err)
	}
	return oldValue.ImgEncode, nil
}

// ClearImgEncode clears the value of the "img_encode" field.
func (m *BookImageMutation) ClearImgEncode() {
	m.img_encode = nil
	m.clearedFields[bookimage.FieldImgEncode] = struct{}{}
}

// ImgEncodeCleared returns if the "img_encode" field was cleared in this mutation.
func (m *BookImageMutation) ImgEncodeCleared() bool {
	_, ok := m.clearedFields[bookimage.FieldImgEncode]
	return ok
}

// ResetImgEncode resets all changes to the "img_encode" field.
func (m *BookImageMutation) ResetImgEncode() {
	m.img_encode = nil
	delete(m.clearedFields, bookimage.FieldImgEncode)
}

// SetBookID sets the "book_id" field.
func (m *BookImageMutation) SetBookID(i int) {
	m.book_id = &i
	m.addbook_id = nil
}

// BookID returns the value of the "book_id" field in the mutation.
func (m *BookImageMutation) BookID() (r int, exists bool) {
	v := m.book_id
	if v == nil {
		return
	}
	return *v, true
}

// OldBookID returns the old "book_id" field's value of the BookImage entity.
// If the BookImage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookImageMutation) OldBookID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBookID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBookID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBookID: %w", err)
	}
	return oldValue.BookID, nil
}

// AddBookID adds i to the "book_id" field.
func (m *BookImageMutation) AddBookID(i int) {
	if m.addbook_id != nil {
		*m.addbook_id += i
	} else {
		m.addbook_id = &i
	}
}

// AddedBookID returns the value that was added to the "book_id" field in this mutation.
func (m *BookImageMutation) AddedBookID() (r int, exists bool) {
	v := m.addbook_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearBookID clears the value of the "book_id" field.
func (m *BookImageMutation) ClearBookID() {
	m.book_id = nil
	m.addbook_id = nil
	m.clearedFields[bookimage.FieldBookID] = struct{}{}
}

// BookIDCleared returns if the "book_id" field was cleared in this mutation.
func (m *BookImageMutation) BookIDCleared() bool {
	_, ok := m.clearedFields[bookimage.FieldBookID]
	return ok
}

// ResetBookID resets all changes to the "book_id" field.
func (m *BookImageMutation) ResetBookID() {
	m.book_id = nil
	m.addbook_id = nil
	delete(m.clearedFields, bookimage.FieldBookID)
}

// SetMainFlag sets the "mainFlag" field.
func (m *BookImageMutation) SetMainFlag(i int32) {
	m.mainFlag = &i
	m.addmainFlag = nil
}

// MainFlag returns the value of the "mainFlag" field in the mutation.
func (m *BookImageMutation) MainFlag() (r int32, exists bool) {
	v := m.mainFlag
	if v == nil {
		return
	}
	return *v, true
}

// OldMainFlag returns the old "mainFlag" field's value of the BookImage entity.
// If the BookImage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookImageMutation) OldMainFlag(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMainFlag is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMainFlag requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMainFlag: %w", err)
	}
	return oldValue.MainFlag, nil
}

// AddMainFlag adds i to the "mainFlag" field.
func (m *BookImageMutation) AddMainFlag(i int32) {
	if m.addmainFlag != nil {
		*m.addmainFlag += i
	} else {
		m.addmainFlag = &i
	}
}

// AddedMainFlag returns the value that was added to the "mainFlag" field in this mutation.
func (m *BookImageMutation) AddedMainFlag() (r int32, exists bool) {
	v := m.addmainFlag
	if v == nil {
		return
	}
	return *v, true
}

// ClearMainFlag clears the value of the "mainFlag" field.
func (m *BookImageMutation) ClearMainFlag() {
	m.mainFlag = nil
	m.addmainFlag = nil
	m.clearedFields[bookimage.FieldMainFlag] = struct{}{}
}

// MainFlagCleared returns if the "mainFlag" field was cleared in this mutation.
func (m *BookImageMutation) MainFlagCleared() bool {
	_, ok := m.clearedFields[bookimage.FieldMainFlag]
	return ok
}

// ResetMainFlag resets all changes to the "mainFlag" field.
func (m *BookImageMutation) ResetMainFlag() {
	m.mainFlag = nil
	m.addmainFlag = nil
	delete(m.clearedFields, bookimage.FieldMainFlag)
}

// Where appends a list predicates to the BookImageMutation builder.
func (m *BookImageMutation) Where(ps ...predicate.BookImage) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BookImageMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BookImageMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.BookImage, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BookImageMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BookImageMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (BookImage).
func (m *BookImageMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BookImageMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.img_url != nil {
		fields = append(fields, bookimage.FieldImgURL)
	}
	if m.isbn != nil {
		fields = append(fields, bookimage.FieldIsbn)
	}
	if m.img_encode != nil {
		fields = append(fields, bookimage.FieldImgEncode)
	}
	if m.book_id != nil {
		fields = append(fields, bookimage.FieldBookID)
	}
	if m.mainFlag != nil {
		fields = append(fields, bookimage.FieldMainFlag)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BookImageMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case bookimage.FieldImgURL:
		return m.ImgURL()
	case bookimage.FieldIsbn:
		return m.Isbn()
	case bookimage.FieldImgEncode:
		return m.ImgEncode()
	case bookimage.FieldBookID:
		return m.BookID()
	case bookimage.FieldMainFlag:
		return m.MainFlag()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BookImageMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case bookimage.FieldImgURL:
		return m.OldImgURL(ctx)
	case bookimage.FieldIsbn:
		return m.OldIsbn(ctx)
	case bookimage.FieldImgEncode:
		return m.OldImgEncode(ctx)
	case bookimage.FieldBookID:
		return m.OldBookID(ctx)
	case bookimage.FieldMainFlag:
		return m.OldMainFlag(ctx)
	}
	return nil, fmt.Errorf("unknown BookImage field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BookImageMutation) SetField(name string, value ent.Value) error {
	switch name {
	case bookimage.FieldImgURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImgURL(v)
		return nil
	case bookimage.FieldIsbn:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsbn(v)
		return nil
	case bookimage.FieldImgEncode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImgEncode(v)
		return nil
	case bookimage.FieldBookID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBookID(v)
		return nil
	case bookimage.FieldMainFlag:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMainFlag(v)
		return nil
	}
	return fmt.Errorf("unknown BookImage field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BookImageMutation) AddedFields() []string {
	var fields []string
	if m.addisbn != nil {
		fields = append(fields, bookimage.FieldIsbn)
	}
	if m.addbook_id != nil {
		fields = append(fields, bookimage.FieldBookID)
	}
	if m.addmainFlag != nil {
		fields = append(fields, bookimage.FieldMainFlag)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BookImageMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case bookimage.FieldIsbn:
		return m.AddedIsbn()
	case bookimage.FieldBookID:
		return m.AddedBookID()
	case bookimage.FieldMainFlag:
		return m.AddedMainFlag()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BookImageMutation) AddField(name string, value ent.Value) error {
	switch name {
	case bookimage.FieldIsbn:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsbn(v)
		return nil
	case bookimage.FieldBookID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBookID(v)
		return nil
	case bookimage.FieldMainFlag:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMainFlag(v)
		return nil
	}
	return fmt.Errorf("unknown BookImage numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BookImageMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(bookimage.FieldImgURL) {
		fields = append(fields, bookimage.FieldImgURL)
	}
	if m.FieldCleared(bookimage.FieldImgEncode) {
		fields = append(fields, bookimage.FieldImgEncode)
	}
	if m.FieldCleared(bookimage.FieldBookID) {
		fields = append(fields, bookimage.FieldBookID)
	}
	if m.FieldCleared(bookimage.FieldMainFlag) {
		fields = append(fields, bookimage.FieldMainFlag)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BookImageMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BookImageMutation) ClearField(name string) error {
	switch name {
	case bookimage.FieldImgURL:
		m.ClearImgURL()
		return nil
	case bookimage.FieldImgEncode:
		m.ClearImgEncode()
		return nil
	case bookimage.FieldBookID:
		m.ClearBookID()
		return nil
	case bookimage.FieldMainFlag:
		m.ClearMainFlag()
		return nil
	}
	return fmt.Errorf("unknown BookImage nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BookImageMutation) ResetField(name string) error {
	switch name {
	case bookimage.FieldImgURL:
		m.ResetImgURL()
		return nil
	case bookimage.FieldIsbn:
		m.ResetIsbn()
		return nil
	case bookimage.FieldImgEncode:
		m.ResetImgEncode()
		return nil
	case bookimage.FieldBookID:
		m.ResetBookID()
		return nil
	case bookimage.FieldMainFlag:
		m.ResetMainFlag()
		return nil
	}
	return fmt.Errorf("unknown BookImage field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BookImageMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BookImageMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BookImageMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BookImageMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BookImageMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BookImageMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BookImageMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown BookImage unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BookImageMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown BookImage edge %s", name)
}

// BookStockMutation represents an operation that mutates the BookStock nodes in the graph.
type BookStockMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	isbn          *string
	quantity      *int
	addquantity   *int
	book_id       *int
	addbook_id    *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*BookStock, error)
	predicates    []predicate.BookStock
}

var _ ent.Mutation = (*BookStockMutation)(nil)

// bookstockOption allows management of the mutation configuration using functional options.
type bookstockOption func(*BookStockMutation)

// newBookStockMutation creates new mutation for the BookStock entity.
func newBookStockMutation(c config, op Op, opts ...bookstockOption) *BookStockMutation {
	m := &BookStockMutation{
		config:        c,
		op:            op,
		typ:           TypeBookStock,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBookStockID sets the ID field of the mutation.
func withBookStockID(id int) bookstockOption {
	return func(m *BookStockMutation) {
		var (
			err   error
			once  sync.Once
			value *BookStock
		)
		m.oldValue = func(ctx context.Context) (*BookStock, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BookStock.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBookStock sets the old BookStock of the mutation.
func withBookStock(node *BookStock) bookstockOption {
	return func(m *BookStockMutation) {
		m.oldValue = func(context.Context) (*BookStock, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BookStockMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BookStockMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of BookStock entities.
func (m *BookStockMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BookStockMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BookStockMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BookStock.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetIsbn sets the "isbn" field.
func (m *BookStockMutation) SetIsbn(s string) {
	m.isbn = &s
}

// Isbn returns the value of the "isbn" field in the mutation.
func (m *BookStockMutation) Isbn() (r string, exists bool) {
	v := m.isbn
	if v == nil {
		return
	}
	return *v, true
}

// OldIsbn returns the old "isbn" field's value of the BookStock entity.
// If the BookStock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookStockMutation) OldIsbn(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsbn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsbn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsbn: %w", err)
	}
	return oldValue.Isbn, nil
}

// ResetIsbn resets all changes to the "isbn" field.
func (m *BookStockMutation) ResetIsbn() {
	m.isbn = nil
}

// SetQuantity sets the "quantity" field.
func (m *BookStockMutation) SetQuantity(i int) {
	m.quantity = &i
	m.addquantity = nil
}

// Quantity returns the value of the "quantity" field in the mutation.
func (m *BookStockMutation) Quantity() (r int, exists bool) {
	v := m.quantity
	if v == nil {
		return
	}
	return *v, true
}

// OldQuantity returns the old "quantity" field's value of the BookStock entity.
// If the BookStock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookStockMutation) OldQuantity(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQuantity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQuantity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuantity: %w", err)
	}
	return oldValue.Quantity, nil
}

// AddQuantity adds i to the "quantity" field.
func (m *BookStockMutation) AddQuantity(i int) {
	if m.addquantity != nil {
		*m.addquantity += i
	} else {
		m.addquantity = &i
	}
}

// AddedQuantity returns the value that was added to the "quantity" field in this mutation.
func (m *BookStockMutation) AddedQuantity() (r int, exists bool) {
	v := m.addquantity
	if v == nil {
		return
	}
	return *v, true
}

// ClearQuantity clears the value of the "quantity" field.
func (m *BookStockMutation) ClearQuantity() {
	m.quantity = nil
	m.addquantity = nil
	m.clearedFields[bookstock.FieldQuantity] = struct{}{}
}

// QuantityCleared returns if the "quantity" field was cleared in this mutation.
func (m *BookStockMutation) QuantityCleared() bool {
	_, ok := m.clearedFields[bookstock.FieldQuantity]
	return ok
}

// ResetQuantity resets all changes to the "quantity" field.
func (m *BookStockMutation) ResetQuantity() {
	m.quantity = nil
	m.addquantity = nil
	delete(m.clearedFields, bookstock.FieldQuantity)
}

// SetBookID sets the "book_id" field.
func (m *BookStockMutation) SetBookID(i int) {
	m.book_id = &i
	m.addbook_id = nil
}

// BookID returns the value of the "book_id" field in the mutation.
func (m *BookStockMutation) BookID() (r int, exists bool) {
	v := m.book_id
	if v == nil {
		return
	}
	return *v, true
}

// OldBookID returns the old "book_id" field's value of the BookStock entity.
// If the BookStock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookStockMutation) OldBookID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBookID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBookID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBookID: %w", err)
	}
	return oldValue.BookID, nil
}

// AddBookID adds i to the "book_id" field.
func (m *BookStockMutation) AddBookID(i int) {
	if m.addbook_id != nil {
		*m.addbook_id += i
	} else {
		m.addbook_id = &i
	}
}

// AddedBookID returns the value that was added to the "book_id" field in this mutation.
func (m *BookStockMutation) AddedBookID() (r int, exists bool) {
	v := m.addbook_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearBookID clears the value of the "book_id" field.
func (m *BookStockMutation) ClearBookID() {
	m.book_id = nil
	m.addbook_id = nil
	m.clearedFields[bookstock.FieldBookID] = struct{}{}
}

// BookIDCleared returns if the "book_id" field was cleared in this mutation.
func (m *BookStockMutation) BookIDCleared() bool {
	_, ok := m.clearedFields[bookstock.FieldBookID]
	return ok
}

// ResetBookID resets all changes to the "book_id" field.
func (m *BookStockMutation) ResetBookID() {
	m.book_id = nil
	m.addbook_id = nil
	delete(m.clearedFields, bookstock.FieldBookID)
}

// Where appends a list predicates to the BookStockMutation builder.
func (m *BookStockMutation) Where(ps ...predicate.BookStock) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BookStockMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BookStockMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.BookStock, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BookStockMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BookStockMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (BookStock).
func (m *BookStockMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BookStockMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.isbn != nil {
		fields = append(fields, bookstock.FieldIsbn)
	}
	if m.quantity != nil {
		fields = append(fields, bookstock.FieldQuantity)
	}
	if m.book_id != nil {
		fields = append(fields, bookstock.FieldBookID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BookStockMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case bookstock.FieldIsbn:
		return m.Isbn()
	case bookstock.FieldQuantity:
		return m.Quantity()
	case bookstock.FieldBookID:
		return m.BookID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BookStockMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case bookstock.FieldIsbn:
		return m.OldIsbn(ctx)
	case bookstock.FieldQuantity:
		return m.OldQuantity(ctx)
	case bookstock.FieldBookID:
		return m.OldBookID(ctx)
	}
	return nil, fmt.Errorf("unknown BookStock field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BookStockMutation) SetField(name string, value ent.Value) error {
	switch name {
	case bookstock.FieldIsbn:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsbn(v)
		return nil
	case bookstock.FieldQuantity:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuantity(v)
		return nil
	case bookstock.FieldBookID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBookID(v)
		return nil
	}
	return fmt.Errorf("unknown BookStock field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BookStockMutation) AddedFields() []string {
	var fields []string
	if m.addquantity != nil {
		fields = append(fields, bookstock.FieldQuantity)
	}
	if m.addbook_id != nil {
		fields = append(fields, bookstock.FieldBookID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BookStockMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case bookstock.FieldQuantity:
		return m.AddedQuantity()
	case bookstock.FieldBookID:
		return m.AddedBookID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BookStockMutation) AddField(name string, value ent.Value) error {
	switch name {
	case bookstock.FieldQuantity:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddQuantity(v)
		return nil
	case bookstock.FieldBookID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBookID(v)
		return nil
	}
	return fmt.Errorf("unknown BookStock numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BookStockMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(bookstock.FieldQuantity) {
		fields = append(fields, bookstock.FieldQuantity)
	}
	if m.FieldCleared(bookstock.FieldBookID) {
		fields = append(fields, bookstock.FieldBookID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BookStockMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BookStockMutation) ClearField(name string) error {
	switch name {
	case bookstock.FieldQuantity:
		m.ClearQuantity()
		return nil
	case bookstock.FieldBookID:
		m.ClearBookID()
		return nil
	}
	return fmt.Errorf("unknown BookStock nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BookStockMutation) ResetField(name string) error {
	switch name {
	case bookstock.FieldIsbn:
		m.ResetIsbn()
		return nil
	case bookstock.FieldQuantity:
		m.ResetQuantity()
		return nil
	case bookstock.FieldBookID:
		m.ResetBookID()
		return nil
	}
	return fmt.Errorf("unknown BookStock field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BookStockMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BookStockMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BookStockMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BookStockMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BookStockMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BookStockMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BookStockMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown BookStock unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BookStockMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown BookStock edge %s", name)
}

// BookXCatalogMutation represents an operation that mutates the BookXCatalog nodes in the graph.
type BookXCatalogMutation struct {
	config
	op            Op
	typ           string
	id            *int
	catalog_id    *int
	addcatalog_id *int
	isbn          *string
	catalog_name  *string
	book_id       *int
	addbook_id    *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*BookXCatalog, error)
	predicates    []predicate.BookXCatalog
}

var _ ent.Mutation = (*BookXCatalogMutation)(nil)

// bookxcatalogOption allows management of the mutation configuration using functional options.
type bookxcatalogOption func(*BookXCatalogMutation)

// newBookXCatalogMutation creates new mutation for the BookXCatalog entity.
func newBookXCatalogMutation(c config, op Op, opts ...bookxcatalogOption) *BookXCatalogMutation {
	m := &BookXCatalogMutation{
		config:        c,
		op:            op,
		typ:           TypeBookXCatalog,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBookXCatalogID sets the ID field of the mutation.
func withBookXCatalogID(id int) bookxcatalogOption {
	return func(m *BookXCatalogMutation) {
		var (
			err   error
			once  sync.Once
			value *BookXCatalog
		)
		m.oldValue = func(ctx context.Context) (*BookXCatalog, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BookXCatalog.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBookXCatalog sets the old BookXCatalog of the mutation.
func withBookXCatalog(node *BookXCatalog) bookxcatalogOption {
	return func(m *BookXCatalogMutation) {
		m.oldValue = func(context.Context) (*BookXCatalog, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BookXCatalogMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BookXCatalogMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of BookXCatalog entities.
func (m *BookXCatalogMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BookXCatalogMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BookXCatalogMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BookXCatalog.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCatalogID sets the "catalog_id" field.
func (m *BookXCatalogMutation) SetCatalogID(i int) {
	m.catalog_id = &i
	m.addcatalog_id = nil
}

// CatalogID returns the value of the "catalog_id" field in the mutation.
func (m *BookXCatalogMutation) CatalogID() (r int, exists bool) {
	v := m.catalog_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCatalogID returns the old "catalog_id" field's value of the BookXCatalog entity.
// If the BookXCatalog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookXCatalogMutation) OldCatalogID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCatalogID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCatalogID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCatalogID: %w", err)
	}
	return oldValue.CatalogID, nil
}

// AddCatalogID adds i to the "catalog_id" field.
func (m *BookXCatalogMutation) AddCatalogID(i int) {
	if m.addcatalog_id != nil {
		*m.addcatalog_id += i
	} else {
		m.addcatalog_id = &i
	}
}

// AddedCatalogID returns the value that was added to the "catalog_id" field in this mutation.
func (m *BookXCatalogMutation) AddedCatalogID() (r int, exists bool) {
	v := m.addcatalog_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetCatalogID resets all changes to the "catalog_id" field.
func (m *BookXCatalogMutation) ResetCatalogID() {
	m.catalog_id = nil
	m.addcatalog_id = nil
}

// SetIsbn sets the "isbn" field.
func (m *BookXCatalogMutation) SetIsbn(s string) {
	m.isbn = &s
}

// Isbn returns the value of the "isbn" field in the mutation.
func (m *BookXCatalogMutation) Isbn() (r string, exists bool) {
	v := m.isbn
	if v == nil {
		return
	}
	return *v, true
}

// OldIsbn returns the old "isbn" field's value of the BookXCatalog entity.
// If the BookXCatalog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookXCatalogMutation) OldIsbn(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsbn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsbn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsbn: %w", err)
	}
	return oldValue.Isbn, nil
}

// ResetIsbn resets all changes to the "isbn" field.
func (m *BookXCatalogMutation) ResetIsbn() {
	m.isbn = nil
}

// SetCatalogName sets the "catalog_name" field.
func (m *BookXCatalogMutation) SetCatalogName(s string) {
	m.catalog_name = &s
}

// CatalogName returns the value of the "catalog_name" field in the mutation.
func (m *BookXCatalogMutation) CatalogName() (r string, exists bool) {
	v := m.catalog_name
	if v == nil {
		return
	}
	return *v, true
}

// OldCatalogName returns the old "catalog_name" field's value of the BookXCatalog entity.
// If the BookXCatalog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookXCatalogMutation) OldCatalogName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCatalogName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCatalogName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCatalogName: %w", err)
	}
	return oldValue.CatalogName, nil
}

// ClearCatalogName clears the value of the "catalog_name" field.
func (m *BookXCatalogMutation) ClearCatalogName() {
	m.catalog_name = nil
	m.clearedFields[bookxcatalog.FieldCatalogName] = struct{}{}
}

// CatalogNameCleared returns if the "catalog_name" field was cleared in this mutation.
func (m *BookXCatalogMutation) CatalogNameCleared() bool {
	_, ok := m.clearedFields[bookxcatalog.FieldCatalogName]
	return ok
}

// ResetCatalogName resets all changes to the "catalog_name" field.
func (m *BookXCatalogMutation) ResetCatalogName() {
	m.catalog_name = nil
	delete(m.clearedFields, bookxcatalog.FieldCatalogName)
}

// SetBookID sets the "book_id" field.
func (m *BookXCatalogMutation) SetBookID(i int) {
	m.book_id = &i
	m.addbook_id = nil
}

// BookID returns the value of the "book_id" field in the mutation.
func (m *BookXCatalogMutation) BookID() (r int, exists bool) {
	v := m.book_id
	if v == nil {
		return
	}
	return *v, true
}

// OldBookID returns the old "book_id" field's value of the BookXCatalog entity.
// If the BookXCatalog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookXCatalogMutation) OldBookID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBookID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBookID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBookID: %w", err)
	}
	return oldValue.BookID, nil
}

// AddBookID adds i to the "book_id" field.
func (m *BookXCatalogMutation) AddBookID(i int) {
	if m.addbook_id != nil {
		*m.addbook_id += i
	} else {
		m.addbook_id = &i
	}
}

// AddedBookID returns the value that was added to the "book_id" field in this mutation.
func (m *BookXCatalogMutation) AddedBookID() (r int, exists bool) {
	v := m.addbook_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearBookID clears the value of the "book_id" field.
func (m *BookXCatalogMutation) ClearBookID() {
	m.book_id = nil
	m.addbook_id = nil
	m.clearedFields[bookxcatalog.FieldBookID] = struct{}{}
}

// BookIDCleared returns if the "book_id" field was cleared in this mutation.
func (m *BookXCatalogMutation) BookIDCleared() bool {
	_, ok := m.clearedFields[bookxcatalog.FieldBookID]
	return ok
}

// ResetBookID resets all changes to the "book_id" field.
func (m *BookXCatalogMutation) ResetBookID() {
	m.book_id = nil
	m.addbook_id = nil
	delete(m.clearedFields, bookxcatalog.FieldBookID)
}

// Where appends a list predicates to the BookXCatalogMutation builder.
func (m *BookXCatalogMutation) Where(ps ...predicate.BookXCatalog) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BookXCatalogMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BookXCatalogMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.BookXCatalog, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BookXCatalogMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BookXCatalogMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (BookXCatalog).
func (m *BookXCatalogMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BookXCatalogMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.catalog_id != nil {
		fields = append(fields, bookxcatalog.FieldCatalogID)
	}
	if m.isbn != nil {
		fields = append(fields, bookxcatalog.FieldIsbn)
	}
	if m.catalog_name != nil {
		fields = append(fields, bookxcatalog.FieldCatalogName)
	}
	if m.book_id != nil {
		fields = append(fields, bookxcatalog.FieldBookID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BookXCatalogMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case bookxcatalog.FieldCatalogID:
		return m.CatalogID()
	case bookxcatalog.FieldIsbn:
		return m.Isbn()
	case bookxcatalog.FieldCatalogName:
		return m.CatalogName()
	case bookxcatalog.FieldBookID:
		return m.BookID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BookXCatalogMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case bookxcatalog.FieldCatalogID:
		return m.OldCatalogID(ctx)
	case bookxcatalog.FieldIsbn:
		return m.OldIsbn(ctx)
	case bookxcatalog.FieldCatalogName:
		return m.OldCatalogName(ctx)
	case bookxcatalog.FieldBookID:
		return m.OldBookID(ctx)
	}
	return nil, fmt.Errorf("unknown BookXCatalog field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BookXCatalogMutation) SetField(name string, value ent.Value) error {
	switch name {
	case bookxcatalog.FieldCatalogID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCatalogID(v)
		return nil
	case bookxcatalog.FieldIsbn:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsbn(v)
		return nil
	case bookxcatalog.FieldCatalogName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCatalogName(v)
		return nil
	case bookxcatalog.FieldBookID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBookID(v)
		return nil
	}
	return fmt.Errorf("unknown BookXCatalog field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BookXCatalogMutation) AddedFields() []string {
	var fields []string
	if m.addcatalog_id != nil {
		fields = append(fields, bookxcatalog.FieldCatalogID)
	}
	if m.addbook_id != nil {
		fields = append(fields, bookxcatalog.FieldBookID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BookXCatalogMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case bookxcatalog.FieldCatalogID:
		return m.AddedCatalogID()
	case bookxcatalog.FieldBookID:
		return m.AddedBookID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BookXCatalogMutation) AddField(name string, value ent.Value) error {
	switch name {
	case bookxcatalog.FieldCatalogID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCatalogID(v)
		return nil
	case bookxcatalog.FieldBookID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBookID(v)
		return nil
	}
	return fmt.Errorf("unknown BookXCatalog numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BookXCatalogMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(bookxcatalog.FieldCatalogName) {
		fields = append(fields, bookxcatalog.FieldCatalogName)
	}
	if m.FieldCleared(bookxcatalog.FieldBookID) {
		fields = append(fields, bookxcatalog.FieldBookID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BookXCatalogMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BookXCatalogMutation) ClearField(name string) error {
	switch name {
	case bookxcatalog.FieldCatalogName:
		m.ClearCatalogName()
		return nil
	case bookxcatalog.FieldBookID:
		m.ClearBookID()
		return nil
	}
	return fmt.Errorf("unknown BookXCatalog nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BookXCatalogMutation) ResetField(name string) error {
	switch name {
	case bookxcatalog.FieldCatalogID:
		m.ResetCatalogID()
		return nil
	case bookxcatalog.FieldIsbn:
		m.ResetIsbn()
		return nil
	case bookxcatalog.FieldCatalogName:
		m.ResetCatalogName()
		return nil
	case bookxcatalog.FieldBookID:
		m.ResetBookID()
		return nil
	}
	return fmt.Errorf("unknown BookXCatalog field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BookXCatalogMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BookXCatalogMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BookXCatalogMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BookXCatalogMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BookXCatalogMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BookXCatalogMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BookXCatalogMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown BookXCatalog unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BookXCatalogMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown BookXCatalog edge %s", name)
}

// BookXClassicMutation represents an operation that mutates the BookXClassic nodes in the graph.
type BookXClassicMutation struct {
	config
	op            Op
	typ           string
	id            *int
	classic_id    *int
	addclassic_id *int
	isbn          *string
	classic_name  *string
	book_id       *int
	addbook_id    *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*BookXClassic, error)
	predicates    []predicate.BookXClassic
}

var _ ent.Mutation = (*BookXClassicMutation)(nil)

// bookxclassicOption allows management of the mutation configuration using functional options.
type bookxclassicOption func(*BookXClassicMutation)

// newBookXClassicMutation creates new mutation for the BookXClassic entity.
func newBookXClassicMutation(c config, op Op, opts ...bookxclassicOption) *BookXClassicMutation {
	m := &BookXClassicMutation{
		config:        c,
		op:            op,
		typ:           TypeBookXClassic,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBookXClassicID sets the ID field of the mutation.
func withBookXClassicID(id int) bookxclassicOption {
	return func(m *BookXClassicMutation) {
		var (
			err   error
			once  sync.Once
			value *BookXClassic
		)
		m.oldValue = func(ctx context.Context) (*BookXClassic, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BookXClassic.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBookXClassic sets the old BookXClassic of the mutation.
func withBookXClassic(node *BookXClassic) bookxclassicOption {
	return func(m *BookXClassicMutation) {
		m.oldValue = func(context.Context) (*BookXClassic, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BookXClassicMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BookXClassicMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of BookXClassic entities.
func (m *BookXClassicMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BookXClassicMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BookXClassicMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BookXClassic.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetClassicID sets the "classic_id" field.
func (m *BookXClassicMutation) SetClassicID(i int) {
	m.classic_id = &i
	m.addclassic_id = nil
}

// ClassicID returns the value of the "classic_id" field in the mutation.
func (m *BookXClassicMutation) ClassicID() (r int, exists bool) {
	v := m.classic_id
	if v == nil {
		return
	}
	return *v, true
}

// OldClassicID returns the old "classic_id" field's value of the BookXClassic entity.
// If the BookXClassic object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookXClassicMutation) OldClassicID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClassicID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClassicID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClassicID: %w", err)
	}
	return oldValue.ClassicID, nil
}

// AddClassicID adds i to the "classic_id" field.
func (m *BookXClassicMutation) AddClassicID(i int) {
	if m.addclassic_id != nil {
		*m.addclassic_id += i
	} else {
		m.addclassic_id = &i
	}
}

// AddedClassicID returns the value that was added to the "classic_id" field in this mutation.
func (m *BookXClassicMutation) AddedClassicID() (r int, exists bool) {
	v := m.addclassic_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetClassicID resets all changes to the "classic_id" field.
func (m *BookXClassicMutation) ResetClassicID() {
	m.classic_id = nil
	m.addclassic_id = nil
}

// SetIsbn sets the "isbn" field.
func (m *BookXClassicMutation) SetIsbn(s string) {
	m.isbn = &s
}

// Isbn returns the value of the "isbn" field in the mutation.
func (m *BookXClassicMutation) Isbn() (r string, exists bool) {
	v := m.isbn
	if v == nil {
		return
	}
	return *v, true
}

// OldIsbn returns the old "isbn" field's value of the BookXClassic entity.
// If the BookXClassic object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookXClassicMutation) OldIsbn(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsbn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsbn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsbn: %w", err)
	}
	return oldValue.Isbn, nil
}

// ResetIsbn resets all changes to the "isbn" field.
func (m *BookXClassicMutation) ResetIsbn() {
	m.isbn = nil
}

// SetClassicName sets the "classic_name" field.
func (m *BookXClassicMutation) SetClassicName(s string) {
	m.classic_name = &s
}

// ClassicName returns the value of the "classic_name" field in the mutation.
func (m *BookXClassicMutation) ClassicName() (r string, exists bool) {
	v := m.classic_name
	if v == nil {
		return
	}
	return *v, true
}

// OldClassicName returns the old "classic_name" field's value of the BookXClassic entity.
// If the BookXClassic object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookXClassicMutation) OldClassicName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClassicName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClassicName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClassicName: %w", err)
	}
	return oldValue.ClassicName, nil
}

// ClearClassicName clears the value of the "classic_name" field.
func (m *BookXClassicMutation) ClearClassicName() {
	m.classic_name = nil
	m.clearedFields[bookxclassic.FieldClassicName] = struct{}{}
}

// ClassicNameCleared returns if the "classic_name" field was cleared in this mutation.
func (m *BookXClassicMutation) ClassicNameCleared() bool {
	_, ok := m.clearedFields[bookxclassic.FieldClassicName]
	return ok
}

// ResetClassicName resets all changes to the "classic_name" field.
func (m *BookXClassicMutation) ResetClassicName() {
	m.classic_name = nil
	delete(m.clearedFields, bookxclassic.FieldClassicName)
}

// SetBookID sets the "book_id" field.
func (m *BookXClassicMutation) SetBookID(i int) {
	m.book_id = &i
	m.addbook_id = nil
}

// BookID returns the value of the "book_id" field in the mutation.
func (m *BookXClassicMutation) BookID() (r int, exists bool) {
	v := m.book_id
	if v == nil {
		return
	}
	return *v, true
}

// OldBookID returns the old "book_id" field's value of the BookXClassic entity.
// If the BookXClassic object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookXClassicMutation) OldBookID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBookID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBookID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBookID: %w", err)
	}
	return oldValue.BookID, nil
}

// AddBookID adds i to the "book_id" field.
func (m *BookXClassicMutation) AddBookID(i int) {
	if m.addbook_id != nil {
		*m.addbook_id += i
	} else {
		m.addbook_id = &i
	}
}

// AddedBookID returns the value that was added to the "book_id" field in this mutation.
func (m *BookXClassicMutation) AddedBookID() (r int, exists bool) {
	v := m.addbook_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearBookID clears the value of the "book_id" field.
func (m *BookXClassicMutation) ClearBookID() {
	m.book_id = nil
	m.addbook_id = nil
	m.clearedFields[bookxclassic.FieldBookID] = struct{}{}
}

// BookIDCleared returns if the "book_id" field was cleared in this mutation.
func (m *BookXClassicMutation) BookIDCleared() bool {
	_, ok := m.clearedFields[bookxclassic.FieldBookID]
	return ok
}

// ResetBookID resets all changes to the "book_id" field.
func (m *BookXClassicMutation) ResetBookID() {
	m.book_id = nil
	m.addbook_id = nil
	delete(m.clearedFields, bookxclassic.FieldBookID)
}

// Where appends a list predicates to the BookXClassicMutation builder.
func (m *BookXClassicMutation) Where(ps ...predicate.BookXClassic) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BookXClassicMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BookXClassicMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.BookXClassic, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BookXClassicMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BookXClassicMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (BookXClassic).
func (m *BookXClassicMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BookXClassicMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.classic_id != nil {
		fields = append(fields, bookxclassic.FieldClassicID)
	}
	if m.isbn != nil {
		fields = append(fields, bookxclassic.FieldIsbn)
	}
	if m.classic_name != nil {
		fields = append(fields, bookxclassic.FieldClassicName)
	}
	if m.book_id != nil {
		fields = append(fields, bookxclassic.FieldBookID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BookXClassicMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case bookxclassic.FieldClassicID:
		return m.ClassicID()
	case bookxclassic.FieldIsbn:
		return m.Isbn()
	case bookxclassic.FieldClassicName:
		return m.ClassicName()
	case bookxclassic.FieldBookID:
		return m.BookID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BookXClassicMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case bookxclassic.FieldClassicID:
		return m.OldClassicID(ctx)
	case bookxclassic.FieldIsbn:
		return m.OldIsbn(ctx)
	case bookxclassic.FieldClassicName:
		return m.OldClassicName(ctx)
	case bookxclassic.FieldBookID:
		return m.OldBookID(ctx)
	}
	return nil, fmt.Errorf("unknown BookXClassic field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BookXClassicMutation) SetField(name string, value ent.Value) error {
	switch name {
	case bookxclassic.FieldClassicID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClassicID(v)
		return nil
	case bookxclassic.FieldIsbn:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsbn(v)
		return nil
	case bookxclassic.FieldClassicName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClassicName(v)
		return nil
	case bookxclassic.FieldBookID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBookID(v)
		return nil
	}
	return fmt.Errorf("unknown BookXClassic field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BookXClassicMutation) AddedFields() []string {
	var fields []string
	if m.addclassic_id != nil {
		fields = append(fields, bookxclassic.FieldClassicID)
	}
	if m.addbook_id != nil {
		fields = append(fields, bookxclassic.FieldBookID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BookXClassicMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case bookxclassic.FieldClassicID:
		return m.AddedClassicID()
	case bookxclassic.FieldBookID:
		return m.AddedBookID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BookXClassicMutation) AddField(name string, value ent.Value) error {
	switch name {
	case bookxclassic.FieldClassicID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddClassicID(v)
		return nil
	case bookxclassic.FieldBookID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBookID(v)
		return nil
	}
	return fmt.Errorf("unknown BookXClassic numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BookXClassicMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(bookxclassic.FieldClassicName) {
		fields = append(fields, bookxclassic.FieldClassicName)
	}
	if m.FieldCleared(bookxclassic.FieldBookID) {
		fields = append(fields, bookxclassic.FieldBookID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BookXClassicMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BookXClassicMutation) ClearField(name string) error {
	switch name {
	case bookxclassic.FieldClassicName:
		m.ClearClassicName()
		return nil
	case bookxclassic.FieldBookID:
		m.ClearBookID()
		return nil
	}
	return fmt.Errorf("unknown BookXClassic nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BookXClassicMutation) ResetField(name string) error {
	switch name {
	case bookxclassic.FieldClassicID:
		m.ResetClassicID()
		return nil
	case bookxclassic.FieldIsbn:
		m.ResetIsbn()
		return nil
	case bookxclassic.FieldClassicName:
		m.ResetClassicName()
		return nil
	case bookxclassic.FieldBookID:
		m.ResetBookID()
		return nil
	}
	return fmt.Errorf("unknown BookXClassic field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BookXClassicMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BookXClassicMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BookXClassicMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BookXClassicMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BookXClassicMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BookXClassicMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BookXClassicMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown BookXClassic unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BookXClassicMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown BookXClassic edge %s", name)
}

// BookXLanguageMutation represents an operation that mutates the BookXLanguage nodes in the graph.
type BookXLanguageMutation struct {
	config
	op             Op
	typ            string
	id             *int
	language_id    *int
	addlanguage_id *int
	isbn           *string
	language_name  *string
	book_id        *int
	addbook_id     *int
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*BookXLanguage, error)
	predicates     []predicate.BookXLanguage
}

var _ ent.Mutation = (*BookXLanguageMutation)(nil)

// bookxlanguageOption allows management of the mutation configuration using functional options.
type bookxlanguageOption func(*BookXLanguageMutation)

// newBookXLanguageMutation creates new mutation for the BookXLanguage entity.
func newBookXLanguageMutation(c config, op Op, opts ...bookxlanguageOption) *BookXLanguageMutation {
	m := &BookXLanguageMutation{
		config:        c,
		op:            op,
		typ:           TypeBookXLanguage,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBookXLanguageID sets the ID field of the mutation.
func withBookXLanguageID(id int) bookxlanguageOption {
	return func(m *BookXLanguageMutation) {
		var (
			err   error
			once  sync.Once
			value *BookXLanguage
		)
		m.oldValue = func(ctx context.Context) (*BookXLanguage, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BookXLanguage.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBookXLanguage sets the old BookXLanguage of the mutation.
func withBookXLanguage(node *BookXLanguage) bookxlanguageOption {
	return func(m *BookXLanguageMutation) {
		m.oldValue = func(context.Context) (*BookXLanguage, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BookXLanguageMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BookXLanguageMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of BookXLanguage entities.
func (m *BookXLanguageMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BookXLanguageMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BookXLanguageMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BookXLanguage.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetLanguageID sets the "language_id" field.
func (m *BookXLanguageMutation) SetLanguageID(i int) {
	m.language_id = &i
	m.addlanguage_id = nil
}

// LanguageID returns the value of the "language_id" field in the mutation.
func (m *BookXLanguageMutation) LanguageID() (r int, exists bool) {
	v := m.language_id
	if v == nil {
		return
	}
	return *v, true
}

// OldLanguageID returns the old "language_id" field's value of the BookXLanguage entity.
// If the BookXLanguage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookXLanguageMutation) OldLanguageID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLanguageID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLanguageID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLanguageID: %w", err)
	}
	return oldValue.LanguageID, nil
}

// AddLanguageID adds i to the "language_id" field.
func (m *BookXLanguageMutation) AddLanguageID(i int) {
	if m.addlanguage_id != nil {
		*m.addlanguage_id += i
	} else {
		m.addlanguage_id = &i
	}
}

// AddedLanguageID returns the value that was added to the "language_id" field in this mutation.
func (m *BookXLanguageMutation) AddedLanguageID() (r int, exists bool) {
	v := m.addlanguage_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetLanguageID resets all changes to the "language_id" field.
func (m *BookXLanguageMutation) ResetLanguageID() {
	m.language_id = nil
	m.addlanguage_id = nil
}

// SetIsbn sets the "isbn" field.
func (m *BookXLanguageMutation) SetIsbn(s string) {
	m.isbn = &s
}

// Isbn returns the value of the "isbn" field in the mutation.
func (m *BookXLanguageMutation) Isbn() (r string, exists bool) {
	v := m.isbn
	if v == nil {
		return
	}
	return *v, true
}

// OldIsbn returns the old "isbn" field's value of the BookXLanguage entity.
// If the BookXLanguage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookXLanguageMutation) OldIsbn(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsbn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsbn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsbn: %w", err)
	}
	return oldValue.Isbn, nil
}

// ResetIsbn resets all changes to the "isbn" field.
func (m *BookXLanguageMutation) ResetIsbn() {
	m.isbn = nil
}

// SetLanguageName sets the "language_name" field.
func (m *BookXLanguageMutation) SetLanguageName(s string) {
	m.language_name = &s
}

// LanguageName returns the value of the "language_name" field in the mutation.
func (m *BookXLanguageMutation) LanguageName() (r string, exists bool) {
	v := m.language_name
	if v == nil {
		return
	}
	return *v, true
}

// OldLanguageName returns the old "language_name" field's value of the BookXLanguage entity.
// If the BookXLanguage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookXLanguageMutation) OldLanguageName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLanguageName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLanguageName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLanguageName: %w", err)
	}
	return oldValue.LanguageName, nil
}

// ClearLanguageName clears the value of the "language_name" field.
func (m *BookXLanguageMutation) ClearLanguageName() {
	m.language_name = nil
	m.clearedFields[bookxlanguage.FieldLanguageName] = struct{}{}
}

// LanguageNameCleared returns if the "language_name" field was cleared in this mutation.
func (m *BookXLanguageMutation) LanguageNameCleared() bool {
	_, ok := m.clearedFields[bookxlanguage.FieldLanguageName]
	return ok
}

// ResetLanguageName resets all changes to the "language_name" field.
func (m *BookXLanguageMutation) ResetLanguageName() {
	m.language_name = nil
	delete(m.clearedFields, bookxlanguage.FieldLanguageName)
}

// SetBookID sets the "book_id" field.
func (m *BookXLanguageMutation) SetBookID(i int) {
	m.book_id = &i
	m.addbook_id = nil
}

// BookID returns the value of the "book_id" field in the mutation.
func (m *BookXLanguageMutation) BookID() (r int, exists bool) {
	v := m.book_id
	if v == nil {
		return
	}
	return *v, true
}

// OldBookID returns the old "book_id" field's value of the BookXLanguage entity.
// If the BookXLanguage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookXLanguageMutation) OldBookID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBookID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBookID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBookID: %w", err)
	}
	return oldValue.BookID, nil
}

// AddBookID adds i to the "book_id" field.
func (m *BookXLanguageMutation) AddBookID(i int) {
	if m.addbook_id != nil {
		*m.addbook_id += i
	} else {
		m.addbook_id = &i
	}
}

// AddedBookID returns the value that was added to the "book_id" field in this mutation.
func (m *BookXLanguageMutation) AddedBookID() (r int, exists bool) {
	v := m.addbook_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearBookID clears the value of the "book_id" field.
func (m *BookXLanguageMutation) ClearBookID() {
	m.book_id = nil
	m.addbook_id = nil
	m.clearedFields[bookxlanguage.FieldBookID] = struct{}{}
}

// BookIDCleared returns if the "book_id" field was cleared in this mutation.
func (m *BookXLanguageMutation) BookIDCleared() bool {
	_, ok := m.clearedFields[bookxlanguage.FieldBookID]
	return ok
}

// ResetBookID resets all changes to the "book_id" field.
func (m *BookXLanguageMutation) ResetBookID() {
	m.book_id = nil
	m.addbook_id = nil
	delete(m.clearedFields, bookxlanguage.FieldBookID)
}

// Where appends a list predicates to the BookXLanguageMutation builder.
func (m *BookXLanguageMutation) Where(ps ...predicate.BookXLanguage) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BookXLanguageMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BookXLanguageMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.BookXLanguage, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BookXLanguageMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BookXLanguageMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (BookXLanguage).
func (m *BookXLanguageMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BookXLanguageMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.language_id != nil {
		fields = append(fields, bookxlanguage.FieldLanguageID)
	}
	if m.isbn != nil {
		fields = append(fields, bookxlanguage.FieldIsbn)
	}
	if m.language_name != nil {
		fields = append(fields, bookxlanguage.FieldLanguageName)
	}
	if m.book_id != nil {
		fields = append(fields, bookxlanguage.FieldBookID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BookXLanguageMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case bookxlanguage.FieldLanguageID:
		return m.LanguageID()
	case bookxlanguage.FieldIsbn:
		return m.Isbn()
	case bookxlanguage.FieldLanguageName:
		return m.LanguageName()
	case bookxlanguage.FieldBookID:
		return m.BookID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BookXLanguageMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case bookxlanguage.FieldLanguageID:
		return m.OldLanguageID(ctx)
	case bookxlanguage.FieldIsbn:
		return m.OldIsbn(ctx)
	case bookxlanguage.FieldLanguageName:
		return m.OldLanguageName(ctx)
	case bookxlanguage.FieldBookID:
		return m.OldBookID(ctx)
	}
	return nil, fmt.Errorf("unknown BookXLanguage field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BookXLanguageMutation) SetField(name string, value ent.Value) error {
	switch name {
	case bookxlanguage.FieldLanguageID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLanguageID(v)
		return nil
	case bookxlanguage.FieldIsbn:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsbn(v)
		return nil
	case bookxlanguage.FieldLanguageName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLanguageName(v)
		return nil
	case bookxlanguage.FieldBookID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBookID(v)
		return nil
	}
	return fmt.Errorf("unknown BookXLanguage field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BookXLanguageMutation) AddedFields() []string {
	var fields []string
	if m.addlanguage_id != nil {
		fields = append(fields, bookxlanguage.FieldLanguageID)
	}
	if m.addbook_id != nil {
		fields = append(fields, bookxlanguage.FieldBookID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BookXLanguageMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case bookxlanguage.FieldLanguageID:
		return m.AddedLanguageID()
	case bookxlanguage.FieldBookID:
		return m.AddedBookID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BookXLanguageMutation) AddField(name string, value ent.Value) error {
	switch name {
	case bookxlanguage.FieldLanguageID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLanguageID(v)
		return nil
	case bookxlanguage.FieldBookID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBookID(v)
		return nil
	}
	return fmt.Errorf("unknown BookXLanguage numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BookXLanguageMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(bookxlanguage.FieldLanguageName) {
		fields = append(fields, bookxlanguage.FieldLanguageName)
	}
	if m.FieldCleared(bookxlanguage.FieldBookID) {
		fields = append(fields, bookxlanguage.FieldBookID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BookXLanguageMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BookXLanguageMutation) ClearField(name string) error {
	switch name {
	case bookxlanguage.FieldLanguageName:
		m.ClearLanguageName()
		return nil
	case bookxlanguage.FieldBookID:
		m.ClearBookID()
		return nil
	}
	return fmt.Errorf("unknown BookXLanguage nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BookXLanguageMutation) ResetField(name string) error {
	switch name {
	case bookxlanguage.FieldLanguageID:
		m.ResetLanguageID()
		return nil
	case bookxlanguage.FieldIsbn:
		m.ResetIsbn()
		return nil
	case bookxlanguage.FieldLanguageName:
		m.ResetLanguageName()
		return nil
	case bookxlanguage.FieldBookID:
		m.ResetBookID()
		return nil
	}
	return fmt.Errorf("unknown BookXLanguage field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BookXLanguageMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BookXLanguageMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BookXLanguageMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BookXLanguageMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BookXLanguageMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BookXLanguageMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BookXLanguageMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown BookXLanguage unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BookXLanguageMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown BookXLanguage edge %s", name)
}

// CategoryMutation represents an operation that mutates the Category nodes in the graph.
type CategoryMutation struct {
	config
	op                Op
	typ               string
	id                *int
	description       *string
	catalog_name      *string
	parent_catalog_id *string
	clearedFields     map[string]struct{}
	done              bool
	oldValue          func(context.Context) (*Category, error)
	predicates        []predicate.Category
}

var _ ent.Mutation = (*CategoryMutation)(nil)

// categoryOption allows management of the mutation configuration using functional options.
type categoryOption func(*CategoryMutation)

// newCategoryMutation creates new mutation for the Category entity.
func newCategoryMutation(c config, op Op, opts ...categoryOption) *CategoryMutation {
	m := &CategoryMutation{
		config:        c,
		op:            op,
		typ:           TypeCategory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCategoryID sets the ID field of the mutation.
func withCategoryID(id int) categoryOption {
	return func(m *CategoryMutation) {
		var (
			err   error
			once  sync.Once
			value *Category
		)
		m.oldValue = func(ctx context.Context) (*Category, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Category.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCategory sets the old Category of the mutation.
func withCategory(node *Category) categoryOption {
	return func(m *CategoryMutation) {
		m.oldValue = func(context.Context) (*Category, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CategoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CategoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Category entities.
func (m *CategoryMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CategoryMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CategoryMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Category.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDescription sets the "description" field.
func (m *CategoryMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *CategoryMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *CategoryMutation) ResetDescription() {
	m.description = nil
}

// SetCatalogName sets the "catalog_name" field.
func (m *CategoryMutation) SetCatalogName(s string) {
	m.catalog_name = &s
}

// CatalogName returns the value of the "catalog_name" field in the mutation.
func (m *CategoryMutation) CatalogName() (r string, exists bool) {
	v := m.catalog_name
	if v == nil {
		return
	}
	return *v, true
}

// OldCatalogName returns the old "catalog_name" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldCatalogName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCatalogName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCatalogName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCatalogName: %w", err)
	}
	return oldValue.CatalogName, nil
}

// ClearCatalogName clears the value of the "catalog_name" field.
func (m *CategoryMutation) ClearCatalogName() {
	m.catalog_name = nil
	m.clearedFields[category.FieldCatalogName] = struct{}{}
}

// CatalogNameCleared returns if the "catalog_name" field was cleared in this mutation.
func (m *CategoryMutation) CatalogNameCleared() bool {
	_, ok := m.clearedFields[category.FieldCatalogName]
	return ok
}

// ResetCatalogName resets all changes to the "catalog_name" field.
func (m *CategoryMutation) ResetCatalogName() {
	m.catalog_name = nil
	delete(m.clearedFields, category.FieldCatalogName)
}

// SetParentCatalogID sets the "parent_catalog_id" field.
func (m *CategoryMutation) SetParentCatalogID(s string) {
	m.parent_catalog_id = &s
}

// ParentCatalogID returns the value of the "parent_catalog_id" field in the mutation.
func (m *CategoryMutation) ParentCatalogID() (r string, exists bool) {
	v := m.parent_catalog_id
	if v == nil {
		return
	}
	return *v, true
}

// OldParentCatalogID returns the old "parent_catalog_id" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldParentCatalogID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentCatalogID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentCatalogID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentCatalogID: %w", err)
	}
	return oldValue.ParentCatalogID, nil
}

// ResetParentCatalogID resets all changes to the "parent_catalog_id" field.
func (m *CategoryMutation) ResetParentCatalogID() {
	m.parent_catalog_id = nil
}

// Where appends a list predicates to the CategoryMutation builder.
func (m *CategoryMutation) Where(ps ...predicate.Category) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CategoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CategoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Category, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CategoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CategoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Category).
func (m *CategoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CategoryMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.description != nil {
		fields = append(fields, category.FieldDescription)
	}
	if m.catalog_name != nil {
		fields = append(fields, category.FieldCatalogName)
	}
	if m.parent_catalog_id != nil {
		fields = append(fields, category.FieldParentCatalogID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CategoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case category.FieldDescription:
		return m.Description()
	case category.FieldCatalogName:
		return m.CatalogName()
	case category.FieldParentCatalogID:
		return m.ParentCatalogID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CategoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case category.FieldDescription:
		return m.OldDescription(ctx)
	case category.FieldCatalogName:
		return m.OldCatalogName(ctx)
	case category.FieldParentCatalogID:
		return m.OldParentCatalogID(ctx)
	}
	return nil, fmt.Errorf("unknown Category field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CategoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case category.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case category.FieldCatalogName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCatalogName(v)
		return nil
	case category.FieldParentCatalogID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentCatalogID(v)
		return nil
	}
	return fmt.Errorf("unknown Category field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CategoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CategoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CategoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Category numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CategoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(category.FieldCatalogName) {
		fields = append(fields, category.FieldCatalogName)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CategoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CategoryMutation) ClearField(name string) error {
	switch name {
	case category.FieldCatalogName:
		m.ClearCatalogName()
		return nil
	}
	return fmt.Errorf("unknown Category nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CategoryMutation) ResetField(name string) error {
	switch name {
	case category.FieldDescription:
		m.ResetDescription()
		return nil
	case category.FieldCatalogName:
		m.ResetCatalogName()
		return nil
	case category.FieldParentCatalogID:
		m.ResetParentCatalogID()
		return nil
	}
	return fmt.Errorf("unknown Category field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CategoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CategoryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CategoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CategoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CategoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CategoryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CategoryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Category unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CategoryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Category edge %s", name)
}

// ClassicMutation represents an operation that mutates the Classic nodes in the graph.
type ClassicMutation struct {
	config
	op            Op
	typ           string
	id            *int
	classic_name  *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Classic, error)
	predicates    []predicate.Classic
}

var _ ent.Mutation = (*ClassicMutation)(nil)

// classicOption allows management of the mutation configuration using functional options.
type classicOption func(*ClassicMutation)

// newClassicMutation creates new mutation for the Classic entity.
func newClassicMutation(c config, op Op, opts ...classicOption) *ClassicMutation {
	m := &ClassicMutation{
		config:        c,
		op:            op,
		typ:           TypeClassic,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withClassicID sets the ID field of the mutation.
func withClassicID(id int) classicOption {
	return func(m *ClassicMutation) {
		var (
			err   error
			once  sync.Once
			value *Classic
		)
		m.oldValue = func(ctx context.Context) (*Classic, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Classic.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withClassic sets the old Classic of the mutation.
func withClassic(node *Classic) classicOption {
	return func(m *ClassicMutation) {
		m.oldValue = func(context.Context) (*Classic, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ClassicMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ClassicMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Classic entities.
func (m *ClassicMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ClassicMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ClassicMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Classic.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetClassicName sets the "classic_name" field.
func (m *ClassicMutation) SetClassicName(s string) {
	m.classic_name = &s
}

// ClassicName returns the value of the "classic_name" field in the mutation.
func (m *ClassicMutation) ClassicName() (r string, exists bool) {
	v := m.classic_name
	if v == nil {
		return
	}
	return *v, true
}

// OldClassicName returns the old "classic_name" field's value of the Classic entity.
// If the Classic object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClassicMutation) OldClassicName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClassicName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClassicName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClassicName: %w", err)
	}
	return oldValue.ClassicName, nil
}

// ClearClassicName clears the value of the "classic_name" field.
func (m *ClassicMutation) ClearClassicName() {
	m.classic_name = nil
	m.clearedFields[classic.FieldClassicName] = struct{}{}
}

// ClassicNameCleared returns if the "classic_name" field was cleared in this mutation.
func (m *ClassicMutation) ClassicNameCleared() bool {
	_, ok := m.clearedFields[classic.FieldClassicName]
	return ok
}

// ResetClassicName resets all changes to the "classic_name" field.
func (m *ClassicMutation) ResetClassicName() {
	m.classic_name = nil
	delete(m.clearedFields, classic.FieldClassicName)
}

// Where appends a list predicates to the ClassicMutation builder.
func (m *ClassicMutation) Where(ps ...predicate.Classic) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ClassicMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ClassicMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Classic, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ClassicMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ClassicMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Classic).
func (m *ClassicMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ClassicMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.classic_name != nil {
		fields = append(fields, classic.FieldClassicName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ClassicMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case classic.FieldClassicName:
		return m.ClassicName()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ClassicMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case classic.FieldClassicName:
		return m.OldClassicName(ctx)
	}
	return nil, fmt.Errorf("unknown Classic field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ClassicMutation) SetField(name string, value ent.Value) error {
	switch name {
	case classic.FieldClassicName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClassicName(v)
		return nil
	}
	return fmt.Errorf("unknown Classic field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ClassicMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ClassicMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ClassicMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Classic numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ClassicMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(classic.FieldClassicName) {
		fields = append(fields, classic.FieldClassicName)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ClassicMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ClassicMutation) ClearField(name string) error {
	switch name {
	case classic.FieldClassicName:
		m.ClearClassicName()
		return nil
	}
	return fmt.Errorf("unknown Classic nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ClassicMutation) ResetField(name string) error {
	switch name {
	case classic.FieldClassicName:
		m.ResetClassicName()
		return nil
	}
	return fmt.Errorf("unknown Classic field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ClassicMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ClassicMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ClassicMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ClassicMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ClassicMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ClassicMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ClassicMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Classic unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ClassicMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Classic edge %s", name)
}

// LanguageMutation represents an operation that mutates the Language nodes in the graph.
type LanguageMutation struct {
	config
	op            Op
	typ           string
	id            *int
	language_name *string
	language_code *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Language, error)
	predicates    []predicate.Language
}

var _ ent.Mutation = (*LanguageMutation)(nil)

// languageOption allows management of the mutation configuration using functional options.
type languageOption func(*LanguageMutation)

// newLanguageMutation creates new mutation for the Language entity.
func newLanguageMutation(c config, op Op, opts ...languageOption) *LanguageMutation {
	m := &LanguageMutation{
		config:        c,
		op:            op,
		typ:           TypeLanguage,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLanguageID sets the ID field of the mutation.
func withLanguageID(id int) languageOption {
	return func(m *LanguageMutation) {
		var (
			err   error
			once  sync.Once
			value *Language
		)
		m.oldValue = func(ctx context.Context) (*Language, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Language.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLanguage sets the old Language of the mutation.
func withLanguage(node *Language) languageOption {
	return func(m *LanguageMutation) {
		m.oldValue = func(context.Context) (*Language, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LanguageMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LanguageMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Language entities.
func (m *LanguageMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LanguageMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LanguageMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Language.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetLanguageName sets the "language_name" field.
func (m *LanguageMutation) SetLanguageName(s string) {
	m.language_name = &s
}

// LanguageName returns the value of the "language_name" field in the mutation.
func (m *LanguageMutation) LanguageName() (r string, exists bool) {
	v := m.language_name
	if v == nil {
		return
	}
	return *v, true
}

// OldLanguageName returns the old "language_name" field's value of the Language entity.
// If the Language object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LanguageMutation) OldLanguageName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLanguageName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLanguageName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLanguageName: %w", err)
	}
	return oldValue.LanguageName, nil
}

// ClearLanguageName clears the value of the "language_name" field.
func (m *LanguageMutation) ClearLanguageName() {
	m.language_name = nil
	m.clearedFields[language.FieldLanguageName] = struct{}{}
}

// LanguageNameCleared returns if the "language_name" field was cleared in this mutation.
func (m *LanguageMutation) LanguageNameCleared() bool {
	_, ok := m.clearedFields[language.FieldLanguageName]
	return ok
}

// ResetLanguageName resets all changes to the "language_name" field.
func (m *LanguageMutation) ResetLanguageName() {
	m.language_name = nil
	delete(m.clearedFields, language.FieldLanguageName)
}

// SetLanguageCode sets the "language_code" field.
func (m *LanguageMutation) SetLanguageCode(s string) {
	m.language_code = &s
}

// LanguageCode returns the value of the "language_code" field in the mutation.
func (m *LanguageMutation) LanguageCode() (r string, exists bool) {
	v := m.language_code
	if v == nil {
		return
	}
	return *v, true
}

// OldLanguageCode returns the old "language_code" field's value of the Language entity.
// If the Language object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LanguageMutation) OldLanguageCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLanguageCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLanguageCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLanguageCode: %w", err)
	}
	return oldValue.LanguageCode, nil
}

// ClearLanguageCode clears the value of the "language_code" field.
func (m *LanguageMutation) ClearLanguageCode() {
	m.language_code = nil
	m.clearedFields[language.FieldLanguageCode] = struct{}{}
}

// LanguageCodeCleared returns if the "language_code" field was cleared in this mutation.
func (m *LanguageMutation) LanguageCodeCleared() bool {
	_, ok := m.clearedFields[language.FieldLanguageCode]
	return ok
}

// ResetLanguageCode resets all changes to the "language_code" field.
func (m *LanguageMutation) ResetLanguageCode() {
	m.language_code = nil
	delete(m.clearedFields, language.FieldLanguageCode)
}

// Where appends a list predicates to the LanguageMutation builder.
func (m *LanguageMutation) Where(ps ...predicate.Language) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the LanguageMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *LanguageMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Language, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *LanguageMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *LanguageMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Language).
func (m *LanguageMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LanguageMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.language_name != nil {
		fields = append(fields, language.FieldLanguageName)
	}
	if m.language_code != nil {
		fields = append(fields, language.FieldLanguageCode)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LanguageMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case language.FieldLanguageName:
		return m.LanguageName()
	case language.FieldLanguageCode:
		return m.LanguageCode()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LanguageMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case language.FieldLanguageName:
		return m.OldLanguageName(ctx)
	case language.FieldLanguageCode:
		return m.OldLanguageCode(ctx)
	}
	return nil, fmt.Errorf("unknown Language field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LanguageMutation) SetField(name string, value ent.Value) error {
	switch name {
	case language.FieldLanguageName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLanguageName(v)
		return nil
	case language.FieldLanguageCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLanguageCode(v)
		return nil
	}
	return fmt.Errorf("unknown Language field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LanguageMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LanguageMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LanguageMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Language numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LanguageMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(language.FieldLanguageName) {
		fields = append(fields, language.FieldLanguageName)
	}
	if m.FieldCleared(language.FieldLanguageCode) {
		fields = append(fields, language.FieldLanguageCode)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LanguageMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LanguageMutation) ClearField(name string) error {
	switch name {
	case language.FieldLanguageName:
		m.ClearLanguageName()
		return nil
	case language.FieldLanguageCode:
		m.ClearLanguageCode()
		return nil
	}
	return fmt.Errorf("unknown Language nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LanguageMutation) ResetField(name string) error {
	switch name {
	case language.FieldLanguageName:
		m.ResetLanguageName()
		return nil
	case language.FieldLanguageCode:
		m.ResetLanguageCode()
		return nil
	}
	return fmt.Errorf("unknown Language field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LanguageMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LanguageMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LanguageMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LanguageMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LanguageMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LanguageMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LanguageMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Language unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LanguageMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Language edge %s", name)
}

// PublisherMutation represents an operation that mutates the Publisher nodes in the graph.
type PublisherMutation struct {
	config
	op                Op
	typ               string
	id                *int
	publisher_name    *string
	publisher_address *string
	publisher_phone   *string
	publisher_email   *string
	publisher_website *string
	clearedFields     map[string]struct{}
	done              bool
	oldValue          func(context.Context) (*Publisher, error)
	predicates        []predicate.Publisher
}

var _ ent.Mutation = (*PublisherMutation)(nil)

// publisherOption allows management of the mutation configuration using functional options.
type publisherOption func(*PublisherMutation)

// newPublisherMutation creates new mutation for the Publisher entity.
func newPublisherMutation(c config, op Op, opts ...publisherOption) *PublisherMutation {
	m := &PublisherMutation{
		config:        c,
		op:            op,
		typ:           TypePublisher,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPublisherID sets the ID field of the mutation.
func withPublisherID(id int) publisherOption {
	return func(m *PublisherMutation) {
		var (
			err   error
			once  sync.Once
			value *Publisher
		)
		m.oldValue = func(ctx context.Context) (*Publisher, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Publisher.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPublisher sets the old Publisher of the mutation.
func withPublisher(node *Publisher) publisherOption {
	return func(m *PublisherMutation) {
		m.oldValue = func(context.Context) (*Publisher, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PublisherMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PublisherMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Publisher entities.
func (m *PublisherMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PublisherMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PublisherMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Publisher.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetPublisherName sets the "publisher_name" field.
func (m *PublisherMutation) SetPublisherName(s string) {
	m.publisher_name = &s
}

// PublisherName returns the value of the "publisher_name" field in the mutation.
func (m *PublisherMutation) PublisherName() (r string, exists bool) {
	v := m.publisher_name
	if v == nil {
		return
	}
	return *v, true
}

// OldPublisherName returns the old "publisher_name" field's value of the Publisher entity.
// If the Publisher object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PublisherMutation) OldPublisherName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPublisherName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPublisherName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublisherName: %w", err)
	}
	return oldValue.PublisherName, nil
}

// ResetPublisherName resets all changes to the "publisher_name" field.
func (m *PublisherMutation) ResetPublisherName() {
	m.publisher_name = nil
}

// SetPublisherAddress sets the "publisher_address" field.
func (m *PublisherMutation) SetPublisherAddress(s string) {
	m.publisher_address = &s
}

// PublisherAddress returns the value of the "publisher_address" field in the mutation.
func (m *PublisherMutation) PublisherAddress() (r string, exists bool) {
	v := m.publisher_address
	if v == nil {
		return
	}
	return *v, true
}

// OldPublisherAddress returns the old "publisher_address" field's value of the Publisher entity.
// If the Publisher object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PublisherMutation) OldPublisherAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPublisherAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPublisherAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublisherAddress: %w", err)
	}
	return oldValue.PublisherAddress, nil
}

// ClearPublisherAddress clears the value of the "publisher_address" field.
func (m *PublisherMutation) ClearPublisherAddress() {
	m.publisher_address = nil
	m.clearedFields[publisher.FieldPublisherAddress] = struct{}{}
}

// PublisherAddressCleared returns if the "publisher_address" field was cleared in this mutation.
func (m *PublisherMutation) PublisherAddressCleared() bool {
	_, ok := m.clearedFields[publisher.FieldPublisherAddress]
	return ok
}

// ResetPublisherAddress resets all changes to the "publisher_address" field.
func (m *PublisherMutation) ResetPublisherAddress() {
	m.publisher_address = nil
	delete(m.clearedFields, publisher.FieldPublisherAddress)
}

// SetPublisherPhone sets the "publisher_phone" field.
func (m *PublisherMutation) SetPublisherPhone(s string) {
	m.publisher_phone = &s
}

// PublisherPhone returns the value of the "publisher_phone" field in the mutation.
func (m *PublisherMutation) PublisherPhone() (r string, exists bool) {
	v := m.publisher_phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPublisherPhone returns the old "publisher_phone" field's value of the Publisher entity.
// If the Publisher object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PublisherMutation) OldPublisherPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPublisherPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPublisherPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublisherPhone: %w", err)
	}
	return oldValue.PublisherPhone, nil
}

// ClearPublisherPhone clears the value of the "publisher_phone" field.
func (m *PublisherMutation) ClearPublisherPhone() {
	m.publisher_phone = nil
	m.clearedFields[publisher.FieldPublisherPhone] = struct{}{}
}

// PublisherPhoneCleared returns if the "publisher_phone" field was cleared in this mutation.
func (m *PublisherMutation) PublisherPhoneCleared() bool {
	_, ok := m.clearedFields[publisher.FieldPublisherPhone]
	return ok
}

// ResetPublisherPhone resets all changes to the "publisher_phone" field.
func (m *PublisherMutation) ResetPublisherPhone() {
	m.publisher_phone = nil
	delete(m.clearedFields, publisher.FieldPublisherPhone)
}

// SetPublisherEmail sets the "publisher_email" field.
func (m *PublisherMutation) SetPublisherEmail(s string) {
	m.publisher_email = &s
}

// PublisherEmail returns the value of the "publisher_email" field in the mutation.
func (m *PublisherMutation) PublisherEmail() (r string, exists bool) {
	v := m.publisher_email
	if v == nil {
		return
	}
	return *v, true
}

// OldPublisherEmail returns the old "publisher_email" field's value of the Publisher entity.
// If the Publisher object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PublisherMutation) OldPublisherEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPublisherEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPublisherEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublisherEmail: %w", err)
	}
	return oldValue.PublisherEmail, nil
}

// ClearPublisherEmail clears the value of the "publisher_email" field.
func (m *PublisherMutation) ClearPublisherEmail() {
	m.publisher_email = nil
	m.clearedFields[publisher.FieldPublisherEmail] = struct{}{}
}

// PublisherEmailCleared returns if the "publisher_email" field was cleared in this mutation.
func (m *PublisherMutation) PublisherEmailCleared() bool {
	_, ok := m.clearedFields[publisher.FieldPublisherEmail]
	return ok
}

// ResetPublisherEmail resets all changes to the "publisher_email" field.
func (m *PublisherMutation) ResetPublisherEmail() {
	m.publisher_email = nil
	delete(m.clearedFields, publisher.FieldPublisherEmail)
}

// SetPublisherWebsite sets the "publisher_website" field.
func (m *PublisherMutation) SetPublisherWebsite(s string) {
	m.publisher_website = &s
}

// PublisherWebsite returns the value of the "publisher_website" field in the mutation.
func (m *PublisherMutation) PublisherWebsite() (r string, exists bool) {
	v := m.publisher_website
	if v == nil {
		return
	}
	return *v, true
}

// OldPublisherWebsite returns the old "publisher_website" field's value of the Publisher entity.
// If the Publisher object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PublisherMutation) OldPublisherWebsite(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPublisherWebsite is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPublisherWebsite requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublisherWebsite: %w", err)
	}
	return oldValue.PublisherWebsite, nil
}

// ClearPublisherWebsite clears the value of the "publisher_website" field.
func (m *PublisherMutation) ClearPublisherWebsite() {
	m.publisher_website = nil
	m.clearedFields[publisher.FieldPublisherWebsite] = struct{}{}
}

// PublisherWebsiteCleared returns if the "publisher_website" field was cleared in this mutation.
func (m *PublisherMutation) PublisherWebsiteCleared() bool {
	_, ok := m.clearedFields[publisher.FieldPublisherWebsite]
	return ok
}

// ResetPublisherWebsite resets all changes to the "publisher_website" field.
func (m *PublisherMutation) ResetPublisherWebsite() {
	m.publisher_website = nil
	delete(m.clearedFields, publisher.FieldPublisherWebsite)
}

// Where appends a list predicates to the PublisherMutation builder.
func (m *PublisherMutation) Where(ps ...predicate.Publisher) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PublisherMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PublisherMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Publisher, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PublisherMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PublisherMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Publisher).
func (m *PublisherMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PublisherMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.publisher_name != nil {
		fields = append(fields, publisher.FieldPublisherName)
	}
	if m.publisher_address != nil {
		fields = append(fields, publisher.FieldPublisherAddress)
	}
	if m.publisher_phone != nil {
		fields = append(fields, publisher.FieldPublisherPhone)
	}
	if m.publisher_email != nil {
		fields = append(fields, publisher.FieldPublisherEmail)
	}
	if m.publisher_website != nil {
		fields = append(fields, publisher.FieldPublisherWebsite)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PublisherMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case publisher.FieldPublisherName:
		return m.PublisherName()
	case publisher.FieldPublisherAddress:
		return m.PublisherAddress()
	case publisher.FieldPublisherPhone:
		return m.PublisherPhone()
	case publisher.FieldPublisherEmail:
		return m.PublisherEmail()
	case publisher.FieldPublisherWebsite:
		return m.PublisherWebsite()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PublisherMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case publisher.FieldPublisherName:
		return m.OldPublisherName(ctx)
	case publisher.FieldPublisherAddress:
		return m.OldPublisherAddress(ctx)
	case publisher.FieldPublisherPhone:
		return m.OldPublisherPhone(ctx)
	case publisher.FieldPublisherEmail:
		return m.OldPublisherEmail(ctx)
	case publisher.FieldPublisherWebsite:
		return m.OldPublisherWebsite(ctx)
	}
	return nil, fmt.Errorf("unknown Publisher field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PublisherMutation) SetField(name string, value ent.Value) error {
	switch name {
	case publisher.FieldPublisherName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublisherName(v)
		return nil
	case publisher.FieldPublisherAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublisherAddress(v)
		return nil
	case publisher.FieldPublisherPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublisherPhone(v)
		return nil
	case publisher.FieldPublisherEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublisherEmail(v)
		return nil
	case publisher.FieldPublisherWebsite:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublisherWebsite(v)
		return nil
	}
	return fmt.Errorf("unknown Publisher field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PublisherMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PublisherMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PublisherMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Publisher numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PublisherMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(publisher.FieldPublisherAddress) {
		fields = append(fields, publisher.FieldPublisherAddress)
	}
	if m.FieldCleared(publisher.FieldPublisherPhone) {
		fields = append(fields, publisher.FieldPublisherPhone)
	}
	if m.FieldCleared(publisher.FieldPublisherEmail) {
		fields = append(fields, publisher.FieldPublisherEmail)
	}
	if m.FieldCleared(publisher.FieldPublisherWebsite) {
		fields = append(fields, publisher.FieldPublisherWebsite)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PublisherMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PublisherMutation) ClearField(name string) error {
	switch name {
	case publisher.FieldPublisherAddress:
		m.ClearPublisherAddress()
		return nil
	case publisher.FieldPublisherPhone:
		m.ClearPublisherPhone()
		return nil
	case publisher.FieldPublisherEmail:
		m.ClearPublisherEmail()
		return nil
	case publisher.FieldPublisherWebsite:
		m.ClearPublisherWebsite()
		return nil
	}
	return fmt.Errorf("unknown Publisher nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PublisherMutation) ResetField(name string) error {
	switch name {
	case publisher.FieldPublisherName:
		m.ResetPublisherName()
		return nil
	case publisher.FieldPublisherAddress:
		m.ResetPublisherAddress()
		return nil
	case publisher.FieldPublisherPhone:
		m.ResetPublisherPhone()
		return nil
	case publisher.FieldPublisherEmail:
		m.ResetPublisherEmail()
		return nil
	case publisher.FieldPublisherWebsite:
		m.ResetPublisherWebsite()
		return nil
	}
	return fmt.Errorf("unknown Publisher field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PublisherMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PublisherMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PublisherMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PublisherMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PublisherMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PublisherMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PublisherMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Publisher unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PublisherMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Publisher edge %s", name)
}
