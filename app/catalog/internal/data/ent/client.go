// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"log"
	"reflect"

	"github.com/publication-shop/app/catalog/ent/migrate"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"github.com/publication-shop/app/catalog/ent/catalog"
	"github.com/publication-shop/app/catalog/ent/classic"
	"github.com/publication-shop/app/catalog/ent/language"
	"github.com/publication-shop/app/catalog/ent/publicationauthor"
	"github.com/publication-shop/app/catalog/ent/publicationdetail"
	"github.com/publication-shop/app/catalog/ent/publicationimg"
	"github.com/publication-shop/app/catalog/ent/publicationinfo"
	"github.com/publication-shop/app/catalog/ent/publicationorg"
	"github.com/publication-shop/app/catalog/ent/publicationstock"
	"github.com/publication-shop/app/catalog/ent/publicationxcatalog"
	"github.com/publication-shop/app/catalog/ent/publicationxclassic"
	"github.com/publication-shop/app/catalog/ent/publicationxlanguage"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// Catalog is the client for interacting with the Catalog builders.
	Catalog *CatalogClient
	// Classic is the client for interacting with the Classic builders.
	Classic *ClassicClient
	// Language is the client for interacting with the Language builders.
	Language *LanguageClient
	// PublicationAuthor is the client for interacting with the PublicationAuthor builders.
	PublicationAuthor *PublicationAuthorClient
	// PublicationDetail is the client for interacting with the PublicationDetail builders.
	PublicationDetail *PublicationDetailClient
	// PublicationImg is the client for interacting with the PublicationImg builders.
	PublicationImg *PublicationImgClient
	// PublicationInfo is the client for interacting with the PublicationInfo builders.
	PublicationInfo *PublicationInfoClient
	// PublicationOrg is the client for interacting with the PublicationOrg builders.
	PublicationOrg *PublicationOrgClient
	// PublicationStock is the client for interacting with the PublicationStock builders.
	PublicationStock *PublicationStockClient
	// PublicationXCatalog is the client for interacting with the PublicationXCatalog builders.
	PublicationXCatalog *PublicationXCatalogClient
	// PublicationXClassic is the client for interacting with the PublicationXClassic builders.
	PublicationXClassic *PublicationXClassicClient
	// PublicationXLanguage is the client for interacting with the PublicationXLanguage builders.
	PublicationXLanguage *PublicationXLanguageClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	client := &Client{config: newConfig(opts...)}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.Catalog = NewCatalogClient(c.config)
	c.Classic = NewClassicClient(c.config)
	c.Language = NewLanguageClient(c.config)
	c.PublicationAuthor = NewPublicationAuthorClient(c.config)
	c.PublicationDetail = NewPublicationDetailClient(c.config)
	c.PublicationImg = NewPublicationImgClient(c.config)
	c.PublicationInfo = NewPublicationInfoClient(c.config)
	c.PublicationOrg = NewPublicationOrgClient(c.config)
	c.PublicationStock = NewPublicationStockClient(c.config)
	c.PublicationXCatalog = NewPublicationXCatalogClient(c.config)
	c.PublicationXClassic = NewPublicationXClassicClient(c.config)
	c.PublicationXLanguage = NewPublicationXLanguageClient(c.config)
}

type (
	// config is the configuration for the client and its builder.
	config struct {
		// driver used for executing database requests.
		driver dialect.Driver
		// debug enable a debug logging.
		debug bool
		// log used for logging on debug mode.
		log func(...any)
		// hooks to execute on mutations.
		hooks *hooks
		// interceptors to execute on queries.
		inters *inters
	}
	// Option function to configure the client.
	Option func(*config)
)

// newConfig creates a new config for the client.
func newConfig(opts ...Option) config {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	return cfg
}

// options applies the options on the config object.
func (c *config) options(opts ...Option) {
	for _, opt := range opts {
		opt(c)
	}
	if c.debug {
		c.driver = dialect.Debug(c.driver, c.log)
	}
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option {
	return func(c *config) {
		c.debug = true
	}
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option {
	return func(c *config) {
		c.log = fn
	}
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option {
	return func(c *config) {
		c.driver = driver
	}
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// ErrTxStarted is returned when trying to start a new transaction from a transactional client.
var ErrTxStarted = errors.New("ent: cannot start a transaction within a transaction")

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, ErrTxStarted
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:                  ctx,
		config:               cfg,
		Catalog:              NewCatalogClient(cfg),
		Classic:              NewClassicClient(cfg),
		Language:             NewLanguageClient(cfg),
		PublicationAuthor:    NewPublicationAuthorClient(cfg),
		PublicationDetail:    NewPublicationDetailClient(cfg),
		PublicationImg:       NewPublicationImgClient(cfg),
		PublicationInfo:      NewPublicationInfoClient(cfg),
		PublicationOrg:       NewPublicationOrgClient(cfg),
		PublicationStock:     NewPublicationStockClient(cfg),
		PublicationXCatalog:  NewPublicationXCatalogClient(cfg),
		PublicationXClassic:  NewPublicationXClassicClient(cfg),
		PublicationXLanguage: NewPublicationXLanguageClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:                  ctx,
		config:               cfg,
		Catalog:              NewCatalogClient(cfg),
		Classic:              NewClassicClient(cfg),
		Language:             NewLanguageClient(cfg),
		PublicationAuthor:    NewPublicationAuthorClient(cfg),
		PublicationDetail:    NewPublicationDetailClient(cfg),
		PublicationImg:       NewPublicationImgClient(cfg),
		PublicationInfo:      NewPublicationInfoClient(cfg),
		PublicationOrg:       NewPublicationOrgClient(cfg),
		PublicationStock:     NewPublicationStockClient(cfg),
		PublicationXCatalog:  NewPublicationXCatalogClient(cfg),
		PublicationXClassic:  NewPublicationXClassicClient(cfg),
		PublicationXLanguage: NewPublicationXLanguageClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		Catalog.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	for _, n := range []interface{ Use(...Hook) }{
		c.Catalog, c.Classic, c.Language, c.PublicationAuthor, c.PublicationDetail,
		c.PublicationImg, c.PublicationInfo, c.PublicationOrg, c.PublicationStock,
		c.PublicationXCatalog, c.PublicationXClassic, c.PublicationXLanguage,
	} {
		n.Use(hooks...)
	}
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	for _, n := range []interface{ Intercept(...Interceptor) }{
		c.Catalog, c.Classic, c.Language, c.PublicationAuthor, c.PublicationDetail,
		c.PublicationImg, c.PublicationInfo, c.PublicationOrg, c.PublicationStock,
		c.PublicationXCatalog, c.PublicationXClassic, c.PublicationXLanguage,
	} {
		n.Intercept(interceptors...)
	}
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *CatalogMutation:
		return c.Catalog.mutate(ctx, m)
	case *ClassicMutation:
		return c.Classic.mutate(ctx, m)
	case *LanguageMutation:
		return c.Language.mutate(ctx, m)
	case *PublicationAuthorMutation:
		return c.PublicationAuthor.mutate(ctx, m)
	case *PublicationDetailMutation:
		return c.PublicationDetail.mutate(ctx, m)
	case *PublicationImgMutation:
		return c.PublicationImg.mutate(ctx, m)
	case *PublicationInfoMutation:
		return c.PublicationInfo.mutate(ctx, m)
	case *PublicationOrgMutation:
		return c.PublicationOrg.mutate(ctx, m)
	case *PublicationStockMutation:
		return c.PublicationStock.mutate(ctx, m)
	case *PublicationXCatalogMutation:
		return c.PublicationXCatalog.mutate(ctx, m)
	case *PublicationXClassicMutation:
		return c.PublicationXClassic.mutate(ctx, m)
	case *PublicationXLanguageMutation:
		return c.PublicationXLanguage.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("ent: unknown mutation type %T", m)
	}
}

// CatalogClient is a client for the Catalog schema.
type CatalogClient struct {
	config
}

// NewCatalogClient returns a client for the Catalog from the given config.
func NewCatalogClient(c config) *CatalogClient {
	return &CatalogClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `catalog.Hooks(f(g(h())))`.
func (c *CatalogClient) Use(hooks ...Hook) {
	c.hooks.Catalog = append(c.hooks.Catalog, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `catalog.Intercept(f(g(h())))`.
func (c *CatalogClient) Intercept(interceptors ...Interceptor) {
	c.inters.Catalog = append(c.inters.Catalog, interceptors...)
}

// Create returns a builder for creating a Catalog entity.
func (c *CatalogClient) Create() *CatalogCreate {
	mutation := newCatalogMutation(c.config, OpCreate)
	return &CatalogCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Catalog entities.
func (c *CatalogClient) CreateBulk(builders ...*CatalogCreate) *CatalogCreateBulk {
	return &CatalogCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CatalogClient) MapCreateBulk(slice any, setFunc func(*CatalogCreate, int)) *CatalogCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CatalogCreateBulk{err: fmt.Errorf("calling to CatalogClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CatalogCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CatalogCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Catalog.
func (c *CatalogClient) Update() *CatalogUpdate {
	mutation := newCatalogMutation(c.config, OpUpdate)
	return &CatalogUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CatalogClient) UpdateOne(ca *Catalog) *CatalogUpdateOne {
	mutation := newCatalogMutation(c.config, OpUpdateOne, withCatalog(ca))
	return &CatalogUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CatalogClient) UpdateOneID(id int) *CatalogUpdateOne {
	mutation := newCatalogMutation(c.config, OpUpdateOne, withCatalogID(id))
	return &CatalogUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Catalog.
func (c *CatalogClient) Delete() *CatalogDelete {
	mutation := newCatalogMutation(c.config, OpDelete)
	return &CatalogDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CatalogClient) DeleteOne(ca *Catalog) *CatalogDeleteOne {
	return c.DeleteOneID(ca.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CatalogClient) DeleteOneID(id int) *CatalogDeleteOne {
	builder := c.Delete().Where(catalog.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CatalogDeleteOne{builder}
}

// Query returns a query builder for Catalog.
func (c *CatalogClient) Query() *CatalogQuery {
	return &CatalogQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCatalog},
		inters: c.Interceptors(),
	}
}

// Get returns a Catalog entity by its id.
func (c *CatalogClient) Get(ctx context.Context, id int) (*Catalog, error) {
	return c.Query().Where(catalog.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CatalogClient) GetX(ctx context.Context, id int) *Catalog {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *CatalogClient) Hooks() []Hook {
	return c.hooks.Catalog
}

// Interceptors returns the client interceptors.
func (c *CatalogClient) Interceptors() []Interceptor {
	return c.inters.Catalog
}

func (c *CatalogClient) mutate(ctx context.Context, m *CatalogMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CatalogCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CatalogUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CatalogUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CatalogDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Catalog mutation op: %q", m.Op())
	}
}

// ClassicClient is a client for the Classic schema.
type ClassicClient struct {
	config
}

// NewClassicClient returns a client for the Classic from the given config.
func NewClassicClient(c config) *ClassicClient {
	return &ClassicClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `classic.Hooks(f(g(h())))`.
func (c *ClassicClient) Use(hooks ...Hook) {
	c.hooks.Classic = append(c.hooks.Classic, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `classic.Intercept(f(g(h())))`.
func (c *ClassicClient) Intercept(interceptors ...Interceptor) {
	c.inters.Classic = append(c.inters.Classic, interceptors...)
}

// Create returns a builder for creating a Classic entity.
func (c *ClassicClient) Create() *ClassicCreate {
	mutation := newClassicMutation(c.config, OpCreate)
	return &ClassicCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Classic entities.
func (c *ClassicClient) CreateBulk(builders ...*ClassicCreate) *ClassicCreateBulk {
	return &ClassicCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ClassicClient) MapCreateBulk(slice any, setFunc func(*ClassicCreate, int)) *ClassicCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ClassicCreateBulk{err: fmt.Errorf("calling to ClassicClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ClassicCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ClassicCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Classic.
func (c *ClassicClient) Update() *ClassicUpdate {
	mutation := newClassicMutation(c.config, OpUpdate)
	return &ClassicUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ClassicClient) UpdateOne(cl *Classic) *ClassicUpdateOne {
	mutation := newClassicMutation(c.config, OpUpdateOne, withClassic(cl))
	return &ClassicUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ClassicClient) UpdateOneID(id int) *ClassicUpdateOne {
	mutation := newClassicMutation(c.config, OpUpdateOne, withClassicID(id))
	return &ClassicUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Classic.
func (c *ClassicClient) Delete() *ClassicDelete {
	mutation := newClassicMutation(c.config, OpDelete)
	return &ClassicDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ClassicClient) DeleteOne(cl *Classic) *ClassicDeleteOne {
	return c.DeleteOneID(cl.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ClassicClient) DeleteOneID(id int) *ClassicDeleteOne {
	builder := c.Delete().Where(classic.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ClassicDeleteOne{builder}
}

// Query returns a query builder for Classic.
func (c *ClassicClient) Query() *ClassicQuery {
	return &ClassicQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeClassic},
		inters: c.Interceptors(),
	}
}

// Get returns a Classic entity by its id.
func (c *ClassicClient) Get(ctx context.Context, id int) (*Classic, error) {
	return c.Query().Where(classic.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ClassicClient) GetX(ctx context.Context, id int) *Classic {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *ClassicClient) Hooks() []Hook {
	return c.hooks.Classic
}

// Interceptors returns the client interceptors.
func (c *ClassicClient) Interceptors() []Interceptor {
	return c.inters.Classic
}

func (c *ClassicClient) mutate(ctx context.Context, m *ClassicMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ClassicCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ClassicUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ClassicUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ClassicDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Classic mutation op: %q", m.Op())
	}
}

// LanguageClient is a client for the Language schema.
type LanguageClient struct {
	config
}

// NewLanguageClient returns a client for the Language from the given config.
func NewLanguageClient(c config) *LanguageClient {
	return &LanguageClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `language.Hooks(f(g(h())))`.
func (c *LanguageClient) Use(hooks ...Hook) {
	c.hooks.Language = append(c.hooks.Language, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `language.Intercept(f(g(h())))`.
func (c *LanguageClient) Intercept(interceptors ...Interceptor) {
	c.inters.Language = append(c.inters.Language, interceptors...)
}

// Create returns a builder for creating a Language entity.
func (c *LanguageClient) Create() *LanguageCreate {
	mutation := newLanguageMutation(c.config, OpCreate)
	return &LanguageCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Language entities.
func (c *LanguageClient) CreateBulk(builders ...*LanguageCreate) *LanguageCreateBulk {
	return &LanguageCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *LanguageClient) MapCreateBulk(slice any, setFunc func(*LanguageCreate, int)) *LanguageCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &LanguageCreateBulk{err: fmt.Errorf("calling to LanguageClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*LanguageCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &LanguageCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Language.
func (c *LanguageClient) Update() *LanguageUpdate {
	mutation := newLanguageMutation(c.config, OpUpdate)
	return &LanguageUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *LanguageClient) UpdateOne(l *Language) *LanguageUpdateOne {
	mutation := newLanguageMutation(c.config, OpUpdateOne, withLanguage(l))
	return &LanguageUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *LanguageClient) UpdateOneID(id int) *LanguageUpdateOne {
	mutation := newLanguageMutation(c.config, OpUpdateOne, withLanguageID(id))
	return &LanguageUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Language.
func (c *LanguageClient) Delete() *LanguageDelete {
	mutation := newLanguageMutation(c.config, OpDelete)
	return &LanguageDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *LanguageClient) DeleteOne(l *Language) *LanguageDeleteOne {
	return c.DeleteOneID(l.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *LanguageClient) DeleteOneID(id int) *LanguageDeleteOne {
	builder := c.Delete().Where(language.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &LanguageDeleteOne{builder}
}

// Query returns a query builder for Language.
func (c *LanguageClient) Query() *LanguageQuery {
	return &LanguageQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeLanguage},
		inters: c.Interceptors(),
	}
}

// Get returns a Language entity by its id.
func (c *LanguageClient) Get(ctx context.Context, id int) (*Language, error) {
	return c.Query().Where(language.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *LanguageClient) GetX(ctx context.Context, id int) *Language {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *LanguageClient) Hooks() []Hook {
	return c.hooks.Language
}

// Interceptors returns the client interceptors.
func (c *LanguageClient) Interceptors() []Interceptor {
	return c.inters.Language
}

func (c *LanguageClient) mutate(ctx context.Context, m *LanguageMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&LanguageCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&LanguageUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&LanguageUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&LanguageDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Language mutation op: %q", m.Op())
	}
}

// PublicationAuthorClient is a client for the PublicationAuthor schema.
type PublicationAuthorClient struct {
	config
}

// NewPublicationAuthorClient returns a client for the PublicationAuthor from the given config.
func NewPublicationAuthorClient(c config) *PublicationAuthorClient {
	return &PublicationAuthorClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `publicationauthor.Hooks(f(g(h())))`.
func (c *PublicationAuthorClient) Use(hooks ...Hook) {
	c.hooks.PublicationAuthor = append(c.hooks.PublicationAuthor, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `publicationauthor.Intercept(f(g(h())))`.
func (c *PublicationAuthorClient) Intercept(interceptors ...Interceptor) {
	c.inters.PublicationAuthor = append(c.inters.PublicationAuthor, interceptors...)
}

// Create returns a builder for creating a PublicationAuthor entity.
func (c *PublicationAuthorClient) Create() *PublicationAuthorCreate {
	mutation := newPublicationAuthorMutation(c.config, OpCreate)
	return &PublicationAuthorCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of PublicationAuthor entities.
func (c *PublicationAuthorClient) CreateBulk(builders ...*PublicationAuthorCreate) *PublicationAuthorCreateBulk {
	return &PublicationAuthorCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PublicationAuthorClient) MapCreateBulk(slice any, setFunc func(*PublicationAuthorCreate, int)) *PublicationAuthorCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PublicationAuthorCreateBulk{err: fmt.Errorf("calling to PublicationAuthorClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PublicationAuthorCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PublicationAuthorCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for PublicationAuthor.
func (c *PublicationAuthorClient) Update() *PublicationAuthorUpdate {
	mutation := newPublicationAuthorMutation(c.config, OpUpdate)
	return &PublicationAuthorUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PublicationAuthorClient) UpdateOne(pa *PublicationAuthor) *PublicationAuthorUpdateOne {
	mutation := newPublicationAuthorMutation(c.config, OpUpdateOne, withPublicationAuthor(pa))
	return &PublicationAuthorUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PublicationAuthorClient) UpdateOneID(id int) *PublicationAuthorUpdateOne {
	mutation := newPublicationAuthorMutation(c.config, OpUpdateOne, withPublicationAuthorID(id))
	return &PublicationAuthorUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for PublicationAuthor.
func (c *PublicationAuthorClient) Delete() *PublicationAuthorDelete {
	mutation := newPublicationAuthorMutation(c.config, OpDelete)
	return &PublicationAuthorDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PublicationAuthorClient) DeleteOne(pa *PublicationAuthor) *PublicationAuthorDeleteOne {
	return c.DeleteOneID(pa.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PublicationAuthorClient) DeleteOneID(id int) *PublicationAuthorDeleteOne {
	builder := c.Delete().Where(publicationauthor.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PublicationAuthorDeleteOne{builder}
}

// Query returns a query builder for PublicationAuthor.
func (c *PublicationAuthorClient) Query() *PublicationAuthorQuery {
	return &PublicationAuthorQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePublicationAuthor},
		inters: c.Interceptors(),
	}
}

// Get returns a PublicationAuthor entity by its id.
func (c *PublicationAuthorClient) Get(ctx context.Context, id int) (*PublicationAuthor, error) {
	return c.Query().Where(publicationauthor.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PublicationAuthorClient) GetX(ctx context.Context, id int) *PublicationAuthor {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *PublicationAuthorClient) Hooks() []Hook {
	return c.hooks.PublicationAuthor
}

// Interceptors returns the client interceptors.
func (c *PublicationAuthorClient) Interceptors() []Interceptor {
	return c.inters.PublicationAuthor
}

func (c *PublicationAuthorClient) mutate(ctx context.Context, m *PublicationAuthorMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PublicationAuthorCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PublicationAuthorUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PublicationAuthorUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PublicationAuthorDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown PublicationAuthor mutation op: %q", m.Op())
	}
}

// PublicationDetailClient is a client for the PublicationDetail schema.
type PublicationDetailClient struct {
	config
}

// NewPublicationDetailClient returns a client for the PublicationDetail from the given config.
func NewPublicationDetailClient(c config) *PublicationDetailClient {
	return &PublicationDetailClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `publicationdetail.Hooks(f(g(h())))`.
func (c *PublicationDetailClient) Use(hooks ...Hook) {
	c.hooks.PublicationDetail = append(c.hooks.PublicationDetail, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `publicationdetail.Intercept(f(g(h())))`.
func (c *PublicationDetailClient) Intercept(interceptors ...Interceptor) {
	c.inters.PublicationDetail = append(c.inters.PublicationDetail, interceptors...)
}

// Create returns a builder for creating a PublicationDetail entity.
func (c *PublicationDetailClient) Create() *PublicationDetailCreate {
	mutation := newPublicationDetailMutation(c.config, OpCreate)
	return &PublicationDetailCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of PublicationDetail entities.
func (c *PublicationDetailClient) CreateBulk(builders ...*PublicationDetailCreate) *PublicationDetailCreateBulk {
	return &PublicationDetailCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PublicationDetailClient) MapCreateBulk(slice any, setFunc func(*PublicationDetailCreate, int)) *PublicationDetailCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PublicationDetailCreateBulk{err: fmt.Errorf("calling to PublicationDetailClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PublicationDetailCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PublicationDetailCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for PublicationDetail.
func (c *PublicationDetailClient) Update() *PublicationDetailUpdate {
	mutation := newPublicationDetailMutation(c.config, OpUpdate)
	return &PublicationDetailUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PublicationDetailClient) UpdateOne(pd *PublicationDetail) *PublicationDetailUpdateOne {
	mutation := newPublicationDetailMutation(c.config, OpUpdateOne, withPublicationDetail(pd))
	return &PublicationDetailUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PublicationDetailClient) UpdateOneID(id int) *PublicationDetailUpdateOne {
	mutation := newPublicationDetailMutation(c.config, OpUpdateOne, withPublicationDetailID(id))
	return &PublicationDetailUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for PublicationDetail.
func (c *PublicationDetailClient) Delete() *PublicationDetailDelete {
	mutation := newPublicationDetailMutation(c.config, OpDelete)
	return &PublicationDetailDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PublicationDetailClient) DeleteOne(pd *PublicationDetail) *PublicationDetailDeleteOne {
	return c.DeleteOneID(pd.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PublicationDetailClient) DeleteOneID(id int) *PublicationDetailDeleteOne {
	builder := c.Delete().Where(publicationdetail.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PublicationDetailDeleteOne{builder}
}

// Query returns a query builder for PublicationDetail.
func (c *PublicationDetailClient) Query() *PublicationDetailQuery {
	return &PublicationDetailQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePublicationDetail},
		inters: c.Interceptors(),
	}
}

// Get returns a PublicationDetail entity by its id.
func (c *PublicationDetailClient) Get(ctx context.Context, id int) (*PublicationDetail, error) {
	return c.Query().Where(publicationdetail.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PublicationDetailClient) GetX(ctx context.Context, id int) *PublicationDetail {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *PublicationDetailClient) Hooks() []Hook {
	return c.hooks.PublicationDetail
}

// Interceptors returns the client interceptors.
func (c *PublicationDetailClient) Interceptors() []Interceptor {
	return c.inters.PublicationDetail
}

func (c *PublicationDetailClient) mutate(ctx context.Context, m *PublicationDetailMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PublicationDetailCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PublicationDetailUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PublicationDetailUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PublicationDetailDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown PublicationDetail mutation op: %q", m.Op())
	}
}

// PublicationImgClient is a client for the PublicationImg schema.
type PublicationImgClient struct {
	config
}

// NewPublicationImgClient returns a client for the PublicationImg from the given config.
func NewPublicationImgClient(c config) *PublicationImgClient {
	return &PublicationImgClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `publicationimg.Hooks(f(g(h())))`.
func (c *PublicationImgClient) Use(hooks ...Hook) {
	c.hooks.PublicationImg = append(c.hooks.PublicationImg, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `publicationimg.Intercept(f(g(h())))`.
func (c *PublicationImgClient) Intercept(interceptors ...Interceptor) {
	c.inters.PublicationImg = append(c.inters.PublicationImg, interceptors...)
}

// Create returns a builder for creating a PublicationImg entity.
func (c *PublicationImgClient) Create() *PublicationImgCreate {
	mutation := newPublicationImgMutation(c.config, OpCreate)
	return &PublicationImgCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of PublicationImg entities.
func (c *PublicationImgClient) CreateBulk(builders ...*PublicationImgCreate) *PublicationImgCreateBulk {
	return &PublicationImgCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PublicationImgClient) MapCreateBulk(slice any, setFunc func(*PublicationImgCreate, int)) *PublicationImgCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PublicationImgCreateBulk{err: fmt.Errorf("calling to PublicationImgClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PublicationImgCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PublicationImgCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for PublicationImg.
func (c *PublicationImgClient) Update() *PublicationImgUpdate {
	mutation := newPublicationImgMutation(c.config, OpUpdate)
	return &PublicationImgUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PublicationImgClient) UpdateOne(pi *PublicationImg) *PublicationImgUpdateOne {
	mutation := newPublicationImgMutation(c.config, OpUpdateOne, withPublicationImg(pi))
	return &PublicationImgUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PublicationImgClient) UpdateOneID(id int) *PublicationImgUpdateOne {
	mutation := newPublicationImgMutation(c.config, OpUpdateOne, withPublicationImgID(id))
	return &PublicationImgUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for PublicationImg.
func (c *PublicationImgClient) Delete() *PublicationImgDelete {
	mutation := newPublicationImgMutation(c.config, OpDelete)
	return &PublicationImgDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PublicationImgClient) DeleteOne(pi *PublicationImg) *PublicationImgDeleteOne {
	return c.DeleteOneID(pi.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PublicationImgClient) DeleteOneID(id int) *PublicationImgDeleteOne {
	builder := c.Delete().Where(publicationimg.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PublicationImgDeleteOne{builder}
}

// Query returns a query builder for PublicationImg.
func (c *PublicationImgClient) Query() *PublicationImgQuery {
	return &PublicationImgQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePublicationImg},
		inters: c.Interceptors(),
	}
}

// Get returns a PublicationImg entity by its id.
func (c *PublicationImgClient) Get(ctx context.Context, id int) (*PublicationImg, error) {
	return c.Query().Where(publicationimg.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PublicationImgClient) GetX(ctx context.Context, id int) *PublicationImg {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *PublicationImgClient) Hooks() []Hook {
	return c.hooks.PublicationImg
}

// Interceptors returns the client interceptors.
func (c *PublicationImgClient) Interceptors() []Interceptor {
	return c.inters.PublicationImg
}

func (c *PublicationImgClient) mutate(ctx context.Context, m *PublicationImgMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PublicationImgCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PublicationImgUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PublicationImgUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PublicationImgDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown PublicationImg mutation op: %q", m.Op())
	}
}

// PublicationInfoClient is a client for the PublicationInfo schema.
type PublicationInfoClient struct {
	config
}

// NewPublicationInfoClient returns a client for the PublicationInfo from the given config.
func NewPublicationInfoClient(c config) *PublicationInfoClient {
	return &PublicationInfoClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `publicationinfo.Hooks(f(g(h())))`.
func (c *PublicationInfoClient) Use(hooks ...Hook) {
	c.hooks.PublicationInfo = append(c.hooks.PublicationInfo, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `publicationinfo.Intercept(f(g(h())))`.
func (c *PublicationInfoClient) Intercept(interceptors ...Interceptor) {
	c.inters.PublicationInfo = append(c.inters.PublicationInfo, interceptors...)
}

// Create returns a builder for creating a PublicationInfo entity.
func (c *PublicationInfoClient) Create() *PublicationInfoCreate {
	mutation := newPublicationInfoMutation(c.config, OpCreate)
	return &PublicationInfoCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of PublicationInfo entities.
func (c *PublicationInfoClient) CreateBulk(builders ...*PublicationInfoCreate) *PublicationInfoCreateBulk {
	return &PublicationInfoCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PublicationInfoClient) MapCreateBulk(slice any, setFunc func(*PublicationInfoCreate, int)) *PublicationInfoCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PublicationInfoCreateBulk{err: fmt.Errorf("calling to PublicationInfoClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PublicationInfoCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PublicationInfoCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for PublicationInfo.
func (c *PublicationInfoClient) Update() *PublicationInfoUpdate {
	mutation := newPublicationInfoMutation(c.config, OpUpdate)
	return &PublicationInfoUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PublicationInfoClient) UpdateOne(pi *PublicationInfo) *PublicationInfoUpdateOne {
	mutation := newPublicationInfoMutation(c.config, OpUpdateOne, withPublicationInfo(pi))
	return &PublicationInfoUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PublicationInfoClient) UpdateOneID(id int) *PublicationInfoUpdateOne {
	mutation := newPublicationInfoMutation(c.config, OpUpdateOne, withPublicationInfoID(id))
	return &PublicationInfoUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for PublicationInfo.
func (c *PublicationInfoClient) Delete() *PublicationInfoDelete {
	mutation := newPublicationInfoMutation(c.config, OpDelete)
	return &PublicationInfoDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PublicationInfoClient) DeleteOne(pi *PublicationInfo) *PublicationInfoDeleteOne {
	return c.DeleteOneID(pi.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PublicationInfoClient) DeleteOneID(id int) *PublicationInfoDeleteOne {
	builder := c.Delete().Where(publicationinfo.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PublicationInfoDeleteOne{builder}
}

// Query returns a query builder for PublicationInfo.
func (c *PublicationInfoClient) Query() *PublicationInfoQuery {
	return &PublicationInfoQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePublicationInfo},
		inters: c.Interceptors(),
	}
}

// Get returns a PublicationInfo entity by its id.
func (c *PublicationInfoClient) Get(ctx context.Context, id int) (*PublicationInfo, error) {
	return c.Query().Where(publicationinfo.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PublicationInfoClient) GetX(ctx context.Context, id int) *PublicationInfo {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *PublicationInfoClient) Hooks() []Hook {
	return c.hooks.PublicationInfo
}

// Interceptors returns the client interceptors.
func (c *PublicationInfoClient) Interceptors() []Interceptor {
	return c.inters.PublicationInfo
}

func (c *PublicationInfoClient) mutate(ctx context.Context, m *PublicationInfoMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PublicationInfoCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PublicationInfoUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PublicationInfoUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PublicationInfoDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown PublicationInfo mutation op: %q", m.Op())
	}
}

// PublicationOrgClient is a client for the PublicationOrg schema.
type PublicationOrgClient struct {
	config
}

// NewPublicationOrgClient returns a client for the PublicationOrg from the given config.
func NewPublicationOrgClient(c config) *PublicationOrgClient {
	return &PublicationOrgClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `publicationorg.Hooks(f(g(h())))`.
func (c *PublicationOrgClient) Use(hooks ...Hook) {
	c.hooks.PublicationOrg = append(c.hooks.PublicationOrg, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `publicationorg.Intercept(f(g(h())))`.
func (c *PublicationOrgClient) Intercept(interceptors ...Interceptor) {
	c.inters.PublicationOrg = append(c.inters.PublicationOrg, interceptors...)
}

// Create returns a builder for creating a PublicationOrg entity.
func (c *PublicationOrgClient) Create() *PublicationOrgCreate {
	mutation := newPublicationOrgMutation(c.config, OpCreate)
	return &PublicationOrgCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of PublicationOrg entities.
func (c *PublicationOrgClient) CreateBulk(builders ...*PublicationOrgCreate) *PublicationOrgCreateBulk {
	return &PublicationOrgCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PublicationOrgClient) MapCreateBulk(slice any, setFunc func(*PublicationOrgCreate, int)) *PublicationOrgCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PublicationOrgCreateBulk{err: fmt.Errorf("calling to PublicationOrgClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PublicationOrgCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PublicationOrgCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for PublicationOrg.
func (c *PublicationOrgClient) Update() *PublicationOrgUpdate {
	mutation := newPublicationOrgMutation(c.config, OpUpdate)
	return &PublicationOrgUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PublicationOrgClient) UpdateOne(po *PublicationOrg) *PublicationOrgUpdateOne {
	mutation := newPublicationOrgMutation(c.config, OpUpdateOne, withPublicationOrg(po))
	return &PublicationOrgUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PublicationOrgClient) UpdateOneID(id int) *PublicationOrgUpdateOne {
	mutation := newPublicationOrgMutation(c.config, OpUpdateOne, withPublicationOrgID(id))
	return &PublicationOrgUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for PublicationOrg.
func (c *PublicationOrgClient) Delete() *PublicationOrgDelete {
	mutation := newPublicationOrgMutation(c.config, OpDelete)
	return &PublicationOrgDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PublicationOrgClient) DeleteOne(po *PublicationOrg) *PublicationOrgDeleteOne {
	return c.DeleteOneID(po.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PublicationOrgClient) DeleteOneID(id int) *PublicationOrgDeleteOne {
	builder := c.Delete().Where(publicationorg.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PublicationOrgDeleteOne{builder}
}

// Query returns a query builder for PublicationOrg.
func (c *PublicationOrgClient) Query() *PublicationOrgQuery {
	return &PublicationOrgQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePublicationOrg},
		inters: c.Interceptors(),
	}
}

// Get returns a PublicationOrg entity by its id.
func (c *PublicationOrgClient) Get(ctx context.Context, id int) (*PublicationOrg, error) {
	return c.Query().Where(publicationorg.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PublicationOrgClient) GetX(ctx context.Context, id int) *PublicationOrg {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *PublicationOrgClient) Hooks() []Hook {
	return c.hooks.PublicationOrg
}

// Interceptors returns the client interceptors.
func (c *PublicationOrgClient) Interceptors() []Interceptor {
	return c.inters.PublicationOrg
}

func (c *PublicationOrgClient) mutate(ctx context.Context, m *PublicationOrgMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PublicationOrgCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PublicationOrgUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PublicationOrgUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PublicationOrgDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown PublicationOrg mutation op: %q", m.Op())
	}
}

// PublicationStockClient is a client for the PublicationStock schema.
type PublicationStockClient struct {
	config
}

// NewPublicationStockClient returns a client for the PublicationStock from the given config.
func NewPublicationStockClient(c config) *PublicationStockClient {
	return &PublicationStockClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `publicationstock.Hooks(f(g(h())))`.
func (c *PublicationStockClient) Use(hooks ...Hook) {
	c.hooks.PublicationStock = append(c.hooks.PublicationStock, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `publicationstock.Intercept(f(g(h())))`.
func (c *PublicationStockClient) Intercept(interceptors ...Interceptor) {
	c.inters.PublicationStock = append(c.inters.PublicationStock, interceptors...)
}

// Create returns a builder for creating a PublicationStock entity.
func (c *PublicationStockClient) Create() *PublicationStockCreate {
	mutation := newPublicationStockMutation(c.config, OpCreate)
	return &PublicationStockCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of PublicationStock entities.
func (c *PublicationStockClient) CreateBulk(builders ...*PublicationStockCreate) *PublicationStockCreateBulk {
	return &PublicationStockCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PublicationStockClient) MapCreateBulk(slice any, setFunc func(*PublicationStockCreate, int)) *PublicationStockCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PublicationStockCreateBulk{err: fmt.Errorf("calling to PublicationStockClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PublicationStockCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PublicationStockCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for PublicationStock.
func (c *PublicationStockClient) Update() *PublicationStockUpdate {
	mutation := newPublicationStockMutation(c.config, OpUpdate)
	return &PublicationStockUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PublicationStockClient) UpdateOne(ps *PublicationStock) *PublicationStockUpdateOne {
	mutation := newPublicationStockMutation(c.config, OpUpdateOne, withPublicationStock(ps))
	return &PublicationStockUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PublicationStockClient) UpdateOneID(id int) *PublicationStockUpdateOne {
	mutation := newPublicationStockMutation(c.config, OpUpdateOne, withPublicationStockID(id))
	return &PublicationStockUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for PublicationStock.
func (c *PublicationStockClient) Delete() *PublicationStockDelete {
	mutation := newPublicationStockMutation(c.config, OpDelete)
	return &PublicationStockDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PublicationStockClient) DeleteOne(ps *PublicationStock) *PublicationStockDeleteOne {
	return c.DeleteOneID(ps.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PublicationStockClient) DeleteOneID(id int) *PublicationStockDeleteOne {
	builder := c.Delete().Where(publicationstock.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PublicationStockDeleteOne{builder}
}

// Query returns a query builder for PublicationStock.
func (c *PublicationStockClient) Query() *PublicationStockQuery {
	return &PublicationStockQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePublicationStock},
		inters: c.Interceptors(),
	}
}

// Get returns a PublicationStock entity by its id.
func (c *PublicationStockClient) Get(ctx context.Context, id int) (*PublicationStock, error) {
	return c.Query().Where(publicationstock.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PublicationStockClient) GetX(ctx context.Context, id int) *PublicationStock {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *PublicationStockClient) Hooks() []Hook {
	return c.hooks.PublicationStock
}

// Interceptors returns the client interceptors.
func (c *PublicationStockClient) Interceptors() []Interceptor {
	return c.inters.PublicationStock
}

func (c *PublicationStockClient) mutate(ctx context.Context, m *PublicationStockMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PublicationStockCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PublicationStockUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PublicationStockUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PublicationStockDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown PublicationStock mutation op: %q", m.Op())
	}
}

// PublicationXCatalogClient is a client for the PublicationXCatalog schema.
type PublicationXCatalogClient struct {
	config
}

// NewPublicationXCatalogClient returns a client for the PublicationXCatalog from the given config.
func NewPublicationXCatalogClient(c config) *PublicationXCatalogClient {
	return &PublicationXCatalogClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `publicationxcatalog.Hooks(f(g(h())))`.
func (c *PublicationXCatalogClient) Use(hooks ...Hook) {
	c.hooks.PublicationXCatalog = append(c.hooks.PublicationXCatalog, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `publicationxcatalog.Intercept(f(g(h())))`.
func (c *PublicationXCatalogClient) Intercept(interceptors ...Interceptor) {
	c.inters.PublicationXCatalog = append(c.inters.PublicationXCatalog, interceptors...)
}

// Create returns a builder for creating a PublicationXCatalog entity.
func (c *PublicationXCatalogClient) Create() *PublicationXCatalogCreate {
	mutation := newPublicationXCatalogMutation(c.config, OpCreate)
	return &PublicationXCatalogCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of PublicationXCatalog entities.
func (c *PublicationXCatalogClient) CreateBulk(builders ...*PublicationXCatalogCreate) *PublicationXCatalogCreateBulk {
	return &PublicationXCatalogCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PublicationXCatalogClient) MapCreateBulk(slice any, setFunc func(*PublicationXCatalogCreate, int)) *PublicationXCatalogCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PublicationXCatalogCreateBulk{err: fmt.Errorf("calling to PublicationXCatalogClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PublicationXCatalogCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PublicationXCatalogCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for PublicationXCatalog.
func (c *PublicationXCatalogClient) Update() *PublicationXCatalogUpdate {
	mutation := newPublicationXCatalogMutation(c.config, OpUpdate)
	return &PublicationXCatalogUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PublicationXCatalogClient) UpdateOne(px *PublicationXCatalog) *PublicationXCatalogUpdateOne {
	mutation := newPublicationXCatalogMutation(c.config, OpUpdateOne, withPublicationXCatalog(px))
	return &PublicationXCatalogUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PublicationXCatalogClient) UpdateOneID(id int) *PublicationXCatalogUpdateOne {
	mutation := newPublicationXCatalogMutation(c.config, OpUpdateOne, withPublicationXCatalogID(id))
	return &PublicationXCatalogUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for PublicationXCatalog.
func (c *PublicationXCatalogClient) Delete() *PublicationXCatalogDelete {
	mutation := newPublicationXCatalogMutation(c.config, OpDelete)
	return &PublicationXCatalogDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PublicationXCatalogClient) DeleteOne(px *PublicationXCatalog) *PublicationXCatalogDeleteOne {
	return c.DeleteOneID(px.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PublicationXCatalogClient) DeleteOneID(id int) *PublicationXCatalogDeleteOne {
	builder := c.Delete().Where(publicationxcatalog.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PublicationXCatalogDeleteOne{builder}
}

// Query returns a query builder for PublicationXCatalog.
func (c *PublicationXCatalogClient) Query() *PublicationXCatalogQuery {
	return &PublicationXCatalogQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePublicationXCatalog},
		inters: c.Interceptors(),
	}
}

// Get returns a PublicationXCatalog entity by its id.
func (c *PublicationXCatalogClient) Get(ctx context.Context, id int) (*PublicationXCatalog, error) {
	return c.Query().Where(publicationxcatalog.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PublicationXCatalogClient) GetX(ctx context.Context, id int) *PublicationXCatalog {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *PublicationXCatalogClient) Hooks() []Hook {
	return c.hooks.PublicationXCatalog
}

// Interceptors returns the client interceptors.
func (c *PublicationXCatalogClient) Interceptors() []Interceptor {
	return c.inters.PublicationXCatalog
}

func (c *PublicationXCatalogClient) mutate(ctx context.Context, m *PublicationXCatalogMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PublicationXCatalogCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PublicationXCatalogUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PublicationXCatalogUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PublicationXCatalogDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown PublicationXCatalog mutation op: %q", m.Op())
	}
}

// PublicationXClassicClient is a client for the PublicationXClassic schema.
type PublicationXClassicClient struct {
	config
}

// NewPublicationXClassicClient returns a client for the PublicationXClassic from the given config.
func NewPublicationXClassicClient(c config) *PublicationXClassicClient {
	return &PublicationXClassicClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `publicationxclassic.Hooks(f(g(h())))`.
func (c *PublicationXClassicClient) Use(hooks ...Hook) {
	c.hooks.PublicationXClassic = append(c.hooks.PublicationXClassic, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `publicationxclassic.Intercept(f(g(h())))`.
func (c *PublicationXClassicClient) Intercept(interceptors ...Interceptor) {
	c.inters.PublicationXClassic = append(c.inters.PublicationXClassic, interceptors...)
}

// Create returns a builder for creating a PublicationXClassic entity.
func (c *PublicationXClassicClient) Create() *PublicationXClassicCreate {
	mutation := newPublicationXClassicMutation(c.config, OpCreate)
	return &PublicationXClassicCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of PublicationXClassic entities.
func (c *PublicationXClassicClient) CreateBulk(builders ...*PublicationXClassicCreate) *PublicationXClassicCreateBulk {
	return &PublicationXClassicCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PublicationXClassicClient) MapCreateBulk(slice any, setFunc func(*PublicationXClassicCreate, int)) *PublicationXClassicCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PublicationXClassicCreateBulk{err: fmt.Errorf("calling to PublicationXClassicClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PublicationXClassicCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PublicationXClassicCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for PublicationXClassic.
func (c *PublicationXClassicClient) Update() *PublicationXClassicUpdate {
	mutation := newPublicationXClassicMutation(c.config, OpUpdate)
	return &PublicationXClassicUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PublicationXClassicClient) UpdateOne(px *PublicationXClassic) *PublicationXClassicUpdateOne {
	mutation := newPublicationXClassicMutation(c.config, OpUpdateOne, withPublicationXClassic(px))
	return &PublicationXClassicUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PublicationXClassicClient) UpdateOneID(id int) *PublicationXClassicUpdateOne {
	mutation := newPublicationXClassicMutation(c.config, OpUpdateOne, withPublicationXClassicID(id))
	return &PublicationXClassicUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for PublicationXClassic.
func (c *PublicationXClassicClient) Delete() *PublicationXClassicDelete {
	mutation := newPublicationXClassicMutation(c.config, OpDelete)
	return &PublicationXClassicDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PublicationXClassicClient) DeleteOne(px *PublicationXClassic) *PublicationXClassicDeleteOne {
	return c.DeleteOneID(px.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PublicationXClassicClient) DeleteOneID(id int) *PublicationXClassicDeleteOne {
	builder := c.Delete().Where(publicationxclassic.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PublicationXClassicDeleteOne{builder}
}

// Query returns a query builder for PublicationXClassic.
func (c *PublicationXClassicClient) Query() *PublicationXClassicQuery {
	return &PublicationXClassicQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePublicationXClassic},
		inters: c.Interceptors(),
	}
}

// Get returns a PublicationXClassic entity by its id.
func (c *PublicationXClassicClient) Get(ctx context.Context, id int) (*PublicationXClassic, error) {
	return c.Query().Where(publicationxclassic.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PublicationXClassicClient) GetX(ctx context.Context, id int) *PublicationXClassic {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *PublicationXClassicClient) Hooks() []Hook {
	return c.hooks.PublicationXClassic
}

// Interceptors returns the client interceptors.
func (c *PublicationXClassicClient) Interceptors() []Interceptor {
	return c.inters.PublicationXClassic
}

func (c *PublicationXClassicClient) mutate(ctx context.Context, m *PublicationXClassicMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PublicationXClassicCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PublicationXClassicUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PublicationXClassicUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PublicationXClassicDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown PublicationXClassic mutation op: %q", m.Op())
	}
}

// PublicationXLanguageClient is a client for the PublicationXLanguage schema.
type PublicationXLanguageClient struct {
	config
}

// NewPublicationXLanguageClient returns a client for the PublicationXLanguage from the given config.
func NewPublicationXLanguageClient(c config) *PublicationXLanguageClient {
	return &PublicationXLanguageClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `publicationxlanguage.Hooks(f(g(h())))`.
func (c *PublicationXLanguageClient) Use(hooks ...Hook) {
	c.hooks.PublicationXLanguage = append(c.hooks.PublicationXLanguage, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `publicationxlanguage.Intercept(f(g(h())))`.
func (c *PublicationXLanguageClient) Intercept(interceptors ...Interceptor) {
	c.inters.PublicationXLanguage = append(c.inters.PublicationXLanguage, interceptors...)
}

// Create returns a builder for creating a PublicationXLanguage entity.
func (c *PublicationXLanguageClient) Create() *PublicationXLanguageCreate {
	mutation := newPublicationXLanguageMutation(c.config, OpCreate)
	return &PublicationXLanguageCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of PublicationXLanguage entities.
func (c *PublicationXLanguageClient) CreateBulk(builders ...*PublicationXLanguageCreate) *PublicationXLanguageCreateBulk {
	return &PublicationXLanguageCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PublicationXLanguageClient) MapCreateBulk(slice any, setFunc func(*PublicationXLanguageCreate, int)) *PublicationXLanguageCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PublicationXLanguageCreateBulk{err: fmt.Errorf("calling to PublicationXLanguageClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PublicationXLanguageCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PublicationXLanguageCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for PublicationXLanguage.
func (c *PublicationXLanguageClient) Update() *PublicationXLanguageUpdate {
	mutation := newPublicationXLanguageMutation(c.config, OpUpdate)
	return &PublicationXLanguageUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PublicationXLanguageClient) UpdateOne(px *PublicationXLanguage) *PublicationXLanguageUpdateOne {
	mutation := newPublicationXLanguageMutation(c.config, OpUpdateOne, withPublicationXLanguage(px))
	return &PublicationXLanguageUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PublicationXLanguageClient) UpdateOneID(id int) *PublicationXLanguageUpdateOne {
	mutation := newPublicationXLanguageMutation(c.config, OpUpdateOne, withPublicationXLanguageID(id))
	return &PublicationXLanguageUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for PublicationXLanguage.
func (c *PublicationXLanguageClient) Delete() *PublicationXLanguageDelete {
	mutation := newPublicationXLanguageMutation(c.config, OpDelete)
	return &PublicationXLanguageDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PublicationXLanguageClient) DeleteOne(px *PublicationXLanguage) *PublicationXLanguageDeleteOne {
	return c.DeleteOneID(px.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PublicationXLanguageClient) DeleteOneID(id int) *PublicationXLanguageDeleteOne {
	builder := c.Delete().Where(publicationxlanguage.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PublicationXLanguageDeleteOne{builder}
}

// Query returns a query builder for PublicationXLanguage.
func (c *PublicationXLanguageClient) Query() *PublicationXLanguageQuery {
	return &PublicationXLanguageQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePublicationXLanguage},
		inters: c.Interceptors(),
	}
}

// Get returns a PublicationXLanguage entity by its id.
func (c *PublicationXLanguageClient) Get(ctx context.Context, id int) (*PublicationXLanguage, error) {
	return c.Query().Where(publicationxlanguage.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PublicationXLanguageClient) GetX(ctx context.Context, id int) *PublicationXLanguage {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *PublicationXLanguageClient) Hooks() []Hook {
	return c.hooks.PublicationXLanguage
}

// Interceptors returns the client interceptors.
func (c *PublicationXLanguageClient) Interceptors() []Interceptor {
	return c.inters.PublicationXLanguage
}

func (c *PublicationXLanguageClient) mutate(ctx context.Context, m *PublicationXLanguageMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PublicationXLanguageCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PublicationXLanguageUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PublicationXLanguageUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PublicationXLanguageDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown PublicationXLanguage mutation op: %q", m.Op())
	}
}

// hooks and interceptors per client, for fast access.
type (
	hooks struct {
		Catalog, Classic, Language, PublicationAuthor, PublicationDetail,
		PublicationImg, PublicationInfo, PublicationOrg, PublicationStock,
		PublicationXCatalog, PublicationXClassic, PublicationXLanguage []ent.Hook
	}
	inters struct {
		Catalog, Classic, Language, PublicationAuthor, PublicationDetail,
		PublicationImg, PublicationInfo, PublicationOrg, PublicationStock,
		PublicationXCatalog, PublicationXClassic,
		PublicationXLanguage []ent.Interceptor
	}
)
