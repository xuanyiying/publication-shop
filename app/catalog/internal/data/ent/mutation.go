// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/publication-shop/app/catalog/ent/catalog"
	"github.com/publication-shop/app/catalog/ent/classic"
	"github.com/publication-shop/app/catalog/ent/language"
	"github.com/publication-shop/app/catalog/ent/predicate"
	"github.com/publication-shop/app/catalog/ent/publicationauthor"
	"github.com/publication-shop/app/catalog/ent/publicationdetail"
	"github.com/publication-shop/app/catalog/ent/publicationimg"
	"github.com/publication-shop/app/catalog/ent/publicationinfo"
	"github.com/publication-shop/app/catalog/ent/publicationorg"
	"github.com/publication-shop/app/catalog/ent/publicationstock"
	"github.com/publication-shop/app/catalog/ent/publicationxcatalog"
	"github.com/publication-shop/app/catalog/ent/publicationxclassic"
	"github.com/publication-shop/app/catalog/ent/publicationxlanguage"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeCatalog              = "Catalog"
	TypeClassic              = "Classic"
	TypeLanguage             = "Language"
	TypePublicationAuthor    = "PublicationAuthor"
	TypePublicationDetail    = "PublicationDetail"
	TypePublicationImg       = "PublicationImg"
	TypePublicationInfo      = "PublicationInfo"
	TypePublicationOrg       = "PublicationOrg"
	TypePublicationStock     = "PublicationStock"
	TypePublicationXCatalog  = "PublicationXCatalog"
	TypePublicationXClassic  = "PublicationXClassic"
	TypePublicationXLanguage = "PublicationXLanguage"
)

// CatalogMutation represents an operation that mutates the Catalog nodes in the graph.
type CatalogMutation struct {
	config
	op                Op
	typ               string
	id                *int
	catalog_code      *string
	catalog_name      *string
	parent_catalog_id *string
	clearedFields     map[string]struct{}
	done              bool
	oldValue          func(context.Context) (*Catalog, error)
	predicates        []predicate.Catalog
}

var _ ent.Mutation = (*CatalogMutation)(nil)

// catalogOption allows management of the mutation configuration using functional options.
type catalogOption func(*CatalogMutation)

// newCatalogMutation creates new mutation for the Catalog entity.
func newCatalogMutation(c config, op Op, opts ...catalogOption) *CatalogMutation {
	m := &CatalogMutation{
		config:        c,
		op:            op,
		typ:           TypeCatalog,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCatalogID sets the ID field of the mutation.
func withCatalogID(id int) catalogOption {
	return func(m *CatalogMutation) {
		var (
			err   error
			once  sync.Once
			value *Catalog
		)
		m.oldValue = func(ctx context.Context) (*Catalog, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Catalog.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCatalog sets the old Catalog of the mutation.
func withCatalog(node *Catalog) catalogOption {
	return func(m *CatalogMutation) {
		m.oldValue = func(context.Context) (*Catalog, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CatalogMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CatalogMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Catalog entities.
func (m *CatalogMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CatalogMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CatalogMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Catalog.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCatalogCode sets the "catalog_code" field.
func (m *CatalogMutation) SetCatalogCode(s string) {
	m.catalog_code = &s
}

// CatalogCode returns the value of the "catalog_code" field in the mutation.
func (m *CatalogMutation) CatalogCode() (r string, exists bool) {
	v := m.catalog_code
	if v == nil {
		return
	}
	return *v, true
}

// OldCatalogCode returns the old "catalog_code" field's value of the Catalog entity.
// If the Catalog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CatalogMutation) OldCatalogCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCatalogCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCatalogCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCatalogCode: %w", err)
	}
	return oldValue.CatalogCode, nil
}

// ResetCatalogCode resets all changes to the "catalog_code" field.
func (m *CatalogMutation) ResetCatalogCode() {
	m.catalog_code = nil
}

// SetCatalogName sets the "catalog_name" field.
func (m *CatalogMutation) SetCatalogName(s string) {
	m.catalog_name = &s
}

// CatalogName returns the value of the "catalog_name" field in the mutation.
func (m *CatalogMutation) CatalogName() (r string, exists bool) {
	v := m.catalog_name
	if v == nil {
		return
	}
	return *v, true
}

// OldCatalogName returns the old "catalog_name" field's value of the Catalog entity.
// If the Catalog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CatalogMutation) OldCatalogName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCatalogName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCatalogName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCatalogName: %w", err)
	}
	return oldValue.CatalogName, nil
}

// ClearCatalogName clears the value of the "catalog_name" field.
func (m *CatalogMutation) ClearCatalogName() {
	m.catalog_name = nil
	m.clearedFields[catalog.FieldCatalogName] = struct{}{}
}

// CatalogNameCleared returns if the "catalog_name" field was cleared in this mutation.
func (m *CatalogMutation) CatalogNameCleared() bool {
	_, ok := m.clearedFields[catalog.FieldCatalogName]
	return ok
}

// ResetCatalogName resets all changes to the "catalog_name" field.
func (m *CatalogMutation) ResetCatalogName() {
	m.catalog_name = nil
	delete(m.clearedFields, catalog.FieldCatalogName)
}

// SetParentCatalogID sets the "parent_catalog_id" field.
func (m *CatalogMutation) SetParentCatalogID(s string) {
	m.parent_catalog_id = &s
}

// ParentCatalogID returns the value of the "parent_catalog_id" field in the mutation.
func (m *CatalogMutation) ParentCatalogID() (r string, exists bool) {
	v := m.parent_catalog_id
	if v == nil {
		return
	}
	return *v, true
}

// OldParentCatalogID returns the old "parent_catalog_id" field's value of the Catalog entity.
// If the Catalog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CatalogMutation) OldParentCatalogID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentCatalogID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentCatalogID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentCatalogID: %w", err)
	}
	return oldValue.ParentCatalogID, nil
}

// ResetParentCatalogID resets all changes to the "parent_catalog_id" field.
func (m *CatalogMutation) ResetParentCatalogID() {
	m.parent_catalog_id = nil
}

// Where appends a list predicates to the CatalogMutation builder.
func (m *CatalogMutation) Where(ps ...predicate.Catalog) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CatalogMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CatalogMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Catalog, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CatalogMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CatalogMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Catalog).
func (m *CatalogMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CatalogMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.catalog_code != nil {
		fields = append(fields, catalog.FieldCatalogCode)
	}
	if m.catalog_name != nil {
		fields = append(fields, catalog.FieldCatalogName)
	}
	if m.parent_catalog_id != nil {
		fields = append(fields, catalog.FieldParentCatalogID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CatalogMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case catalog.FieldCatalogCode:
		return m.CatalogCode()
	case catalog.FieldCatalogName:
		return m.CatalogName()
	case catalog.FieldParentCatalogID:
		return m.ParentCatalogID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CatalogMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case catalog.FieldCatalogCode:
		return m.OldCatalogCode(ctx)
	case catalog.FieldCatalogName:
		return m.OldCatalogName(ctx)
	case catalog.FieldParentCatalogID:
		return m.OldParentCatalogID(ctx)
	}
	return nil, fmt.Errorf("unknown Catalog field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CatalogMutation) SetField(name string, value ent.Value) error {
	switch name {
	case catalog.FieldCatalogCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCatalogCode(v)
		return nil
	case catalog.FieldCatalogName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCatalogName(v)
		return nil
	case catalog.FieldParentCatalogID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentCatalogID(v)
		return nil
	}
	return fmt.Errorf("unknown Catalog field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CatalogMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CatalogMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CatalogMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Catalog numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CatalogMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(catalog.FieldCatalogName) {
		fields = append(fields, catalog.FieldCatalogName)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CatalogMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CatalogMutation) ClearField(name string) error {
	switch name {
	case catalog.FieldCatalogName:
		m.ClearCatalogName()
		return nil
	}
	return fmt.Errorf("unknown Catalog nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CatalogMutation) ResetField(name string) error {
	switch name {
	case catalog.FieldCatalogCode:
		m.ResetCatalogCode()
		return nil
	case catalog.FieldCatalogName:
		m.ResetCatalogName()
		return nil
	case catalog.FieldParentCatalogID:
		m.ResetParentCatalogID()
		return nil
	}
	return fmt.Errorf("unknown Catalog field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CatalogMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CatalogMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CatalogMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CatalogMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CatalogMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CatalogMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CatalogMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Catalog unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CatalogMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Catalog edge %s", name)
}

// ClassicMutation represents an operation that mutates the Classic nodes in the graph.
type ClassicMutation struct {
	config
	op            Op
	typ           string
	id            *int
	classic_name  *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Classic, error)
	predicates    []predicate.Classic
}

var _ ent.Mutation = (*ClassicMutation)(nil)

// classicOption allows management of the mutation configuration using functional options.
type classicOption func(*ClassicMutation)

// newClassicMutation creates new mutation for the Classic entity.
func newClassicMutation(c config, op Op, opts ...classicOption) *ClassicMutation {
	m := &ClassicMutation{
		config:        c,
		op:            op,
		typ:           TypeClassic,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withClassicID sets the ID field of the mutation.
func withClassicID(id int) classicOption {
	return func(m *ClassicMutation) {
		var (
			err   error
			once  sync.Once
			value *Classic
		)
		m.oldValue = func(ctx context.Context) (*Classic, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Classic.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withClassic sets the old Classic of the mutation.
func withClassic(node *Classic) classicOption {
	return func(m *ClassicMutation) {
		m.oldValue = func(context.Context) (*Classic, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ClassicMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ClassicMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Classic entities.
func (m *ClassicMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ClassicMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ClassicMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Classic.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetClassicName sets the "classic_name" field.
func (m *ClassicMutation) SetClassicName(s string) {
	m.classic_name = &s
}

// ClassicName returns the value of the "classic_name" field in the mutation.
func (m *ClassicMutation) ClassicName() (r string, exists bool) {
	v := m.classic_name
	if v == nil {
		return
	}
	return *v, true
}

// OldClassicName returns the old "classic_name" field's value of the Classic entity.
// If the Classic object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClassicMutation) OldClassicName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClassicName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClassicName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClassicName: %w", err)
	}
	return oldValue.ClassicName, nil
}

// ClearClassicName clears the value of the "classic_name" field.
func (m *ClassicMutation) ClearClassicName() {
	m.classic_name = nil
	m.clearedFields[classic.FieldClassicName] = struct{}{}
}

// ClassicNameCleared returns if the "classic_name" field was cleared in this mutation.
func (m *ClassicMutation) ClassicNameCleared() bool {
	_, ok := m.clearedFields[classic.FieldClassicName]
	return ok
}

// ResetClassicName resets all changes to the "classic_name" field.
func (m *ClassicMutation) ResetClassicName() {
	m.classic_name = nil
	delete(m.clearedFields, classic.FieldClassicName)
}

// Where appends a list predicates to the ClassicMutation builder.
func (m *ClassicMutation) Where(ps ...predicate.Classic) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ClassicMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ClassicMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Classic, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ClassicMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ClassicMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Classic).
func (m *ClassicMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ClassicMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.classic_name != nil {
		fields = append(fields, classic.FieldClassicName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ClassicMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case classic.FieldClassicName:
		return m.ClassicName()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ClassicMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case classic.FieldClassicName:
		return m.OldClassicName(ctx)
	}
	return nil, fmt.Errorf("unknown Classic field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ClassicMutation) SetField(name string, value ent.Value) error {
	switch name {
	case classic.FieldClassicName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClassicName(v)
		return nil
	}
	return fmt.Errorf("unknown Classic field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ClassicMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ClassicMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ClassicMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Classic numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ClassicMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(classic.FieldClassicName) {
		fields = append(fields, classic.FieldClassicName)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ClassicMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ClassicMutation) ClearField(name string) error {
	switch name {
	case classic.FieldClassicName:
		m.ClearClassicName()
		return nil
	}
	return fmt.Errorf("unknown Classic nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ClassicMutation) ResetField(name string) error {
	switch name {
	case classic.FieldClassicName:
		m.ResetClassicName()
		return nil
	}
	return fmt.Errorf("unknown Classic field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ClassicMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ClassicMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ClassicMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ClassicMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ClassicMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ClassicMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ClassicMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Classic unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ClassicMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Classic edge %s", name)
}

// LanguageMutation represents an operation that mutates the Language nodes in the graph.
type LanguageMutation struct {
	config
	op            Op
	typ           string
	id            *int
	language_name *string
	language_code *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Language, error)
	predicates    []predicate.Language
}

var _ ent.Mutation = (*LanguageMutation)(nil)

// languageOption allows management of the mutation configuration using functional options.
type languageOption func(*LanguageMutation)

// newLanguageMutation creates new mutation for the Language entity.
func newLanguageMutation(c config, op Op, opts ...languageOption) *LanguageMutation {
	m := &LanguageMutation{
		config:        c,
		op:            op,
		typ:           TypeLanguage,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLanguageID sets the ID field of the mutation.
func withLanguageID(id int) languageOption {
	return func(m *LanguageMutation) {
		var (
			err   error
			once  sync.Once
			value *Language
		)
		m.oldValue = func(ctx context.Context) (*Language, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Language.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLanguage sets the old Language of the mutation.
func withLanguage(node *Language) languageOption {
	return func(m *LanguageMutation) {
		m.oldValue = func(context.Context) (*Language, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LanguageMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LanguageMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Language entities.
func (m *LanguageMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LanguageMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LanguageMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Language.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetLanguageName sets the "language_name" field.
func (m *LanguageMutation) SetLanguageName(s string) {
	m.language_name = &s
}

// LanguageName returns the value of the "language_name" field in the mutation.
func (m *LanguageMutation) LanguageName() (r string, exists bool) {
	v := m.language_name
	if v == nil {
		return
	}
	return *v, true
}

// OldLanguageName returns the old "language_name" field's value of the Language entity.
// If the Language object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LanguageMutation) OldLanguageName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLanguageName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLanguageName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLanguageName: %w", err)
	}
	return oldValue.LanguageName, nil
}

// ClearLanguageName clears the value of the "language_name" field.
func (m *LanguageMutation) ClearLanguageName() {
	m.language_name = nil
	m.clearedFields[language.FieldLanguageName] = struct{}{}
}

// LanguageNameCleared returns if the "language_name" field was cleared in this mutation.
func (m *LanguageMutation) LanguageNameCleared() bool {
	_, ok := m.clearedFields[language.FieldLanguageName]
	return ok
}

// ResetLanguageName resets all changes to the "language_name" field.
func (m *LanguageMutation) ResetLanguageName() {
	m.language_name = nil
	delete(m.clearedFields, language.FieldLanguageName)
}

// SetLanguageCode sets the "language_code" field.
func (m *LanguageMutation) SetLanguageCode(s string) {
	m.language_code = &s
}

// LanguageCode returns the value of the "language_code" field in the mutation.
func (m *LanguageMutation) LanguageCode() (r string, exists bool) {
	v := m.language_code
	if v == nil {
		return
	}
	return *v, true
}

// OldLanguageCode returns the old "language_code" field's value of the Language entity.
// If the Language object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LanguageMutation) OldLanguageCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLanguageCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLanguageCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLanguageCode: %w", err)
	}
	return oldValue.LanguageCode, nil
}

// ClearLanguageCode clears the value of the "language_code" field.
func (m *LanguageMutation) ClearLanguageCode() {
	m.language_code = nil
	m.clearedFields[language.FieldLanguageCode] = struct{}{}
}

// LanguageCodeCleared returns if the "language_code" field was cleared in this mutation.
func (m *LanguageMutation) LanguageCodeCleared() bool {
	_, ok := m.clearedFields[language.FieldLanguageCode]
	return ok
}

// ResetLanguageCode resets all changes to the "language_code" field.
func (m *LanguageMutation) ResetLanguageCode() {
	m.language_code = nil
	delete(m.clearedFields, language.FieldLanguageCode)
}

// Where appends a list predicates to the LanguageMutation builder.
func (m *LanguageMutation) Where(ps ...predicate.Language) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the LanguageMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *LanguageMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Language, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *LanguageMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *LanguageMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Language).
func (m *LanguageMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LanguageMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.language_name != nil {
		fields = append(fields, language.FieldLanguageName)
	}
	if m.language_code != nil {
		fields = append(fields, language.FieldLanguageCode)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LanguageMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case language.FieldLanguageName:
		return m.LanguageName()
	case language.FieldLanguageCode:
		return m.LanguageCode()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LanguageMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case language.FieldLanguageName:
		return m.OldLanguageName(ctx)
	case language.FieldLanguageCode:
		return m.OldLanguageCode(ctx)
	}
	return nil, fmt.Errorf("unknown Language field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LanguageMutation) SetField(name string, value ent.Value) error {
	switch name {
	case language.FieldLanguageName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLanguageName(v)
		return nil
	case language.FieldLanguageCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLanguageCode(v)
		return nil
	}
	return fmt.Errorf("unknown Language field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LanguageMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LanguageMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LanguageMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Language numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LanguageMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(language.FieldLanguageName) {
		fields = append(fields, language.FieldLanguageName)
	}
	if m.FieldCleared(language.FieldLanguageCode) {
		fields = append(fields, language.FieldLanguageCode)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LanguageMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LanguageMutation) ClearField(name string) error {
	switch name {
	case language.FieldLanguageName:
		m.ClearLanguageName()
		return nil
	case language.FieldLanguageCode:
		m.ClearLanguageCode()
		return nil
	}
	return fmt.Errorf("unknown Language nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LanguageMutation) ResetField(name string) error {
	switch name {
	case language.FieldLanguageName:
		m.ResetLanguageName()
		return nil
	case language.FieldLanguageCode:
		m.ResetLanguageCode()
		return nil
	}
	return fmt.Errorf("unknown Language field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LanguageMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LanguageMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LanguageMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LanguageMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LanguageMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LanguageMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LanguageMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Language unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LanguageMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Language edge %s", name)
}

// PublicationAuthorMutation represents an operation that mutates the PublicationAuthor nodes in the graph.
type PublicationAuthorMutation struct {
	config
	op                Op
	typ               string
	id                *int
	isbn              *string
	publication_id    *int
	addpublication_id *int
	author            *string
	author_about      *string
	clearedFields     map[string]struct{}
	done              bool
	oldValue          func(context.Context) (*PublicationAuthor, error)
	predicates        []predicate.PublicationAuthor
}

var _ ent.Mutation = (*PublicationAuthorMutation)(nil)

// publicationauthorOption allows management of the mutation configuration using functional options.
type publicationauthorOption func(*PublicationAuthorMutation)

// newPublicationAuthorMutation creates new mutation for the PublicationAuthor entity.
func newPublicationAuthorMutation(c config, op Op, opts ...publicationauthorOption) *PublicationAuthorMutation {
	m := &PublicationAuthorMutation{
		config:        c,
		op:            op,
		typ:           TypePublicationAuthor,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPublicationAuthorID sets the ID field of the mutation.
func withPublicationAuthorID(id int) publicationauthorOption {
	return func(m *PublicationAuthorMutation) {
		var (
			err   error
			once  sync.Once
			value *PublicationAuthor
		)
		m.oldValue = func(ctx context.Context) (*PublicationAuthor, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PublicationAuthor.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPublicationAuthor sets the old PublicationAuthor of the mutation.
func withPublicationAuthor(node *PublicationAuthor) publicationauthorOption {
	return func(m *PublicationAuthorMutation) {
		m.oldValue = func(context.Context) (*PublicationAuthor, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PublicationAuthorMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PublicationAuthorMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PublicationAuthor entities.
func (m *PublicationAuthorMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PublicationAuthorMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PublicationAuthorMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PublicationAuthor.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetIsbn sets the "isbn" field.
func (m *PublicationAuthorMutation) SetIsbn(s string) {
	m.isbn = &s
}

// Isbn returns the value of the "isbn" field in the mutation.
func (m *PublicationAuthorMutation) Isbn() (r string, exists bool) {
	v := m.isbn
	if v == nil {
		return
	}
	return *v, true
}

// OldIsbn returns the old "isbn" field's value of the PublicationAuthor entity.
// If the PublicationAuthor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PublicationAuthorMutation) OldIsbn(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsbn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsbn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsbn: %w", err)
	}
	return oldValue.Isbn, nil
}

// ResetIsbn resets all changes to the "isbn" field.
func (m *PublicationAuthorMutation) ResetIsbn() {
	m.isbn = nil
}

// SetPublicationID sets the "publication_id" field.
func (m *PublicationAuthorMutation) SetPublicationID(i int) {
	m.publication_id = &i
	m.addpublication_id = nil
}

// PublicationID returns the value of the "publication_id" field in the mutation.
func (m *PublicationAuthorMutation) PublicationID() (r int, exists bool) {
	v := m.publication_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPublicationID returns the old "publication_id" field's value of the PublicationAuthor entity.
// If the PublicationAuthor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PublicationAuthorMutation) OldPublicationID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPublicationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPublicationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublicationID: %w", err)
	}
	return oldValue.PublicationID, nil
}

// AddPublicationID adds i to the "publication_id" field.
func (m *PublicationAuthorMutation) AddPublicationID(i int) {
	if m.addpublication_id != nil {
		*m.addpublication_id += i
	} else {
		m.addpublication_id = &i
	}
}

// AddedPublicationID returns the value that was added to the "publication_id" field in this mutation.
func (m *PublicationAuthorMutation) AddedPublicationID() (r int, exists bool) {
	v := m.addpublication_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearPublicationID clears the value of the "publication_id" field.
func (m *PublicationAuthorMutation) ClearPublicationID() {
	m.publication_id = nil
	m.addpublication_id = nil
	m.clearedFields[publicationauthor.FieldPublicationID] = struct{}{}
}

// PublicationIDCleared returns if the "publication_id" field was cleared in this mutation.
func (m *PublicationAuthorMutation) PublicationIDCleared() bool {
	_, ok := m.clearedFields[publicationauthor.FieldPublicationID]
	return ok
}

// ResetPublicationID resets all changes to the "publication_id" field.
func (m *PublicationAuthorMutation) ResetPublicationID() {
	m.publication_id = nil
	m.addpublication_id = nil
	delete(m.clearedFields, publicationauthor.FieldPublicationID)
}

// SetAuthor sets the "author" field.
func (m *PublicationAuthorMutation) SetAuthor(s string) {
	m.author = &s
}

// Author returns the value of the "author" field in the mutation.
func (m *PublicationAuthorMutation) Author() (r string, exists bool) {
	v := m.author
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthor returns the old "author" field's value of the PublicationAuthor entity.
// If the PublicationAuthor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PublicationAuthorMutation) OldAuthor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthor: %w", err)
	}
	return oldValue.Author, nil
}

// ClearAuthor clears the value of the "author" field.
func (m *PublicationAuthorMutation) ClearAuthor() {
	m.author = nil
	m.clearedFields[publicationauthor.FieldAuthor] = struct{}{}
}

// AuthorCleared returns if the "author" field was cleared in this mutation.
func (m *PublicationAuthorMutation) AuthorCleared() bool {
	_, ok := m.clearedFields[publicationauthor.FieldAuthor]
	return ok
}

// ResetAuthor resets all changes to the "author" field.
func (m *PublicationAuthorMutation) ResetAuthor() {
	m.author = nil
	delete(m.clearedFields, publicationauthor.FieldAuthor)
}

// SetAuthorAbout sets the "author_about" field.
func (m *PublicationAuthorMutation) SetAuthorAbout(s string) {
	m.author_about = &s
}

// AuthorAbout returns the value of the "author_about" field in the mutation.
func (m *PublicationAuthorMutation) AuthorAbout() (r string, exists bool) {
	v := m.author_about
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthorAbout returns the old "author_about" field's value of the PublicationAuthor entity.
// If the PublicationAuthor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PublicationAuthorMutation) OldAuthorAbout(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthorAbout is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthorAbout requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthorAbout: %w", err)
	}
	return oldValue.AuthorAbout, nil
}

// ClearAuthorAbout clears the value of the "author_about" field.
func (m *PublicationAuthorMutation) ClearAuthorAbout() {
	m.author_about = nil
	m.clearedFields[publicationauthor.FieldAuthorAbout] = struct{}{}
}

// AuthorAboutCleared returns if the "author_about" field was cleared in this mutation.
func (m *PublicationAuthorMutation) AuthorAboutCleared() bool {
	_, ok := m.clearedFields[publicationauthor.FieldAuthorAbout]
	return ok
}

// ResetAuthorAbout resets all changes to the "author_about" field.
func (m *PublicationAuthorMutation) ResetAuthorAbout() {
	m.author_about = nil
	delete(m.clearedFields, publicationauthor.FieldAuthorAbout)
}

// Where appends a list predicates to the PublicationAuthorMutation builder.
func (m *PublicationAuthorMutation) Where(ps ...predicate.PublicationAuthor) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PublicationAuthorMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PublicationAuthorMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PublicationAuthor, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PublicationAuthorMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PublicationAuthorMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PublicationAuthor).
func (m *PublicationAuthorMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PublicationAuthorMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.isbn != nil {
		fields = append(fields, publicationauthor.FieldIsbn)
	}
	if m.publication_id != nil {
		fields = append(fields, publicationauthor.FieldPublicationID)
	}
	if m.author != nil {
		fields = append(fields, publicationauthor.FieldAuthor)
	}
	if m.author_about != nil {
		fields = append(fields, publicationauthor.FieldAuthorAbout)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PublicationAuthorMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case publicationauthor.FieldIsbn:
		return m.Isbn()
	case publicationauthor.FieldPublicationID:
		return m.PublicationID()
	case publicationauthor.FieldAuthor:
		return m.Author()
	case publicationauthor.FieldAuthorAbout:
		return m.AuthorAbout()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PublicationAuthorMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case publicationauthor.FieldIsbn:
		return m.OldIsbn(ctx)
	case publicationauthor.FieldPublicationID:
		return m.OldPublicationID(ctx)
	case publicationauthor.FieldAuthor:
		return m.OldAuthor(ctx)
	case publicationauthor.FieldAuthorAbout:
		return m.OldAuthorAbout(ctx)
	}
	return nil, fmt.Errorf("unknown PublicationAuthor field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PublicationAuthorMutation) SetField(name string, value ent.Value) error {
	switch name {
	case publicationauthor.FieldIsbn:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsbn(v)
		return nil
	case publicationauthor.FieldPublicationID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublicationID(v)
		return nil
	case publicationauthor.FieldAuthor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthor(v)
		return nil
	case publicationauthor.FieldAuthorAbout:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthorAbout(v)
		return nil
	}
	return fmt.Errorf("unknown PublicationAuthor field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PublicationAuthorMutation) AddedFields() []string {
	var fields []string
	if m.addpublication_id != nil {
		fields = append(fields, publicationauthor.FieldPublicationID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PublicationAuthorMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case publicationauthor.FieldPublicationID:
		return m.AddedPublicationID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PublicationAuthorMutation) AddField(name string, value ent.Value) error {
	switch name {
	case publicationauthor.FieldPublicationID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPublicationID(v)
		return nil
	}
	return fmt.Errorf("unknown PublicationAuthor numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PublicationAuthorMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(publicationauthor.FieldPublicationID) {
		fields = append(fields, publicationauthor.FieldPublicationID)
	}
	if m.FieldCleared(publicationauthor.FieldAuthor) {
		fields = append(fields, publicationauthor.FieldAuthor)
	}
	if m.FieldCleared(publicationauthor.FieldAuthorAbout) {
		fields = append(fields, publicationauthor.FieldAuthorAbout)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PublicationAuthorMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PublicationAuthorMutation) ClearField(name string) error {
	switch name {
	case publicationauthor.FieldPublicationID:
		m.ClearPublicationID()
		return nil
	case publicationauthor.FieldAuthor:
		m.ClearAuthor()
		return nil
	case publicationauthor.FieldAuthorAbout:
		m.ClearAuthorAbout()
		return nil
	}
	return fmt.Errorf("unknown PublicationAuthor nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PublicationAuthorMutation) ResetField(name string) error {
	switch name {
	case publicationauthor.FieldIsbn:
		m.ResetIsbn()
		return nil
	case publicationauthor.FieldPublicationID:
		m.ResetPublicationID()
		return nil
	case publicationauthor.FieldAuthor:
		m.ResetAuthor()
		return nil
	case publicationauthor.FieldAuthorAbout:
		m.ResetAuthorAbout()
		return nil
	}
	return fmt.Errorf("unknown PublicationAuthor field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PublicationAuthorMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PublicationAuthorMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PublicationAuthorMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PublicationAuthorMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PublicationAuthorMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PublicationAuthorMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PublicationAuthorMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown PublicationAuthor unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PublicationAuthorMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown PublicationAuthor edge %s", name)
}

// PublicationDetailMutation represents an operation that mutates the PublicationDetail nodes in the graph.
type PublicationDetailMutation struct {
	config
	op                Op
	typ               string
	id                *int
	isbn              *string
	detail_html       *string
	detail_img        *string
	publication_id    *int
	addpublication_id *int
	clearedFields     map[string]struct{}
	done              bool
	oldValue          func(context.Context) (*PublicationDetail, error)
	predicates        []predicate.PublicationDetail
}

var _ ent.Mutation = (*PublicationDetailMutation)(nil)

// publicationdetailOption allows management of the mutation configuration using functional options.
type publicationdetailOption func(*PublicationDetailMutation)

// newPublicationDetailMutation creates new mutation for the PublicationDetail entity.
func newPublicationDetailMutation(c config, op Op, opts ...publicationdetailOption) *PublicationDetailMutation {
	m := &PublicationDetailMutation{
		config:        c,
		op:            op,
		typ:           TypePublicationDetail,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPublicationDetailID sets the ID field of the mutation.
func withPublicationDetailID(id int) publicationdetailOption {
	return func(m *PublicationDetailMutation) {
		var (
			err   error
			once  sync.Once
			value *PublicationDetail
		)
		m.oldValue = func(ctx context.Context) (*PublicationDetail, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PublicationDetail.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPublicationDetail sets the old PublicationDetail of the mutation.
func withPublicationDetail(node *PublicationDetail) publicationdetailOption {
	return func(m *PublicationDetailMutation) {
		m.oldValue = func(context.Context) (*PublicationDetail, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PublicationDetailMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PublicationDetailMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PublicationDetail entities.
func (m *PublicationDetailMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PublicationDetailMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PublicationDetailMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PublicationDetail.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetIsbn sets the "isbn" field.
func (m *PublicationDetailMutation) SetIsbn(s string) {
	m.isbn = &s
}

// Isbn returns the value of the "isbn" field in the mutation.
func (m *PublicationDetailMutation) Isbn() (r string, exists bool) {
	v := m.isbn
	if v == nil {
		return
	}
	return *v, true
}

// OldIsbn returns the old "isbn" field's value of the PublicationDetail entity.
// If the PublicationDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PublicationDetailMutation) OldIsbn(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsbn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsbn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsbn: %w", err)
	}
	return oldValue.Isbn, nil
}

// ResetIsbn resets all changes to the "isbn" field.
func (m *PublicationDetailMutation) ResetIsbn() {
	m.isbn = nil
}

// SetDetailHTML sets the "detail_html" field.
func (m *PublicationDetailMutation) SetDetailHTML(s string) {
	m.detail_html = &s
}

// DetailHTML returns the value of the "detail_html" field in the mutation.
func (m *PublicationDetailMutation) DetailHTML() (r string, exists bool) {
	v := m.detail_html
	if v == nil {
		return
	}
	return *v, true
}

// OldDetailHTML returns the old "detail_html" field's value of the PublicationDetail entity.
// If the PublicationDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PublicationDetailMutation) OldDetailHTML(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDetailHTML is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDetailHTML requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDetailHTML: %w", err)
	}
	return oldValue.DetailHTML, nil
}

// ClearDetailHTML clears the value of the "detail_html" field.
func (m *PublicationDetailMutation) ClearDetailHTML() {
	m.detail_html = nil
	m.clearedFields[publicationdetail.FieldDetailHTML] = struct{}{}
}

// DetailHTMLCleared returns if the "detail_html" field was cleared in this mutation.
func (m *PublicationDetailMutation) DetailHTMLCleared() bool {
	_, ok := m.clearedFields[publicationdetail.FieldDetailHTML]
	return ok
}

// ResetDetailHTML resets all changes to the "detail_html" field.
func (m *PublicationDetailMutation) ResetDetailHTML() {
	m.detail_html = nil
	delete(m.clearedFields, publicationdetail.FieldDetailHTML)
}

// SetDetailImg sets the "detail_img" field.
func (m *PublicationDetailMutation) SetDetailImg(s string) {
	m.detail_img = &s
}

// DetailImg returns the value of the "detail_img" field in the mutation.
func (m *PublicationDetailMutation) DetailImg() (r string, exists bool) {
	v := m.detail_img
	if v == nil {
		return
	}
	return *v, true
}

// OldDetailImg returns the old "detail_img" field's value of the PublicationDetail entity.
// If the PublicationDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PublicationDetailMutation) OldDetailImg(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDetailImg is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDetailImg requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDetailImg: %w", err)
	}
	return oldValue.DetailImg, nil
}

// ClearDetailImg clears the value of the "detail_img" field.
func (m *PublicationDetailMutation) ClearDetailImg() {
	m.detail_img = nil
	m.clearedFields[publicationdetail.FieldDetailImg] = struct{}{}
}

// DetailImgCleared returns if the "detail_img" field was cleared in this mutation.
func (m *PublicationDetailMutation) DetailImgCleared() bool {
	_, ok := m.clearedFields[publicationdetail.FieldDetailImg]
	return ok
}

// ResetDetailImg resets all changes to the "detail_img" field.
func (m *PublicationDetailMutation) ResetDetailImg() {
	m.detail_img = nil
	delete(m.clearedFields, publicationdetail.FieldDetailImg)
}

// SetPublicationID sets the "publication_id" field.
func (m *PublicationDetailMutation) SetPublicationID(i int) {
	m.publication_id = &i
	m.addpublication_id = nil
}

// PublicationID returns the value of the "publication_id" field in the mutation.
func (m *PublicationDetailMutation) PublicationID() (r int, exists bool) {
	v := m.publication_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPublicationID returns the old "publication_id" field's value of the PublicationDetail entity.
// If the PublicationDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PublicationDetailMutation) OldPublicationID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPublicationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPublicationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublicationID: %w", err)
	}
	return oldValue.PublicationID, nil
}

// AddPublicationID adds i to the "publication_id" field.
func (m *PublicationDetailMutation) AddPublicationID(i int) {
	if m.addpublication_id != nil {
		*m.addpublication_id += i
	} else {
		m.addpublication_id = &i
	}
}

// AddedPublicationID returns the value that was added to the "publication_id" field in this mutation.
func (m *PublicationDetailMutation) AddedPublicationID() (r int, exists bool) {
	v := m.addpublication_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearPublicationID clears the value of the "publication_id" field.
func (m *PublicationDetailMutation) ClearPublicationID() {
	m.publication_id = nil
	m.addpublication_id = nil
	m.clearedFields[publicationdetail.FieldPublicationID] = struct{}{}
}

// PublicationIDCleared returns if the "publication_id" field was cleared in this mutation.
func (m *PublicationDetailMutation) PublicationIDCleared() bool {
	_, ok := m.clearedFields[publicationdetail.FieldPublicationID]
	return ok
}

// ResetPublicationID resets all changes to the "publication_id" field.
func (m *PublicationDetailMutation) ResetPublicationID() {
	m.publication_id = nil
	m.addpublication_id = nil
	delete(m.clearedFields, publicationdetail.FieldPublicationID)
}

// Where appends a list predicates to the PublicationDetailMutation builder.
func (m *PublicationDetailMutation) Where(ps ...predicate.PublicationDetail) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PublicationDetailMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PublicationDetailMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PublicationDetail, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PublicationDetailMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PublicationDetailMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PublicationDetail).
func (m *PublicationDetailMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PublicationDetailMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.isbn != nil {
		fields = append(fields, publicationdetail.FieldIsbn)
	}
	if m.detail_html != nil {
		fields = append(fields, publicationdetail.FieldDetailHTML)
	}
	if m.detail_img != nil {
		fields = append(fields, publicationdetail.FieldDetailImg)
	}
	if m.publication_id != nil {
		fields = append(fields, publicationdetail.FieldPublicationID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PublicationDetailMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case publicationdetail.FieldIsbn:
		return m.Isbn()
	case publicationdetail.FieldDetailHTML:
		return m.DetailHTML()
	case publicationdetail.FieldDetailImg:
		return m.DetailImg()
	case publicationdetail.FieldPublicationID:
		return m.PublicationID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PublicationDetailMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case publicationdetail.FieldIsbn:
		return m.OldIsbn(ctx)
	case publicationdetail.FieldDetailHTML:
		return m.OldDetailHTML(ctx)
	case publicationdetail.FieldDetailImg:
		return m.OldDetailImg(ctx)
	case publicationdetail.FieldPublicationID:
		return m.OldPublicationID(ctx)
	}
	return nil, fmt.Errorf("unknown PublicationDetail field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PublicationDetailMutation) SetField(name string, value ent.Value) error {
	switch name {
	case publicationdetail.FieldIsbn:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsbn(v)
		return nil
	case publicationdetail.FieldDetailHTML:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDetailHTML(v)
		return nil
	case publicationdetail.FieldDetailImg:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDetailImg(v)
		return nil
	case publicationdetail.FieldPublicationID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublicationID(v)
		return nil
	}
	return fmt.Errorf("unknown PublicationDetail field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PublicationDetailMutation) AddedFields() []string {
	var fields []string
	if m.addpublication_id != nil {
		fields = append(fields, publicationdetail.FieldPublicationID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PublicationDetailMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case publicationdetail.FieldPublicationID:
		return m.AddedPublicationID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PublicationDetailMutation) AddField(name string, value ent.Value) error {
	switch name {
	case publicationdetail.FieldPublicationID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPublicationID(v)
		return nil
	}
	return fmt.Errorf("unknown PublicationDetail numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PublicationDetailMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(publicationdetail.FieldDetailHTML) {
		fields = append(fields, publicationdetail.FieldDetailHTML)
	}
	if m.FieldCleared(publicationdetail.FieldDetailImg) {
		fields = append(fields, publicationdetail.FieldDetailImg)
	}
	if m.FieldCleared(publicationdetail.FieldPublicationID) {
		fields = append(fields, publicationdetail.FieldPublicationID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PublicationDetailMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PublicationDetailMutation) ClearField(name string) error {
	switch name {
	case publicationdetail.FieldDetailHTML:
		m.ClearDetailHTML()
		return nil
	case publicationdetail.FieldDetailImg:
		m.ClearDetailImg()
		return nil
	case publicationdetail.FieldPublicationID:
		m.ClearPublicationID()
		return nil
	}
	return fmt.Errorf("unknown PublicationDetail nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PublicationDetailMutation) ResetField(name string) error {
	switch name {
	case publicationdetail.FieldIsbn:
		m.ResetIsbn()
		return nil
	case publicationdetail.FieldDetailHTML:
		m.ResetDetailHTML()
		return nil
	case publicationdetail.FieldDetailImg:
		m.ResetDetailImg()
		return nil
	case publicationdetail.FieldPublicationID:
		m.ResetPublicationID()
		return nil
	}
	return fmt.Errorf("unknown PublicationDetail field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PublicationDetailMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PublicationDetailMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PublicationDetailMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PublicationDetailMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PublicationDetailMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PublicationDetailMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PublicationDetailMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown PublicationDetail unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PublicationDetailMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown PublicationDetail edge %s", name)
}

// PublicationImgMutation represents an operation that mutates the PublicationImg nodes in the graph.
type PublicationImgMutation struct {
	config
	op                Op
	typ               string
	id                *int
	img_url           *string
	isbn              *int
	addisbn           *int
	img_encode        *string
	publication_id    *int
	addpublication_id *int
	mainFlag          *int32
	addmainFlag       *int32
	clearedFields     map[string]struct{}
	done              bool
	oldValue          func(context.Context) (*PublicationImg, error)
	predicates        []predicate.PublicationImg
}

var _ ent.Mutation = (*PublicationImgMutation)(nil)

// publicationimgOption allows management of the mutation configuration using functional options.
type publicationimgOption func(*PublicationImgMutation)

// newPublicationImgMutation creates new mutation for the PublicationImg entity.
func newPublicationImgMutation(c config, op Op, opts ...publicationimgOption) *PublicationImgMutation {
	m := &PublicationImgMutation{
		config:        c,
		op:            op,
		typ:           TypePublicationImg,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPublicationImgID sets the ID field of the mutation.
func withPublicationImgID(id int) publicationimgOption {
	return func(m *PublicationImgMutation) {
		var (
			err   error
			once  sync.Once
			value *PublicationImg
		)
		m.oldValue = func(ctx context.Context) (*PublicationImg, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PublicationImg.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPublicationImg sets the old PublicationImg of the mutation.
func withPublicationImg(node *PublicationImg) publicationimgOption {
	return func(m *PublicationImgMutation) {
		m.oldValue = func(context.Context) (*PublicationImg, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PublicationImgMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PublicationImgMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PublicationImg entities.
func (m *PublicationImgMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PublicationImgMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PublicationImgMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PublicationImg.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetImgURL sets the "img_url" field.
func (m *PublicationImgMutation) SetImgURL(s string) {
	m.img_url = &s
}

// ImgURL returns the value of the "img_url" field in the mutation.
func (m *PublicationImgMutation) ImgURL() (r string, exists bool) {
	v := m.img_url
	if v == nil {
		return
	}
	return *v, true
}

// OldImgURL returns the old "img_url" field's value of the PublicationImg entity.
// If the PublicationImg object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PublicationImgMutation) OldImgURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImgURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImgURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImgURL: %w", err)
	}
	return oldValue.ImgURL, nil
}

// ClearImgURL clears the value of the "img_url" field.
func (m *PublicationImgMutation) ClearImgURL() {
	m.img_url = nil
	m.clearedFields[publicationimg.FieldImgURL] = struct{}{}
}

// ImgURLCleared returns if the "img_url" field was cleared in this mutation.
func (m *PublicationImgMutation) ImgURLCleared() bool {
	_, ok := m.clearedFields[publicationimg.FieldImgURL]
	return ok
}

// ResetImgURL resets all changes to the "img_url" field.
func (m *PublicationImgMutation) ResetImgURL() {
	m.img_url = nil
	delete(m.clearedFields, publicationimg.FieldImgURL)
}

// SetIsbn sets the "isbn" field.
func (m *PublicationImgMutation) SetIsbn(i int) {
	m.isbn = &i
	m.addisbn = nil
}

// Isbn returns the value of the "isbn" field in the mutation.
func (m *PublicationImgMutation) Isbn() (r int, exists bool) {
	v := m.isbn
	if v == nil {
		return
	}
	return *v, true
}

// OldIsbn returns the old "isbn" field's value of the PublicationImg entity.
// If the PublicationImg object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PublicationImgMutation) OldIsbn(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsbn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsbn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsbn: %w", err)
	}
	return oldValue.Isbn, nil
}

// AddIsbn adds i to the "isbn" field.
func (m *PublicationImgMutation) AddIsbn(i int) {
	if m.addisbn != nil {
		*m.addisbn += i
	} else {
		m.addisbn = &i
	}
}

// AddedIsbn returns the value that was added to the "isbn" field in this mutation.
func (m *PublicationImgMutation) AddedIsbn() (r int, exists bool) {
	v := m.addisbn
	if v == nil {
		return
	}
	return *v, true
}

// ResetIsbn resets all changes to the "isbn" field.
func (m *PublicationImgMutation) ResetIsbn() {
	m.isbn = nil
	m.addisbn = nil
}

// SetImgEncode sets the "img_encode" field.
func (m *PublicationImgMutation) SetImgEncode(s string) {
	m.img_encode = &s
}

// ImgEncode returns the value of the "img_encode" field in the mutation.
func (m *PublicationImgMutation) ImgEncode() (r string, exists bool) {
	v := m.img_encode
	if v == nil {
		return
	}
	return *v, true
}

// OldImgEncode returns the old "img_encode" field's value of the PublicationImg entity.
// If the PublicationImg object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PublicationImgMutation) OldImgEncode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImgEncode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImgEncode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImgEncode: %w", err)
	}
	return oldValue.ImgEncode, nil
}

// ClearImgEncode clears the value of the "img_encode" field.
func (m *PublicationImgMutation) ClearImgEncode() {
	m.img_encode = nil
	m.clearedFields[publicationimg.FieldImgEncode] = struct{}{}
}

// ImgEncodeCleared returns if the "img_encode" field was cleared in this mutation.
func (m *PublicationImgMutation) ImgEncodeCleared() bool {
	_, ok := m.clearedFields[publicationimg.FieldImgEncode]
	return ok
}

// ResetImgEncode resets all changes to the "img_encode" field.
func (m *PublicationImgMutation) ResetImgEncode() {
	m.img_encode = nil
	delete(m.clearedFields, publicationimg.FieldImgEncode)
}

// SetPublicationID sets the "publication_id" field.
func (m *PublicationImgMutation) SetPublicationID(i int) {
	m.publication_id = &i
	m.addpublication_id = nil
}

// PublicationID returns the value of the "publication_id" field in the mutation.
func (m *PublicationImgMutation) PublicationID() (r int, exists bool) {
	v := m.publication_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPublicationID returns the old "publication_id" field's value of the PublicationImg entity.
// If the PublicationImg object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PublicationImgMutation) OldPublicationID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPublicationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPublicationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublicationID: %w", err)
	}
	return oldValue.PublicationID, nil
}

// AddPublicationID adds i to the "publication_id" field.
func (m *PublicationImgMutation) AddPublicationID(i int) {
	if m.addpublication_id != nil {
		*m.addpublication_id += i
	} else {
		m.addpublication_id = &i
	}
}

// AddedPublicationID returns the value that was added to the "publication_id" field in this mutation.
func (m *PublicationImgMutation) AddedPublicationID() (r int, exists bool) {
	v := m.addpublication_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearPublicationID clears the value of the "publication_id" field.
func (m *PublicationImgMutation) ClearPublicationID() {
	m.publication_id = nil
	m.addpublication_id = nil
	m.clearedFields[publicationimg.FieldPublicationID] = struct{}{}
}

// PublicationIDCleared returns if the "publication_id" field was cleared in this mutation.
func (m *PublicationImgMutation) PublicationIDCleared() bool {
	_, ok := m.clearedFields[publicationimg.FieldPublicationID]
	return ok
}

// ResetPublicationID resets all changes to the "publication_id" field.
func (m *PublicationImgMutation) ResetPublicationID() {
	m.publication_id = nil
	m.addpublication_id = nil
	delete(m.clearedFields, publicationimg.FieldPublicationID)
}

// SetMainFlag sets the "mainFlag" field.
func (m *PublicationImgMutation) SetMainFlag(i int32) {
	m.mainFlag = &i
	m.addmainFlag = nil
}

// MainFlag returns the value of the "mainFlag" field in the mutation.
func (m *PublicationImgMutation) MainFlag() (r int32, exists bool) {
	v := m.mainFlag
	if v == nil {
		return
	}
	return *v, true
}

// OldMainFlag returns the old "mainFlag" field's value of the PublicationImg entity.
// If the PublicationImg object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PublicationImgMutation) OldMainFlag(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMainFlag is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMainFlag requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMainFlag: %w", err)
	}
	return oldValue.MainFlag, nil
}

// AddMainFlag adds i to the "mainFlag" field.
func (m *PublicationImgMutation) AddMainFlag(i int32) {
	if m.addmainFlag != nil {
		*m.addmainFlag += i
	} else {
		m.addmainFlag = &i
	}
}

// AddedMainFlag returns the value that was added to the "mainFlag" field in this mutation.
func (m *PublicationImgMutation) AddedMainFlag() (r int32, exists bool) {
	v := m.addmainFlag
	if v == nil {
		return
	}
	return *v, true
}

// ClearMainFlag clears the value of the "mainFlag" field.
func (m *PublicationImgMutation) ClearMainFlag() {
	m.mainFlag = nil
	m.addmainFlag = nil
	m.clearedFields[publicationimg.FieldMainFlag] = struct{}{}
}

// MainFlagCleared returns if the "mainFlag" field was cleared in this mutation.
func (m *PublicationImgMutation) MainFlagCleared() bool {
	_, ok := m.clearedFields[publicationimg.FieldMainFlag]
	return ok
}

// ResetMainFlag resets all changes to the "mainFlag" field.
func (m *PublicationImgMutation) ResetMainFlag() {
	m.mainFlag = nil
	m.addmainFlag = nil
	delete(m.clearedFields, publicationimg.FieldMainFlag)
}

// Where appends a list predicates to the PublicationImgMutation builder.
func (m *PublicationImgMutation) Where(ps ...predicate.PublicationImg) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PublicationImgMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PublicationImgMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PublicationImg, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PublicationImgMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PublicationImgMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PublicationImg).
func (m *PublicationImgMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PublicationImgMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.img_url != nil {
		fields = append(fields, publicationimg.FieldImgURL)
	}
	if m.isbn != nil {
		fields = append(fields, publicationimg.FieldIsbn)
	}
	if m.img_encode != nil {
		fields = append(fields, publicationimg.FieldImgEncode)
	}
	if m.publication_id != nil {
		fields = append(fields, publicationimg.FieldPublicationID)
	}
	if m.mainFlag != nil {
		fields = append(fields, publicationimg.FieldMainFlag)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PublicationImgMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case publicationimg.FieldImgURL:
		return m.ImgURL()
	case publicationimg.FieldIsbn:
		return m.Isbn()
	case publicationimg.FieldImgEncode:
		return m.ImgEncode()
	case publicationimg.FieldPublicationID:
		return m.PublicationID()
	case publicationimg.FieldMainFlag:
		return m.MainFlag()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PublicationImgMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case publicationimg.FieldImgURL:
		return m.OldImgURL(ctx)
	case publicationimg.FieldIsbn:
		return m.OldIsbn(ctx)
	case publicationimg.FieldImgEncode:
		return m.OldImgEncode(ctx)
	case publicationimg.FieldPublicationID:
		return m.OldPublicationID(ctx)
	case publicationimg.FieldMainFlag:
		return m.OldMainFlag(ctx)
	}
	return nil, fmt.Errorf("unknown PublicationImg field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PublicationImgMutation) SetField(name string, value ent.Value) error {
	switch name {
	case publicationimg.FieldImgURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImgURL(v)
		return nil
	case publicationimg.FieldIsbn:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsbn(v)
		return nil
	case publicationimg.FieldImgEncode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImgEncode(v)
		return nil
	case publicationimg.FieldPublicationID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublicationID(v)
		return nil
	case publicationimg.FieldMainFlag:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMainFlag(v)
		return nil
	}
	return fmt.Errorf("unknown PublicationImg field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PublicationImgMutation) AddedFields() []string {
	var fields []string
	if m.addisbn != nil {
		fields = append(fields, publicationimg.FieldIsbn)
	}
	if m.addpublication_id != nil {
		fields = append(fields, publicationimg.FieldPublicationID)
	}
	if m.addmainFlag != nil {
		fields = append(fields, publicationimg.FieldMainFlag)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PublicationImgMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case publicationimg.FieldIsbn:
		return m.AddedIsbn()
	case publicationimg.FieldPublicationID:
		return m.AddedPublicationID()
	case publicationimg.FieldMainFlag:
		return m.AddedMainFlag()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PublicationImgMutation) AddField(name string, value ent.Value) error {
	switch name {
	case publicationimg.FieldIsbn:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsbn(v)
		return nil
	case publicationimg.FieldPublicationID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPublicationID(v)
		return nil
	case publicationimg.FieldMainFlag:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMainFlag(v)
		return nil
	}
	return fmt.Errorf("unknown PublicationImg numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PublicationImgMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(publicationimg.FieldImgURL) {
		fields = append(fields, publicationimg.FieldImgURL)
	}
	if m.FieldCleared(publicationimg.FieldImgEncode) {
		fields = append(fields, publicationimg.FieldImgEncode)
	}
	if m.FieldCleared(publicationimg.FieldPublicationID) {
		fields = append(fields, publicationimg.FieldPublicationID)
	}
	if m.FieldCleared(publicationimg.FieldMainFlag) {
		fields = append(fields, publicationimg.FieldMainFlag)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PublicationImgMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PublicationImgMutation) ClearField(name string) error {
	switch name {
	case publicationimg.FieldImgURL:
		m.ClearImgURL()
		return nil
	case publicationimg.FieldImgEncode:
		m.ClearImgEncode()
		return nil
	case publicationimg.FieldPublicationID:
		m.ClearPublicationID()
		return nil
	case publicationimg.FieldMainFlag:
		m.ClearMainFlag()
		return nil
	}
	return fmt.Errorf("unknown PublicationImg nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PublicationImgMutation) ResetField(name string) error {
	switch name {
	case publicationimg.FieldImgURL:
		m.ResetImgURL()
		return nil
	case publicationimg.FieldIsbn:
		m.ResetIsbn()
		return nil
	case publicationimg.FieldImgEncode:
		m.ResetImgEncode()
		return nil
	case publicationimg.FieldPublicationID:
		m.ResetPublicationID()
		return nil
	case publicationimg.FieldMainFlag:
		m.ResetMainFlag()
		return nil
	}
	return fmt.Errorf("unknown PublicationImg field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PublicationImgMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PublicationImgMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PublicationImgMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PublicationImgMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PublicationImgMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PublicationImgMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PublicationImgMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown PublicationImg unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PublicationImgMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown PublicationImg edge %s", name)
}

// PublicationInfoMutation represents an operation that mutates the PublicationInfo nodes in the graph.
type PublicationInfoMutation struct {
	config
	op               Op
	typ              string
	id               *int
	publication_name *string
	org_id           *string
	published_times  *string
	print_times      *string
	price            *float64
	addprice         *float64
	introduction     *string
	word_count       *string
	isbn             *string
	storage_by       *string
	storage_at       *time.Time
	modified_by      *string
	created_at       *time.Time
	modified_at      *time.Time
	clearedFields    map[string]struct{}
	done             bool
	oldValue         func(context.Context) (*PublicationInfo, error)
	predicates       []predicate.PublicationInfo
}

var _ ent.Mutation = (*PublicationInfoMutation)(nil)

// publicationinfoOption allows management of the mutation configuration using functional options.
type publicationinfoOption func(*PublicationInfoMutation)

// newPublicationInfoMutation creates new mutation for the PublicationInfo entity.
func newPublicationInfoMutation(c config, op Op, opts ...publicationinfoOption) *PublicationInfoMutation {
	m := &PublicationInfoMutation{
		config:        c,
		op:            op,
		typ:           TypePublicationInfo,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPublicationInfoID sets the ID field of the mutation.
func withPublicationInfoID(id int) publicationinfoOption {
	return func(m *PublicationInfoMutation) {
		var (
			err   error
			once  sync.Once
			value *PublicationInfo
		)
		m.oldValue = func(ctx context.Context) (*PublicationInfo, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PublicationInfo.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPublicationInfo sets the old PublicationInfo of the mutation.
func withPublicationInfo(node *PublicationInfo) publicationinfoOption {
	return func(m *PublicationInfoMutation) {
		m.oldValue = func(context.Context) (*PublicationInfo, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PublicationInfoMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PublicationInfoMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PublicationInfo entities.
func (m *PublicationInfoMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PublicationInfoMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PublicationInfoMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PublicationInfo.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetPublicationName sets the "publication_name" field.
func (m *PublicationInfoMutation) SetPublicationName(s string) {
	m.publication_name = &s
}

// PublicationName returns the value of the "publication_name" field in the mutation.
func (m *PublicationInfoMutation) PublicationName() (r string, exists bool) {
	v := m.publication_name
	if v == nil {
		return
	}
	return *v, true
}

// OldPublicationName returns the old "publication_name" field's value of the PublicationInfo entity.
// If the PublicationInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PublicationInfoMutation) OldPublicationName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPublicationName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPublicationName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublicationName: %w", err)
	}
	return oldValue.PublicationName, nil
}

// ClearPublicationName clears the value of the "publication_name" field.
func (m *PublicationInfoMutation) ClearPublicationName() {
	m.publication_name = nil
	m.clearedFields[publicationinfo.FieldPublicationName] = struct{}{}
}

// PublicationNameCleared returns if the "publication_name" field was cleared in this mutation.
func (m *PublicationInfoMutation) PublicationNameCleared() bool {
	_, ok := m.clearedFields[publicationinfo.FieldPublicationName]
	return ok
}

// ResetPublicationName resets all changes to the "publication_name" field.
func (m *PublicationInfoMutation) ResetPublicationName() {
	m.publication_name = nil
	delete(m.clearedFields, publicationinfo.FieldPublicationName)
}

// SetOrgID sets the "org_id" field.
func (m *PublicationInfoMutation) SetOrgID(s string) {
	m.org_id = &s
}

// OrgID returns the value of the "org_id" field in the mutation.
func (m *PublicationInfoMutation) OrgID() (r string, exists bool) {
	v := m.org_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOrgID returns the old "org_id" field's value of the PublicationInfo entity.
// If the PublicationInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PublicationInfoMutation) OldOrgID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrgID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrgID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrgID: %w", err)
	}
	return oldValue.OrgID, nil
}

// ClearOrgID clears the value of the "org_id" field.
func (m *PublicationInfoMutation) ClearOrgID() {
	m.org_id = nil
	m.clearedFields[publicationinfo.FieldOrgID] = struct{}{}
}

// OrgIDCleared returns if the "org_id" field was cleared in this mutation.
func (m *PublicationInfoMutation) OrgIDCleared() bool {
	_, ok := m.clearedFields[publicationinfo.FieldOrgID]
	return ok
}

// ResetOrgID resets all changes to the "org_id" field.
func (m *PublicationInfoMutation) ResetOrgID() {
	m.org_id = nil
	delete(m.clearedFields, publicationinfo.FieldOrgID)
}

// SetPublishedTimes sets the "published_times" field.
func (m *PublicationInfoMutation) SetPublishedTimes(s string) {
	m.published_times = &s
}

// PublishedTimes returns the value of the "published_times" field in the mutation.
func (m *PublicationInfoMutation) PublishedTimes() (r string, exists bool) {
	v := m.published_times
	if v == nil {
		return
	}
	return *v, true
}

// OldPublishedTimes returns the old "published_times" field's value of the PublicationInfo entity.
// If the PublicationInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PublicationInfoMutation) OldPublishedTimes(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPublishedTimes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPublishedTimes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublishedTimes: %w", err)
	}
	return oldValue.PublishedTimes, nil
}

// ClearPublishedTimes clears the value of the "published_times" field.
func (m *PublicationInfoMutation) ClearPublishedTimes() {
	m.published_times = nil
	m.clearedFields[publicationinfo.FieldPublishedTimes] = struct{}{}
}

// PublishedTimesCleared returns if the "published_times" field was cleared in this mutation.
func (m *PublicationInfoMutation) PublishedTimesCleared() bool {
	_, ok := m.clearedFields[publicationinfo.FieldPublishedTimes]
	return ok
}

// ResetPublishedTimes resets all changes to the "published_times" field.
func (m *PublicationInfoMutation) ResetPublishedTimes() {
	m.published_times = nil
	delete(m.clearedFields, publicationinfo.FieldPublishedTimes)
}

// SetPrintTimes sets the "print_times" field.
func (m *PublicationInfoMutation) SetPrintTimes(s string) {
	m.print_times = &s
}

// PrintTimes returns the value of the "print_times" field in the mutation.
func (m *PublicationInfoMutation) PrintTimes() (r string, exists bool) {
	v := m.print_times
	if v == nil {
		return
	}
	return *v, true
}

// OldPrintTimes returns the old "print_times" field's value of the PublicationInfo entity.
// If the PublicationInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PublicationInfoMutation) OldPrintTimes(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrintTimes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrintTimes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrintTimes: %w", err)
	}
	return oldValue.PrintTimes, nil
}

// ClearPrintTimes clears the value of the "print_times" field.
func (m *PublicationInfoMutation) ClearPrintTimes() {
	m.print_times = nil
	m.clearedFields[publicationinfo.FieldPrintTimes] = struct{}{}
}

// PrintTimesCleared returns if the "print_times" field was cleared in this mutation.
func (m *PublicationInfoMutation) PrintTimesCleared() bool {
	_, ok := m.clearedFields[publicationinfo.FieldPrintTimes]
	return ok
}

// ResetPrintTimes resets all changes to the "print_times" field.
func (m *PublicationInfoMutation) ResetPrintTimes() {
	m.print_times = nil
	delete(m.clearedFields, publicationinfo.FieldPrintTimes)
}

// SetPrice sets the "price" field.
func (m *PublicationInfoMutation) SetPrice(f float64) {
	m.price = &f
	m.addprice = nil
}

// Price returns the value of the "price" field in the mutation.
func (m *PublicationInfoMutation) Price() (r float64, exists bool) {
	v := m.price
	if v == nil {
		return
	}
	return *v, true
}

// OldPrice returns the old "price" field's value of the PublicationInfo entity.
// If the PublicationInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PublicationInfoMutation) OldPrice(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrice: %w", err)
	}
	return oldValue.Price, nil
}

// AddPrice adds f to the "price" field.
func (m *PublicationInfoMutation) AddPrice(f float64) {
	if m.addprice != nil {
		*m.addprice += f
	} else {
		m.addprice = &f
	}
}

// AddedPrice returns the value that was added to the "price" field in this mutation.
func (m *PublicationInfoMutation) AddedPrice() (r float64, exists bool) {
	v := m.addprice
	if v == nil {
		return
	}
	return *v, true
}

// ClearPrice clears the value of the "price" field.
func (m *PublicationInfoMutation) ClearPrice() {
	m.price = nil
	m.addprice = nil
	m.clearedFields[publicationinfo.FieldPrice] = struct{}{}
}

// PriceCleared returns if the "price" field was cleared in this mutation.
func (m *PublicationInfoMutation) PriceCleared() bool {
	_, ok := m.clearedFields[publicationinfo.FieldPrice]
	return ok
}

// ResetPrice resets all changes to the "price" field.
func (m *PublicationInfoMutation) ResetPrice() {
	m.price = nil
	m.addprice = nil
	delete(m.clearedFields, publicationinfo.FieldPrice)
}

// SetIntroduction sets the "introduction" field.
func (m *PublicationInfoMutation) SetIntroduction(s string) {
	m.introduction = &s
}

// Introduction returns the value of the "introduction" field in the mutation.
func (m *PublicationInfoMutation) Introduction() (r string, exists bool) {
	v := m.introduction
	if v == nil {
		return
	}
	return *v, true
}

// OldIntroduction returns the old "introduction" field's value of the PublicationInfo entity.
// If the PublicationInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PublicationInfoMutation) OldIntroduction(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIntroduction is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIntroduction requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIntroduction: %w", err)
	}
	return oldValue.Introduction, nil
}

// ClearIntroduction clears the value of the "introduction" field.
func (m *PublicationInfoMutation) ClearIntroduction() {
	m.introduction = nil
	m.clearedFields[publicationinfo.FieldIntroduction] = struct{}{}
}

// IntroductionCleared returns if the "introduction" field was cleared in this mutation.
func (m *PublicationInfoMutation) IntroductionCleared() bool {
	_, ok := m.clearedFields[publicationinfo.FieldIntroduction]
	return ok
}

// ResetIntroduction resets all changes to the "introduction" field.
func (m *PublicationInfoMutation) ResetIntroduction() {
	m.introduction = nil
	delete(m.clearedFields, publicationinfo.FieldIntroduction)
}

// SetWordCount sets the "word_count" field.
func (m *PublicationInfoMutation) SetWordCount(s string) {
	m.word_count = &s
}

// WordCount returns the value of the "word_count" field in the mutation.
func (m *PublicationInfoMutation) WordCount() (r string, exists bool) {
	v := m.word_count
	if v == nil {
		return
	}
	return *v, true
}

// OldWordCount returns the old "word_count" field's value of the PublicationInfo entity.
// If the PublicationInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PublicationInfoMutation) OldWordCount(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWordCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWordCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWordCount: %w", err)
	}
	return oldValue.WordCount, nil
}

// ClearWordCount clears the value of the "word_count" field.
func (m *PublicationInfoMutation) ClearWordCount() {
	m.word_count = nil
	m.clearedFields[publicationinfo.FieldWordCount] = struct{}{}
}

// WordCountCleared returns if the "word_count" field was cleared in this mutation.
func (m *PublicationInfoMutation) WordCountCleared() bool {
	_, ok := m.clearedFields[publicationinfo.FieldWordCount]
	return ok
}

// ResetWordCount resets all changes to the "word_count" field.
func (m *PublicationInfoMutation) ResetWordCount() {
	m.word_count = nil
	delete(m.clearedFields, publicationinfo.FieldWordCount)
}

// SetIsbn sets the "isbn" field.
func (m *PublicationInfoMutation) SetIsbn(s string) {
	m.isbn = &s
}

// Isbn returns the value of the "isbn" field in the mutation.
func (m *PublicationInfoMutation) Isbn() (r string, exists bool) {
	v := m.isbn
	if v == nil {
		return
	}
	return *v, true
}

// OldIsbn returns the old "isbn" field's value of the PublicationInfo entity.
// If the PublicationInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PublicationInfoMutation) OldIsbn(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsbn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsbn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsbn: %w", err)
	}
	return oldValue.Isbn, nil
}

// ClearIsbn clears the value of the "isbn" field.
func (m *PublicationInfoMutation) ClearIsbn() {
	m.isbn = nil
	m.clearedFields[publicationinfo.FieldIsbn] = struct{}{}
}

// IsbnCleared returns if the "isbn" field was cleared in this mutation.
func (m *PublicationInfoMutation) IsbnCleared() bool {
	_, ok := m.clearedFields[publicationinfo.FieldIsbn]
	return ok
}

// ResetIsbn resets all changes to the "isbn" field.
func (m *PublicationInfoMutation) ResetIsbn() {
	m.isbn = nil
	delete(m.clearedFields, publicationinfo.FieldIsbn)
}

// SetStorageBy sets the "storage_by" field.
func (m *PublicationInfoMutation) SetStorageBy(s string) {
	m.storage_by = &s
}

// StorageBy returns the value of the "storage_by" field in the mutation.
func (m *PublicationInfoMutation) StorageBy() (r string, exists bool) {
	v := m.storage_by
	if v == nil {
		return
	}
	return *v, true
}

// OldStorageBy returns the old "storage_by" field's value of the PublicationInfo entity.
// If the PublicationInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PublicationInfoMutation) OldStorageBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStorageBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStorageBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStorageBy: %w", err)
	}
	return oldValue.StorageBy, nil
}

// ClearStorageBy clears the value of the "storage_by" field.
func (m *PublicationInfoMutation) ClearStorageBy() {
	m.storage_by = nil
	m.clearedFields[publicationinfo.FieldStorageBy] = struct{}{}
}

// StorageByCleared returns if the "storage_by" field was cleared in this mutation.
func (m *PublicationInfoMutation) StorageByCleared() bool {
	_, ok := m.clearedFields[publicationinfo.FieldStorageBy]
	return ok
}

// ResetStorageBy resets all changes to the "storage_by" field.
func (m *PublicationInfoMutation) ResetStorageBy() {
	m.storage_by = nil
	delete(m.clearedFields, publicationinfo.FieldStorageBy)
}

// SetStorageAt sets the "storage_at" field.
func (m *PublicationInfoMutation) SetStorageAt(t time.Time) {
	m.storage_at = &t
}

// StorageAt returns the value of the "storage_at" field in the mutation.
func (m *PublicationInfoMutation) StorageAt() (r time.Time, exists bool) {
	v := m.storage_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStorageAt returns the old "storage_at" field's value of the PublicationInfo entity.
// If the PublicationInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PublicationInfoMutation) OldStorageAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStorageAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStorageAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStorageAt: %w", err)
	}
	return oldValue.StorageAt, nil
}

// ClearStorageAt clears the value of the "storage_at" field.
func (m *PublicationInfoMutation) ClearStorageAt() {
	m.storage_at = nil
	m.clearedFields[publicationinfo.FieldStorageAt] = struct{}{}
}

// StorageAtCleared returns if the "storage_at" field was cleared in this mutation.
func (m *PublicationInfoMutation) StorageAtCleared() bool {
	_, ok := m.clearedFields[publicationinfo.FieldStorageAt]
	return ok
}

// ResetStorageAt resets all changes to the "storage_at" field.
func (m *PublicationInfoMutation) ResetStorageAt() {
	m.storage_at = nil
	delete(m.clearedFields, publicationinfo.FieldStorageAt)
}

// SetModifiedBy sets the "modified_by" field.
func (m *PublicationInfoMutation) SetModifiedBy(s string) {
	m.modified_by = &s
}

// ModifiedBy returns the value of the "modified_by" field in the mutation.
func (m *PublicationInfoMutation) ModifiedBy() (r string, exists bool) {
	v := m.modified_by
	if v == nil {
		return
	}
	return *v, true
}

// OldModifiedBy returns the old "modified_by" field's value of the PublicationInfo entity.
// If the PublicationInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PublicationInfoMutation) OldModifiedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModifiedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModifiedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModifiedBy: %w", err)
	}
	return oldValue.ModifiedBy, nil
}

// ClearModifiedBy clears the value of the "modified_by" field.
func (m *PublicationInfoMutation) ClearModifiedBy() {
	m.modified_by = nil
	m.clearedFields[publicationinfo.FieldModifiedBy] = struct{}{}
}

// ModifiedByCleared returns if the "modified_by" field was cleared in this mutation.
func (m *PublicationInfoMutation) ModifiedByCleared() bool {
	_, ok := m.clearedFields[publicationinfo.FieldModifiedBy]
	return ok
}

// ResetModifiedBy resets all changes to the "modified_by" field.
func (m *PublicationInfoMutation) ResetModifiedBy() {
	m.modified_by = nil
	delete(m.clearedFields, publicationinfo.FieldModifiedBy)
}

// SetCreatedAt sets the "created_at" field.
func (m *PublicationInfoMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PublicationInfoMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PublicationInfo entity.
// If the PublicationInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PublicationInfoMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *PublicationInfoMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[publicationinfo.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *PublicationInfoMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[publicationinfo.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PublicationInfoMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, publicationinfo.FieldCreatedAt)
}

// SetModifiedAt sets the "modified_at" field.
func (m *PublicationInfoMutation) SetModifiedAt(t time.Time) {
	m.modified_at = &t
}

// ModifiedAt returns the value of the "modified_at" field in the mutation.
func (m *PublicationInfoMutation) ModifiedAt() (r time.Time, exists bool) {
	v := m.modified_at
	if v == nil {
		return
	}
	return *v, true
}

// OldModifiedAt returns the old "modified_at" field's value of the PublicationInfo entity.
// If the PublicationInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PublicationInfoMutation) OldModifiedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModifiedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModifiedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModifiedAt: %w", err)
	}
	return oldValue.ModifiedAt, nil
}

// ClearModifiedAt clears the value of the "modified_at" field.
func (m *PublicationInfoMutation) ClearModifiedAt() {
	m.modified_at = nil
	m.clearedFields[publicationinfo.FieldModifiedAt] = struct{}{}
}

// ModifiedAtCleared returns if the "modified_at" field was cleared in this mutation.
func (m *PublicationInfoMutation) ModifiedAtCleared() bool {
	_, ok := m.clearedFields[publicationinfo.FieldModifiedAt]
	return ok
}

// ResetModifiedAt resets all changes to the "modified_at" field.
func (m *PublicationInfoMutation) ResetModifiedAt() {
	m.modified_at = nil
	delete(m.clearedFields, publicationinfo.FieldModifiedAt)
}

// Where appends a list predicates to the PublicationInfoMutation builder.
func (m *PublicationInfoMutation) Where(ps ...predicate.PublicationInfo) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PublicationInfoMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PublicationInfoMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PublicationInfo, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PublicationInfoMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PublicationInfoMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PublicationInfo).
func (m *PublicationInfoMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PublicationInfoMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.publication_name != nil {
		fields = append(fields, publicationinfo.FieldPublicationName)
	}
	if m.org_id != nil {
		fields = append(fields, publicationinfo.FieldOrgID)
	}
	if m.published_times != nil {
		fields = append(fields, publicationinfo.FieldPublishedTimes)
	}
	if m.print_times != nil {
		fields = append(fields, publicationinfo.FieldPrintTimes)
	}
	if m.price != nil {
		fields = append(fields, publicationinfo.FieldPrice)
	}
	if m.introduction != nil {
		fields = append(fields, publicationinfo.FieldIntroduction)
	}
	if m.word_count != nil {
		fields = append(fields, publicationinfo.FieldWordCount)
	}
	if m.isbn != nil {
		fields = append(fields, publicationinfo.FieldIsbn)
	}
	if m.storage_by != nil {
		fields = append(fields, publicationinfo.FieldStorageBy)
	}
	if m.storage_at != nil {
		fields = append(fields, publicationinfo.FieldStorageAt)
	}
	if m.modified_by != nil {
		fields = append(fields, publicationinfo.FieldModifiedBy)
	}
	if m.created_at != nil {
		fields = append(fields, publicationinfo.FieldCreatedAt)
	}
	if m.modified_at != nil {
		fields = append(fields, publicationinfo.FieldModifiedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PublicationInfoMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case publicationinfo.FieldPublicationName:
		return m.PublicationName()
	case publicationinfo.FieldOrgID:
		return m.OrgID()
	case publicationinfo.FieldPublishedTimes:
		return m.PublishedTimes()
	case publicationinfo.FieldPrintTimes:
		return m.PrintTimes()
	case publicationinfo.FieldPrice:
		return m.Price()
	case publicationinfo.FieldIntroduction:
		return m.Introduction()
	case publicationinfo.FieldWordCount:
		return m.WordCount()
	case publicationinfo.FieldIsbn:
		return m.Isbn()
	case publicationinfo.FieldStorageBy:
		return m.StorageBy()
	case publicationinfo.FieldStorageAt:
		return m.StorageAt()
	case publicationinfo.FieldModifiedBy:
		return m.ModifiedBy()
	case publicationinfo.FieldCreatedAt:
		return m.CreatedAt()
	case publicationinfo.FieldModifiedAt:
		return m.ModifiedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PublicationInfoMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case publicationinfo.FieldPublicationName:
		return m.OldPublicationName(ctx)
	case publicationinfo.FieldOrgID:
		return m.OldOrgID(ctx)
	case publicationinfo.FieldPublishedTimes:
		return m.OldPublishedTimes(ctx)
	case publicationinfo.FieldPrintTimes:
		return m.OldPrintTimes(ctx)
	case publicationinfo.FieldPrice:
		return m.OldPrice(ctx)
	case publicationinfo.FieldIntroduction:
		return m.OldIntroduction(ctx)
	case publicationinfo.FieldWordCount:
		return m.OldWordCount(ctx)
	case publicationinfo.FieldIsbn:
		return m.OldIsbn(ctx)
	case publicationinfo.FieldStorageBy:
		return m.OldStorageBy(ctx)
	case publicationinfo.FieldStorageAt:
		return m.OldStorageAt(ctx)
	case publicationinfo.FieldModifiedBy:
		return m.OldModifiedBy(ctx)
	case publicationinfo.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case publicationinfo.FieldModifiedAt:
		return m.OldModifiedAt(ctx)
	}
	return nil, fmt.Errorf("unknown PublicationInfo field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PublicationInfoMutation) SetField(name string, value ent.Value) error {
	switch name {
	case publicationinfo.FieldPublicationName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublicationName(v)
		return nil
	case publicationinfo.FieldOrgID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrgID(v)
		return nil
	case publicationinfo.FieldPublishedTimes:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublishedTimes(v)
		return nil
	case publicationinfo.FieldPrintTimes:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrintTimes(v)
		return nil
	case publicationinfo.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrice(v)
		return nil
	case publicationinfo.FieldIntroduction:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIntroduction(v)
		return nil
	case publicationinfo.FieldWordCount:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWordCount(v)
		return nil
	case publicationinfo.FieldIsbn:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsbn(v)
		return nil
	case publicationinfo.FieldStorageBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStorageBy(v)
		return nil
	case publicationinfo.FieldStorageAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStorageAt(v)
		return nil
	case publicationinfo.FieldModifiedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModifiedBy(v)
		return nil
	case publicationinfo.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case publicationinfo.FieldModifiedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModifiedAt(v)
		return nil
	}
	return fmt.Errorf("unknown PublicationInfo field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PublicationInfoMutation) AddedFields() []string {
	var fields []string
	if m.addprice != nil {
		fields = append(fields, publicationinfo.FieldPrice)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PublicationInfoMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case publicationinfo.FieldPrice:
		return m.AddedPrice()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PublicationInfoMutation) AddField(name string, value ent.Value) error {
	switch name {
	case publicationinfo.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPrice(v)
		return nil
	}
	return fmt.Errorf("unknown PublicationInfo numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PublicationInfoMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(publicationinfo.FieldPublicationName) {
		fields = append(fields, publicationinfo.FieldPublicationName)
	}
	if m.FieldCleared(publicationinfo.FieldOrgID) {
		fields = append(fields, publicationinfo.FieldOrgID)
	}
	if m.FieldCleared(publicationinfo.FieldPublishedTimes) {
		fields = append(fields, publicationinfo.FieldPublishedTimes)
	}
	if m.FieldCleared(publicationinfo.FieldPrintTimes) {
		fields = append(fields, publicationinfo.FieldPrintTimes)
	}
	if m.FieldCleared(publicationinfo.FieldPrice) {
		fields = append(fields, publicationinfo.FieldPrice)
	}
	if m.FieldCleared(publicationinfo.FieldIntroduction) {
		fields = append(fields, publicationinfo.FieldIntroduction)
	}
	if m.FieldCleared(publicationinfo.FieldWordCount) {
		fields = append(fields, publicationinfo.FieldWordCount)
	}
	if m.FieldCleared(publicationinfo.FieldIsbn) {
		fields = append(fields, publicationinfo.FieldIsbn)
	}
	if m.FieldCleared(publicationinfo.FieldStorageBy) {
		fields = append(fields, publicationinfo.FieldStorageBy)
	}
	if m.FieldCleared(publicationinfo.FieldStorageAt) {
		fields = append(fields, publicationinfo.FieldStorageAt)
	}
	if m.FieldCleared(publicationinfo.FieldModifiedBy) {
		fields = append(fields, publicationinfo.FieldModifiedBy)
	}
	if m.FieldCleared(publicationinfo.FieldCreatedAt) {
		fields = append(fields, publicationinfo.FieldCreatedAt)
	}
	if m.FieldCleared(publicationinfo.FieldModifiedAt) {
		fields = append(fields, publicationinfo.FieldModifiedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PublicationInfoMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PublicationInfoMutation) ClearField(name string) error {
	switch name {
	case publicationinfo.FieldPublicationName:
		m.ClearPublicationName()
		return nil
	case publicationinfo.FieldOrgID:
		m.ClearOrgID()
		return nil
	case publicationinfo.FieldPublishedTimes:
		m.ClearPublishedTimes()
		return nil
	case publicationinfo.FieldPrintTimes:
		m.ClearPrintTimes()
		return nil
	case publicationinfo.FieldPrice:
		m.ClearPrice()
		return nil
	case publicationinfo.FieldIntroduction:
		m.ClearIntroduction()
		return nil
	case publicationinfo.FieldWordCount:
		m.ClearWordCount()
		return nil
	case publicationinfo.FieldIsbn:
		m.ClearIsbn()
		return nil
	case publicationinfo.FieldStorageBy:
		m.ClearStorageBy()
		return nil
	case publicationinfo.FieldStorageAt:
		m.ClearStorageAt()
		return nil
	case publicationinfo.FieldModifiedBy:
		m.ClearModifiedBy()
		return nil
	case publicationinfo.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case publicationinfo.FieldModifiedAt:
		m.ClearModifiedAt()
		return nil
	}
	return fmt.Errorf("unknown PublicationInfo nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PublicationInfoMutation) ResetField(name string) error {
	switch name {
	case publicationinfo.FieldPublicationName:
		m.ResetPublicationName()
		return nil
	case publicationinfo.FieldOrgID:
		m.ResetOrgID()
		return nil
	case publicationinfo.FieldPublishedTimes:
		m.ResetPublishedTimes()
		return nil
	case publicationinfo.FieldPrintTimes:
		m.ResetPrintTimes()
		return nil
	case publicationinfo.FieldPrice:
		m.ResetPrice()
		return nil
	case publicationinfo.FieldIntroduction:
		m.ResetIntroduction()
		return nil
	case publicationinfo.FieldWordCount:
		m.ResetWordCount()
		return nil
	case publicationinfo.FieldIsbn:
		m.ResetIsbn()
		return nil
	case publicationinfo.FieldStorageBy:
		m.ResetStorageBy()
		return nil
	case publicationinfo.FieldStorageAt:
		m.ResetStorageAt()
		return nil
	case publicationinfo.FieldModifiedBy:
		m.ResetModifiedBy()
		return nil
	case publicationinfo.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case publicationinfo.FieldModifiedAt:
		m.ResetModifiedAt()
		return nil
	}
	return fmt.Errorf("unknown PublicationInfo field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PublicationInfoMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PublicationInfoMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PublicationInfoMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PublicationInfoMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PublicationInfoMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PublicationInfoMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PublicationInfoMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown PublicationInfo unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PublicationInfoMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown PublicationInfo edge %s", name)
}

// PublicationOrgMutation represents an operation that mutates the PublicationOrg nodes in the graph.
type PublicationOrgMutation struct {
	config
	op            Op
	typ           string
	id            *int
	org_code      *string
	org_name      *string
	org_address   *string
	modified_at   *time.Time
	created_at    *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*PublicationOrg, error)
	predicates    []predicate.PublicationOrg
}

var _ ent.Mutation = (*PublicationOrgMutation)(nil)

// publicationorgOption allows management of the mutation configuration using functional options.
type publicationorgOption func(*PublicationOrgMutation)

// newPublicationOrgMutation creates new mutation for the PublicationOrg entity.
func newPublicationOrgMutation(c config, op Op, opts ...publicationorgOption) *PublicationOrgMutation {
	m := &PublicationOrgMutation{
		config:        c,
		op:            op,
		typ:           TypePublicationOrg,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPublicationOrgID sets the ID field of the mutation.
func withPublicationOrgID(id int) publicationorgOption {
	return func(m *PublicationOrgMutation) {
		var (
			err   error
			once  sync.Once
			value *PublicationOrg
		)
		m.oldValue = func(ctx context.Context) (*PublicationOrg, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PublicationOrg.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPublicationOrg sets the old PublicationOrg of the mutation.
func withPublicationOrg(node *PublicationOrg) publicationorgOption {
	return func(m *PublicationOrgMutation) {
		m.oldValue = func(context.Context) (*PublicationOrg, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PublicationOrgMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PublicationOrgMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PublicationOrg entities.
func (m *PublicationOrgMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PublicationOrgMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PublicationOrgMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PublicationOrg.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetOrgCode sets the "org_code" field.
func (m *PublicationOrgMutation) SetOrgCode(s string) {
	m.org_code = &s
}

// OrgCode returns the value of the "org_code" field in the mutation.
func (m *PublicationOrgMutation) OrgCode() (r string, exists bool) {
	v := m.org_code
	if v == nil {
		return
	}
	return *v, true
}

// OldOrgCode returns the old "org_code" field's value of the PublicationOrg entity.
// If the PublicationOrg object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PublicationOrgMutation) OldOrgCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrgCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrgCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrgCode: %w", err)
	}
	return oldValue.OrgCode, nil
}

// ResetOrgCode resets all changes to the "org_code" field.
func (m *PublicationOrgMutation) ResetOrgCode() {
	m.org_code = nil
}

// SetOrgName sets the "org_name" field.
func (m *PublicationOrgMutation) SetOrgName(s string) {
	m.org_name = &s
}

// OrgName returns the value of the "org_name" field in the mutation.
func (m *PublicationOrgMutation) OrgName() (r string, exists bool) {
	v := m.org_name
	if v == nil {
		return
	}
	return *v, true
}

// OldOrgName returns the old "org_name" field's value of the PublicationOrg entity.
// If the PublicationOrg object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PublicationOrgMutation) OldOrgName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrgName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrgName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrgName: %w", err)
	}
	return oldValue.OrgName, nil
}

// ClearOrgName clears the value of the "org_name" field.
func (m *PublicationOrgMutation) ClearOrgName() {
	m.org_name = nil
	m.clearedFields[publicationorg.FieldOrgName] = struct{}{}
}

// OrgNameCleared returns if the "org_name" field was cleared in this mutation.
func (m *PublicationOrgMutation) OrgNameCleared() bool {
	_, ok := m.clearedFields[publicationorg.FieldOrgName]
	return ok
}

// ResetOrgName resets all changes to the "org_name" field.
func (m *PublicationOrgMutation) ResetOrgName() {
	m.org_name = nil
	delete(m.clearedFields, publicationorg.FieldOrgName)
}

// SetOrgAddress sets the "org_address" field.
func (m *PublicationOrgMutation) SetOrgAddress(s string) {
	m.org_address = &s
}

// OrgAddress returns the value of the "org_address" field in the mutation.
func (m *PublicationOrgMutation) OrgAddress() (r string, exists bool) {
	v := m.org_address
	if v == nil {
		return
	}
	return *v, true
}

// OldOrgAddress returns the old "org_address" field's value of the PublicationOrg entity.
// If the PublicationOrg object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PublicationOrgMutation) OldOrgAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrgAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrgAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrgAddress: %w", err)
	}
	return oldValue.OrgAddress, nil
}

// ClearOrgAddress clears the value of the "org_address" field.
func (m *PublicationOrgMutation) ClearOrgAddress() {
	m.org_address = nil
	m.clearedFields[publicationorg.FieldOrgAddress] = struct{}{}
}

// OrgAddressCleared returns if the "org_address" field was cleared in this mutation.
func (m *PublicationOrgMutation) OrgAddressCleared() bool {
	_, ok := m.clearedFields[publicationorg.FieldOrgAddress]
	return ok
}

// ResetOrgAddress resets all changes to the "org_address" field.
func (m *PublicationOrgMutation) ResetOrgAddress() {
	m.org_address = nil
	delete(m.clearedFields, publicationorg.FieldOrgAddress)
}

// SetModifiedAt sets the "modified_at" field.
func (m *PublicationOrgMutation) SetModifiedAt(t time.Time) {
	m.modified_at = &t
}

// ModifiedAt returns the value of the "modified_at" field in the mutation.
func (m *PublicationOrgMutation) ModifiedAt() (r time.Time, exists bool) {
	v := m.modified_at
	if v == nil {
		return
	}
	return *v, true
}

// OldModifiedAt returns the old "modified_at" field's value of the PublicationOrg entity.
// If the PublicationOrg object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PublicationOrgMutation) OldModifiedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModifiedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModifiedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModifiedAt: %w", err)
	}
	return oldValue.ModifiedAt, nil
}

// ClearModifiedAt clears the value of the "modified_at" field.
func (m *PublicationOrgMutation) ClearModifiedAt() {
	m.modified_at = nil
	m.clearedFields[publicationorg.FieldModifiedAt] = struct{}{}
}

// ModifiedAtCleared returns if the "modified_at" field was cleared in this mutation.
func (m *PublicationOrgMutation) ModifiedAtCleared() bool {
	_, ok := m.clearedFields[publicationorg.FieldModifiedAt]
	return ok
}

// ResetModifiedAt resets all changes to the "modified_at" field.
func (m *PublicationOrgMutation) ResetModifiedAt() {
	m.modified_at = nil
	delete(m.clearedFields, publicationorg.FieldModifiedAt)
}

// SetCreatedAt sets the "created_at" field.
func (m *PublicationOrgMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PublicationOrgMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PublicationOrg entity.
// If the PublicationOrg object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PublicationOrgMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *PublicationOrgMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[publicationorg.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *PublicationOrgMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[publicationorg.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PublicationOrgMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, publicationorg.FieldCreatedAt)
}

// Where appends a list predicates to the PublicationOrgMutation builder.
func (m *PublicationOrgMutation) Where(ps ...predicate.PublicationOrg) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PublicationOrgMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PublicationOrgMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PublicationOrg, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PublicationOrgMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PublicationOrgMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PublicationOrg).
func (m *PublicationOrgMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PublicationOrgMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.org_code != nil {
		fields = append(fields, publicationorg.FieldOrgCode)
	}
	if m.org_name != nil {
		fields = append(fields, publicationorg.FieldOrgName)
	}
	if m.org_address != nil {
		fields = append(fields, publicationorg.FieldOrgAddress)
	}
	if m.modified_at != nil {
		fields = append(fields, publicationorg.FieldModifiedAt)
	}
	if m.created_at != nil {
		fields = append(fields, publicationorg.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PublicationOrgMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case publicationorg.FieldOrgCode:
		return m.OrgCode()
	case publicationorg.FieldOrgName:
		return m.OrgName()
	case publicationorg.FieldOrgAddress:
		return m.OrgAddress()
	case publicationorg.FieldModifiedAt:
		return m.ModifiedAt()
	case publicationorg.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PublicationOrgMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case publicationorg.FieldOrgCode:
		return m.OldOrgCode(ctx)
	case publicationorg.FieldOrgName:
		return m.OldOrgName(ctx)
	case publicationorg.FieldOrgAddress:
		return m.OldOrgAddress(ctx)
	case publicationorg.FieldModifiedAt:
		return m.OldModifiedAt(ctx)
	case publicationorg.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown PublicationOrg field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PublicationOrgMutation) SetField(name string, value ent.Value) error {
	switch name {
	case publicationorg.FieldOrgCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrgCode(v)
		return nil
	case publicationorg.FieldOrgName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrgName(v)
		return nil
	case publicationorg.FieldOrgAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrgAddress(v)
		return nil
	case publicationorg.FieldModifiedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModifiedAt(v)
		return nil
	case publicationorg.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown PublicationOrg field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PublicationOrgMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PublicationOrgMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PublicationOrgMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PublicationOrg numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PublicationOrgMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(publicationorg.FieldOrgName) {
		fields = append(fields, publicationorg.FieldOrgName)
	}
	if m.FieldCleared(publicationorg.FieldOrgAddress) {
		fields = append(fields, publicationorg.FieldOrgAddress)
	}
	if m.FieldCleared(publicationorg.FieldModifiedAt) {
		fields = append(fields, publicationorg.FieldModifiedAt)
	}
	if m.FieldCleared(publicationorg.FieldCreatedAt) {
		fields = append(fields, publicationorg.FieldCreatedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PublicationOrgMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PublicationOrgMutation) ClearField(name string) error {
	switch name {
	case publicationorg.FieldOrgName:
		m.ClearOrgName()
		return nil
	case publicationorg.FieldOrgAddress:
		m.ClearOrgAddress()
		return nil
	case publicationorg.FieldModifiedAt:
		m.ClearModifiedAt()
		return nil
	case publicationorg.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown PublicationOrg nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PublicationOrgMutation) ResetField(name string) error {
	switch name {
	case publicationorg.FieldOrgCode:
		m.ResetOrgCode()
		return nil
	case publicationorg.FieldOrgName:
		m.ResetOrgName()
		return nil
	case publicationorg.FieldOrgAddress:
		m.ResetOrgAddress()
		return nil
	case publicationorg.FieldModifiedAt:
		m.ResetModifiedAt()
		return nil
	case publicationorg.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown PublicationOrg field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PublicationOrgMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PublicationOrgMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PublicationOrgMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PublicationOrgMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PublicationOrgMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PublicationOrgMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PublicationOrgMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown PublicationOrg unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PublicationOrgMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown PublicationOrg edge %s", name)
}

// PublicationStockMutation represents an operation that mutates the PublicationStock nodes in the graph.
type PublicationStockMutation struct {
	config
	op                Op
	typ               string
	id                *int
	isbn              *string
	quantity          *int
	addquantity       *int
	publication_id    *int
	addpublication_id *int
	clearedFields     map[string]struct{}
	done              bool
	oldValue          func(context.Context) (*PublicationStock, error)
	predicates        []predicate.PublicationStock
}

var _ ent.Mutation = (*PublicationStockMutation)(nil)

// publicationstockOption allows management of the mutation configuration using functional options.
type publicationstockOption func(*PublicationStockMutation)

// newPublicationStockMutation creates new mutation for the PublicationStock entity.
func newPublicationStockMutation(c config, op Op, opts ...publicationstockOption) *PublicationStockMutation {
	m := &PublicationStockMutation{
		config:        c,
		op:            op,
		typ:           TypePublicationStock,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPublicationStockID sets the ID field of the mutation.
func withPublicationStockID(id int) publicationstockOption {
	return func(m *PublicationStockMutation) {
		var (
			err   error
			once  sync.Once
			value *PublicationStock
		)
		m.oldValue = func(ctx context.Context) (*PublicationStock, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PublicationStock.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPublicationStock sets the old PublicationStock of the mutation.
func withPublicationStock(node *PublicationStock) publicationstockOption {
	return func(m *PublicationStockMutation) {
		m.oldValue = func(context.Context) (*PublicationStock, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PublicationStockMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PublicationStockMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PublicationStock entities.
func (m *PublicationStockMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PublicationStockMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PublicationStockMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PublicationStock.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetIsbn sets the "isbn" field.
func (m *PublicationStockMutation) SetIsbn(s string) {
	m.isbn = &s
}

// Isbn returns the value of the "isbn" field in the mutation.
func (m *PublicationStockMutation) Isbn() (r string, exists bool) {
	v := m.isbn
	if v == nil {
		return
	}
	return *v, true
}

// OldIsbn returns the old "isbn" field's value of the PublicationStock entity.
// If the PublicationStock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PublicationStockMutation) OldIsbn(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsbn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsbn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsbn: %w", err)
	}
	return oldValue.Isbn, nil
}

// ResetIsbn resets all changes to the "isbn" field.
func (m *PublicationStockMutation) ResetIsbn() {
	m.isbn = nil
}

// SetQuantity sets the "quantity" field.
func (m *PublicationStockMutation) SetQuantity(i int) {
	m.quantity = &i
	m.addquantity = nil
}

// Quantity returns the value of the "quantity" field in the mutation.
func (m *PublicationStockMutation) Quantity() (r int, exists bool) {
	v := m.quantity
	if v == nil {
		return
	}
	return *v, true
}

// OldQuantity returns the old "quantity" field's value of the PublicationStock entity.
// If the PublicationStock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PublicationStockMutation) OldQuantity(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQuantity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQuantity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuantity: %w", err)
	}
	return oldValue.Quantity, nil
}

// AddQuantity adds i to the "quantity" field.
func (m *PublicationStockMutation) AddQuantity(i int) {
	if m.addquantity != nil {
		*m.addquantity += i
	} else {
		m.addquantity = &i
	}
}

// AddedQuantity returns the value that was added to the "quantity" field in this mutation.
func (m *PublicationStockMutation) AddedQuantity() (r int, exists bool) {
	v := m.addquantity
	if v == nil {
		return
	}
	return *v, true
}

// ClearQuantity clears the value of the "quantity" field.
func (m *PublicationStockMutation) ClearQuantity() {
	m.quantity = nil
	m.addquantity = nil
	m.clearedFields[publicationstock.FieldQuantity] = struct{}{}
}

// QuantityCleared returns if the "quantity" field was cleared in this mutation.
func (m *PublicationStockMutation) QuantityCleared() bool {
	_, ok := m.clearedFields[publicationstock.FieldQuantity]
	return ok
}

// ResetQuantity resets all changes to the "quantity" field.
func (m *PublicationStockMutation) ResetQuantity() {
	m.quantity = nil
	m.addquantity = nil
	delete(m.clearedFields, publicationstock.FieldQuantity)
}

// SetPublicationID sets the "publication_id" field.
func (m *PublicationStockMutation) SetPublicationID(i int) {
	m.publication_id = &i
	m.addpublication_id = nil
}

// PublicationID returns the value of the "publication_id" field in the mutation.
func (m *PublicationStockMutation) PublicationID() (r int, exists bool) {
	v := m.publication_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPublicationID returns the old "publication_id" field's value of the PublicationStock entity.
// If the PublicationStock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PublicationStockMutation) OldPublicationID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPublicationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPublicationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublicationID: %w", err)
	}
	return oldValue.PublicationID, nil
}

// AddPublicationID adds i to the "publication_id" field.
func (m *PublicationStockMutation) AddPublicationID(i int) {
	if m.addpublication_id != nil {
		*m.addpublication_id += i
	} else {
		m.addpublication_id = &i
	}
}

// AddedPublicationID returns the value that was added to the "publication_id" field in this mutation.
func (m *PublicationStockMutation) AddedPublicationID() (r int, exists bool) {
	v := m.addpublication_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearPublicationID clears the value of the "publication_id" field.
func (m *PublicationStockMutation) ClearPublicationID() {
	m.publication_id = nil
	m.addpublication_id = nil
	m.clearedFields[publicationstock.FieldPublicationID] = struct{}{}
}

// PublicationIDCleared returns if the "publication_id" field was cleared in this mutation.
func (m *PublicationStockMutation) PublicationIDCleared() bool {
	_, ok := m.clearedFields[publicationstock.FieldPublicationID]
	return ok
}

// ResetPublicationID resets all changes to the "publication_id" field.
func (m *PublicationStockMutation) ResetPublicationID() {
	m.publication_id = nil
	m.addpublication_id = nil
	delete(m.clearedFields, publicationstock.FieldPublicationID)
}

// Where appends a list predicates to the PublicationStockMutation builder.
func (m *PublicationStockMutation) Where(ps ...predicate.PublicationStock) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PublicationStockMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PublicationStockMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PublicationStock, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PublicationStockMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PublicationStockMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PublicationStock).
func (m *PublicationStockMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PublicationStockMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.isbn != nil {
		fields = append(fields, publicationstock.FieldIsbn)
	}
	if m.quantity != nil {
		fields = append(fields, publicationstock.FieldQuantity)
	}
	if m.publication_id != nil {
		fields = append(fields, publicationstock.FieldPublicationID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PublicationStockMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case publicationstock.FieldIsbn:
		return m.Isbn()
	case publicationstock.FieldQuantity:
		return m.Quantity()
	case publicationstock.FieldPublicationID:
		return m.PublicationID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PublicationStockMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case publicationstock.FieldIsbn:
		return m.OldIsbn(ctx)
	case publicationstock.FieldQuantity:
		return m.OldQuantity(ctx)
	case publicationstock.FieldPublicationID:
		return m.OldPublicationID(ctx)
	}
	return nil, fmt.Errorf("unknown PublicationStock field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PublicationStockMutation) SetField(name string, value ent.Value) error {
	switch name {
	case publicationstock.FieldIsbn:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsbn(v)
		return nil
	case publicationstock.FieldQuantity:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuantity(v)
		return nil
	case publicationstock.FieldPublicationID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublicationID(v)
		return nil
	}
	return fmt.Errorf("unknown PublicationStock field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PublicationStockMutation) AddedFields() []string {
	var fields []string
	if m.addquantity != nil {
		fields = append(fields, publicationstock.FieldQuantity)
	}
	if m.addpublication_id != nil {
		fields = append(fields, publicationstock.FieldPublicationID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PublicationStockMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case publicationstock.FieldQuantity:
		return m.AddedQuantity()
	case publicationstock.FieldPublicationID:
		return m.AddedPublicationID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PublicationStockMutation) AddField(name string, value ent.Value) error {
	switch name {
	case publicationstock.FieldQuantity:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddQuantity(v)
		return nil
	case publicationstock.FieldPublicationID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPublicationID(v)
		return nil
	}
	return fmt.Errorf("unknown PublicationStock numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PublicationStockMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(publicationstock.FieldQuantity) {
		fields = append(fields, publicationstock.FieldQuantity)
	}
	if m.FieldCleared(publicationstock.FieldPublicationID) {
		fields = append(fields, publicationstock.FieldPublicationID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PublicationStockMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PublicationStockMutation) ClearField(name string) error {
	switch name {
	case publicationstock.FieldQuantity:
		m.ClearQuantity()
		return nil
	case publicationstock.FieldPublicationID:
		m.ClearPublicationID()
		return nil
	}
	return fmt.Errorf("unknown PublicationStock nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PublicationStockMutation) ResetField(name string) error {
	switch name {
	case publicationstock.FieldIsbn:
		m.ResetIsbn()
		return nil
	case publicationstock.FieldQuantity:
		m.ResetQuantity()
		return nil
	case publicationstock.FieldPublicationID:
		m.ResetPublicationID()
		return nil
	}
	return fmt.Errorf("unknown PublicationStock field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PublicationStockMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PublicationStockMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PublicationStockMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PublicationStockMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PublicationStockMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PublicationStockMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PublicationStockMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown PublicationStock unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PublicationStockMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown PublicationStock edge %s", name)
}

// PublicationXCatalogMutation represents an operation that mutates the PublicationXCatalog nodes in the graph.
type PublicationXCatalogMutation struct {
	config
	op                Op
	typ               string
	id                *int
	catalog_id        *int
	addcatalog_id     *int
	isbn              *string
	catalog_name      *string
	publication_id    *int
	addpublication_id *int
	clearedFields     map[string]struct{}
	done              bool
	oldValue          func(context.Context) (*PublicationXCatalog, error)
	predicates        []predicate.PublicationXCatalog
}

var _ ent.Mutation = (*PublicationXCatalogMutation)(nil)

// publicationxcatalogOption allows management of the mutation configuration using functional options.
type publicationxcatalogOption func(*PublicationXCatalogMutation)

// newPublicationXCatalogMutation creates new mutation for the PublicationXCatalog entity.
func newPublicationXCatalogMutation(c config, op Op, opts ...publicationxcatalogOption) *PublicationXCatalogMutation {
	m := &PublicationXCatalogMutation{
		config:        c,
		op:            op,
		typ:           TypePublicationXCatalog,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPublicationXCatalogID sets the ID field of the mutation.
func withPublicationXCatalogID(id int) publicationxcatalogOption {
	return func(m *PublicationXCatalogMutation) {
		var (
			err   error
			once  sync.Once
			value *PublicationXCatalog
		)
		m.oldValue = func(ctx context.Context) (*PublicationXCatalog, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PublicationXCatalog.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPublicationXCatalog sets the old PublicationXCatalog of the mutation.
func withPublicationXCatalog(node *PublicationXCatalog) publicationxcatalogOption {
	return func(m *PublicationXCatalogMutation) {
		m.oldValue = func(context.Context) (*PublicationXCatalog, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PublicationXCatalogMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PublicationXCatalogMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PublicationXCatalog entities.
func (m *PublicationXCatalogMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PublicationXCatalogMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PublicationXCatalogMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PublicationXCatalog.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCatalogID sets the "catalog_id" field.
func (m *PublicationXCatalogMutation) SetCatalogID(i int) {
	m.catalog_id = &i
	m.addcatalog_id = nil
}

// CatalogID returns the value of the "catalog_id" field in the mutation.
func (m *PublicationXCatalogMutation) CatalogID() (r int, exists bool) {
	v := m.catalog_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCatalogID returns the old "catalog_id" field's value of the PublicationXCatalog entity.
// If the PublicationXCatalog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PublicationXCatalogMutation) OldCatalogID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCatalogID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCatalogID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCatalogID: %w", err)
	}
	return oldValue.CatalogID, nil
}

// AddCatalogID adds i to the "catalog_id" field.
func (m *PublicationXCatalogMutation) AddCatalogID(i int) {
	if m.addcatalog_id != nil {
		*m.addcatalog_id += i
	} else {
		m.addcatalog_id = &i
	}
}

// AddedCatalogID returns the value that was added to the "catalog_id" field in this mutation.
func (m *PublicationXCatalogMutation) AddedCatalogID() (r int, exists bool) {
	v := m.addcatalog_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetCatalogID resets all changes to the "catalog_id" field.
func (m *PublicationXCatalogMutation) ResetCatalogID() {
	m.catalog_id = nil
	m.addcatalog_id = nil
}

// SetIsbn sets the "isbn" field.
func (m *PublicationXCatalogMutation) SetIsbn(s string) {
	m.isbn = &s
}

// Isbn returns the value of the "isbn" field in the mutation.
func (m *PublicationXCatalogMutation) Isbn() (r string, exists bool) {
	v := m.isbn
	if v == nil {
		return
	}
	return *v, true
}

// OldIsbn returns the old "isbn" field's value of the PublicationXCatalog entity.
// If the PublicationXCatalog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PublicationXCatalogMutation) OldIsbn(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsbn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsbn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsbn: %w", err)
	}
	return oldValue.Isbn, nil
}

// ResetIsbn resets all changes to the "isbn" field.
func (m *PublicationXCatalogMutation) ResetIsbn() {
	m.isbn = nil
}

// SetCatalogName sets the "catalog_name" field.
func (m *PublicationXCatalogMutation) SetCatalogName(s string) {
	m.catalog_name = &s
}

// CatalogName returns the value of the "catalog_name" field in the mutation.
func (m *PublicationXCatalogMutation) CatalogName() (r string, exists bool) {
	v := m.catalog_name
	if v == nil {
		return
	}
	return *v, true
}

// OldCatalogName returns the old "catalog_name" field's value of the PublicationXCatalog entity.
// If the PublicationXCatalog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PublicationXCatalogMutation) OldCatalogName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCatalogName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCatalogName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCatalogName: %w", err)
	}
	return oldValue.CatalogName, nil
}

// ClearCatalogName clears the value of the "catalog_name" field.
func (m *PublicationXCatalogMutation) ClearCatalogName() {
	m.catalog_name = nil
	m.clearedFields[publicationxcatalog.FieldCatalogName] = struct{}{}
}

// CatalogNameCleared returns if the "catalog_name" field was cleared in this mutation.
func (m *PublicationXCatalogMutation) CatalogNameCleared() bool {
	_, ok := m.clearedFields[publicationxcatalog.FieldCatalogName]
	return ok
}

// ResetCatalogName resets all changes to the "catalog_name" field.
func (m *PublicationXCatalogMutation) ResetCatalogName() {
	m.catalog_name = nil
	delete(m.clearedFields, publicationxcatalog.FieldCatalogName)
}

// SetPublicationID sets the "publication_id" field.
func (m *PublicationXCatalogMutation) SetPublicationID(i int) {
	m.publication_id = &i
	m.addpublication_id = nil
}

// PublicationID returns the value of the "publication_id" field in the mutation.
func (m *PublicationXCatalogMutation) PublicationID() (r int, exists bool) {
	v := m.publication_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPublicationID returns the old "publication_id" field's value of the PublicationXCatalog entity.
// If the PublicationXCatalog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PublicationXCatalogMutation) OldPublicationID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPublicationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPublicationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublicationID: %w", err)
	}
	return oldValue.PublicationID, nil
}

// AddPublicationID adds i to the "publication_id" field.
func (m *PublicationXCatalogMutation) AddPublicationID(i int) {
	if m.addpublication_id != nil {
		*m.addpublication_id += i
	} else {
		m.addpublication_id = &i
	}
}

// AddedPublicationID returns the value that was added to the "publication_id" field in this mutation.
func (m *PublicationXCatalogMutation) AddedPublicationID() (r int, exists bool) {
	v := m.addpublication_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearPublicationID clears the value of the "publication_id" field.
func (m *PublicationXCatalogMutation) ClearPublicationID() {
	m.publication_id = nil
	m.addpublication_id = nil
	m.clearedFields[publicationxcatalog.FieldPublicationID] = struct{}{}
}

// PublicationIDCleared returns if the "publication_id" field was cleared in this mutation.
func (m *PublicationXCatalogMutation) PublicationIDCleared() bool {
	_, ok := m.clearedFields[publicationxcatalog.FieldPublicationID]
	return ok
}

// ResetPublicationID resets all changes to the "publication_id" field.
func (m *PublicationXCatalogMutation) ResetPublicationID() {
	m.publication_id = nil
	m.addpublication_id = nil
	delete(m.clearedFields, publicationxcatalog.FieldPublicationID)
}

// Where appends a list predicates to the PublicationXCatalogMutation builder.
func (m *PublicationXCatalogMutation) Where(ps ...predicate.PublicationXCatalog) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PublicationXCatalogMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PublicationXCatalogMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PublicationXCatalog, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PublicationXCatalogMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PublicationXCatalogMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PublicationXCatalog).
func (m *PublicationXCatalogMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PublicationXCatalogMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.catalog_id != nil {
		fields = append(fields, publicationxcatalog.FieldCatalogID)
	}
	if m.isbn != nil {
		fields = append(fields, publicationxcatalog.FieldIsbn)
	}
	if m.catalog_name != nil {
		fields = append(fields, publicationxcatalog.FieldCatalogName)
	}
	if m.publication_id != nil {
		fields = append(fields, publicationxcatalog.FieldPublicationID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PublicationXCatalogMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case publicationxcatalog.FieldCatalogID:
		return m.CatalogID()
	case publicationxcatalog.FieldIsbn:
		return m.Isbn()
	case publicationxcatalog.FieldCatalogName:
		return m.CatalogName()
	case publicationxcatalog.FieldPublicationID:
		return m.PublicationID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PublicationXCatalogMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case publicationxcatalog.FieldCatalogID:
		return m.OldCatalogID(ctx)
	case publicationxcatalog.FieldIsbn:
		return m.OldIsbn(ctx)
	case publicationxcatalog.FieldCatalogName:
		return m.OldCatalogName(ctx)
	case publicationxcatalog.FieldPublicationID:
		return m.OldPublicationID(ctx)
	}
	return nil, fmt.Errorf("unknown PublicationXCatalog field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PublicationXCatalogMutation) SetField(name string, value ent.Value) error {
	switch name {
	case publicationxcatalog.FieldCatalogID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCatalogID(v)
		return nil
	case publicationxcatalog.FieldIsbn:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsbn(v)
		return nil
	case publicationxcatalog.FieldCatalogName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCatalogName(v)
		return nil
	case publicationxcatalog.FieldPublicationID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublicationID(v)
		return nil
	}
	return fmt.Errorf("unknown PublicationXCatalog field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PublicationXCatalogMutation) AddedFields() []string {
	var fields []string
	if m.addcatalog_id != nil {
		fields = append(fields, publicationxcatalog.FieldCatalogID)
	}
	if m.addpublication_id != nil {
		fields = append(fields, publicationxcatalog.FieldPublicationID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PublicationXCatalogMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case publicationxcatalog.FieldCatalogID:
		return m.AddedCatalogID()
	case publicationxcatalog.FieldPublicationID:
		return m.AddedPublicationID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PublicationXCatalogMutation) AddField(name string, value ent.Value) error {
	switch name {
	case publicationxcatalog.FieldCatalogID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCatalogID(v)
		return nil
	case publicationxcatalog.FieldPublicationID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPublicationID(v)
		return nil
	}
	return fmt.Errorf("unknown PublicationXCatalog numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PublicationXCatalogMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(publicationxcatalog.FieldCatalogName) {
		fields = append(fields, publicationxcatalog.FieldCatalogName)
	}
	if m.FieldCleared(publicationxcatalog.FieldPublicationID) {
		fields = append(fields, publicationxcatalog.FieldPublicationID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PublicationXCatalogMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PublicationXCatalogMutation) ClearField(name string) error {
	switch name {
	case publicationxcatalog.FieldCatalogName:
		m.ClearCatalogName()
		return nil
	case publicationxcatalog.FieldPublicationID:
		m.ClearPublicationID()
		return nil
	}
	return fmt.Errorf("unknown PublicationXCatalog nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PublicationXCatalogMutation) ResetField(name string) error {
	switch name {
	case publicationxcatalog.FieldCatalogID:
		m.ResetCatalogID()
		return nil
	case publicationxcatalog.FieldIsbn:
		m.ResetIsbn()
		return nil
	case publicationxcatalog.FieldCatalogName:
		m.ResetCatalogName()
		return nil
	case publicationxcatalog.FieldPublicationID:
		m.ResetPublicationID()
		return nil
	}
	return fmt.Errorf("unknown PublicationXCatalog field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PublicationXCatalogMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PublicationXCatalogMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PublicationXCatalogMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PublicationXCatalogMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PublicationXCatalogMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PublicationXCatalogMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PublicationXCatalogMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown PublicationXCatalog unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PublicationXCatalogMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown PublicationXCatalog edge %s", name)
}

// PublicationXClassicMutation represents an operation that mutates the PublicationXClassic nodes in the graph.
type PublicationXClassicMutation struct {
	config
	op                Op
	typ               string
	id                *int
	classic_id        *int
	addclassic_id     *int
	isbn              *string
	classic_name      *string
	publication_id    *int
	addpublication_id *int
	clearedFields     map[string]struct{}
	done              bool
	oldValue          func(context.Context) (*PublicationXClassic, error)
	predicates        []predicate.PublicationXClassic
}

var _ ent.Mutation = (*PublicationXClassicMutation)(nil)

// publicationxclassicOption allows management of the mutation configuration using functional options.
type publicationxclassicOption func(*PublicationXClassicMutation)

// newPublicationXClassicMutation creates new mutation for the PublicationXClassic entity.
func newPublicationXClassicMutation(c config, op Op, opts ...publicationxclassicOption) *PublicationXClassicMutation {
	m := &PublicationXClassicMutation{
		config:        c,
		op:            op,
		typ:           TypePublicationXClassic,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPublicationXClassicID sets the ID field of the mutation.
func withPublicationXClassicID(id int) publicationxclassicOption {
	return func(m *PublicationXClassicMutation) {
		var (
			err   error
			once  sync.Once
			value *PublicationXClassic
		)
		m.oldValue = func(ctx context.Context) (*PublicationXClassic, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PublicationXClassic.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPublicationXClassic sets the old PublicationXClassic of the mutation.
func withPublicationXClassic(node *PublicationXClassic) publicationxclassicOption {
	return func(m *PublicationXClassicMutation) {
		m.oldValue = func(context.Context) (*PublicationXClassic, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PublicationXClassicMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PublicationXClassicMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PublicationXClassic entities.
func (m *PublicationXClassicMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PublicationXClassicMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PublicationXClassicMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PublicationXClassic.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetClassicID sets the "classic_id" field.
func (m *PublicationXClassicMutation) SetClassicID(i int) {
	m.classic_id = &i
	m.addclassic_id = nil
}

// ClassicID returns the value of the "classic_id" field in the mutation.
func (m *PublicationXClassicMutation) ClassicID() (r int, exists bool) {
	v := m.classic_id
	if v == nil {
		return
	}
	return *v, true
}

// OldClassicID returns the old "classic_id" field's value of the PublicationXClassic entity.
// If the PublicationXClassic object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PublicationXClassicMutation) OldClassicID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClassicID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClassicID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClassicID: %w", err)
	}
	return oldValue.ClassicID, nil
}

// AddClassicID adds i to the "classic_id" field.
func (m *PublicationXClassicMutation) AddClassicID(i int) {
	if m.addclassic_id != nil {
		*m.addclassic_id += i
	} else {
		m.addclassic_id = &i
	}
}

// AddedClassicID returns the value that was added to the "classic_id" field in this mutation.
func (m *PublicationXClassicMutation) AddedClassicID() (r int, exists bool) {
	v := m.addclassic_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetClassicID resets all changes to the "classic_id" field.
func (m *PublicationXClassicMutation) ResetClassicID() {
	m.classic_id = nil
	m.addclassic_id = nil
}

// SetIsbn sets the "isbn" field.
func (m *PublicationXClassicMutation) SetIsbn(s string) {
	m.isbn = &s
}

// Isbn returns the value of the "isbn" field in the mutation.
func (m *PublicationXClassicMutation) Isbn() (r string, exists bool) {
	v := m.isbn
	if v == nil {
		return
	}
	return *v, true
}

// OldIsbn returns the old "isbn" field's value of the PublicationXClassic entity.
// If the PublicationXClassic object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PublicationXClassicMutation) OldIsbn(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsbn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsbn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsbn: %w", err)
	}
	return oldValue.Isbn, nil
}

// ResetIsbn resets all changes to the "isbn" field.
func (m *PublicationXClassicMutation) ResetIsbn() {
	m.isbn = nil
}

// SetClassicName sets the "classic_name" field.
func (m *PublicationXClassicMutation) SetClassicName(s string) {
	m.classic_name = &s
}

// ClassicName returns the value of the "classic_name" field in the mutation.
func (m *PublicationXClassicMutation) ClassicName() (r string, exists bool) {
	v := m.classic_name
	if v == nil {
		return
	}
	return *v, true
}

// OldClassicName returns the old "classic_name" field's value of the PublicationXClassic entity.
// If the PublicationXClassic object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PublicationXClassicMutation) OldClassicName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClassicName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClassicName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClassicName: %w", err)
	}
	return oldValue.ClassicName, nil
}

// ClearClassicName clears the value of the "classic_name" field.
func (m *PublicationXClassicMutation) ClearClassicName() {
	m.classic_name = nil
	m.clearedFields[publicationxclassic.FieldClassicName] = struct{}{}
}

// ClassicNameCleared returns if the "classic_name" field was cleared in this mutation.
func (m *PublicationXClassicMutation) ClassicNameCleared() bool {
	_, ok := m.clearedFields[publicationxclassic.FieldClassicName]
	return ok
}

// ResetClassicName resets all changes to the "classic_name" field.
func (m *PublicationXClassicMutation) ResetClassicName() {
	m.classic_name = nil
	delete(m.clearedFields, publicationxclassic.FieldClassicName)
}

// SetPublicationID sets the "publication_id" field.
func (m *PublicationXClassicMutation) SetPublicationID(i int) {
	m.publication_id = &i
	m.addpublication_id = nil
}

// PublicationID returns the value of the "publication_id" field in the mutation.
func (m *PublicationXClassicMutation) PublicationID() (r int, exists bool) {
	v := m.publication_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPublicationID returns the old "publication_id" field's value of the PublicationXClassic entity.
// If the PublicationXClassic object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PublicationXClassicMutation) OldPublicationID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPublicationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPublicationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublicationID: %w", err)
	}
	return oldValue.PublicationID, nil
}

// AddPublicationID adds i to the "publication_id" field.
func (m *PublicationXClassicMutation) AddPublicationID(i int) {
	if m.addpublication_id != nil {
		*m.addpublication_id += i
	} else {
		m.addpublication_id = &i
	}
}

// AddedPublicationID returns the value that was added to the "publication_id" field in this mutation.
func (m *PublicationXClassicMutation) AddedPublicationID() (r int, exists bool) {
	v := m.addpublication_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearPublicationID clears the value of the "publication_id" field.
func (m *PublicationXClassicMutation) ClearPublicationID() {
	m.publication_id = nil
	m.addpublication_id = nil
	m.clearedFields[publicationxclassic.FieldPublicationID] = struct{}{}
}

// PublicationIDCleared returns if the "publication_id" field was cleared in this mutation.
func (m *PublicationXClassicMutation) PublicationIDCleared() bool {
	_, ok := m.clearedFields[publicationxclassic.FieldPublicationID]
	return ok
}

// ResetPublicationID resets all changes to the "publication_id" field.
func (m *PublicationXClassicMutation) ResetPublicationID() {
	m.publication_id = nil
	m.addpublication_id = nil
	delete(m.clearedFields, publicationxclassic.FieldPublicationID)
}

// Where appends a list predicates to the PublicationXClassicMutation builder.
func (m *PublicationXClassicMutation) Where(ps ...predicate.PublicationXClassic) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PublicationXClassicMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PublicationXClassicMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PublicationXClassic, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PublicationXClassicMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PublicationXClassicMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PublicationXClassic).
func (m *PublicationXClassicMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PublicationXClassicMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.classic_id != nil {
		fields = append(fields, publicationxclassic.FieldClassicID)
	}
	if m.isbn != nil {
		fields = append(fields, publicationxclassic.FieldIsbn)
	}
	if m.classic_name != nil {
		fields = append(fields, publicationxclassic.FieldClassicName)
	}
	if m.publication_id != nil {
		fields = append(fields, publicationxclassic.FieldPublicationID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PublicationXClassicMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case publicationxclassic.FieldClassicID:
		return m.ClassicID()
	case publicationxclassic.FieldIsbn:
		return m.Isbn()
	case publicationxclassic.FieldClassicName:
		return m.ClassicName()
	case publicationxclassic.FieldPublicationID:
		return m.PublicationID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PublicationXClassicMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case publicationxclassic.FieldClassicID:
		return m.OldClassicID(ctx)
	case publicationxclassic.FieldIsbn:
		return m.OldIsbn(ctx)
	case publicationxclassic.FieldClassicName:
		return m.OldClassicName(ctx)
	case publicationxclassic.FieldPublicationID:
		return m.OldPublicationID(ctx)
	}
	return nil, fmt.Errorf("unknown PublicationXClassic field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PublicationXClassicMutation) SetField(name string, value ent.Value) error {
	switch name {
	case publicationxclassic.FieldClassicID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClassicID(v)
		return nil
	case publicationxclassic.FieldIsbn:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsbn(v)
		return nil
	case publicationxclassic.FieldClassicName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClassicName(v)
		return nil
	case publicationxclassic.FieldPublicationID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublicationID(v)
		return nil
	}
	return fmt.Errorf("unknown PublicationXClassic field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PublicationXClassicMutation) AddedFields() []string {
	var fields []string
	if m.addclassic_id != nil {
		fields = append(fields, publicationxclassic.FieldClassicID)
	}
	if m.addpublication_id != nil {
		fields = append(fields, publicationxclassic.FieldPublicationID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PublicationXClassicMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case publicationxclassic.FieldClassicID:
		return m.AddedClassicID()
	case publicationxclassic.FieldPublicationID:
		return m.AddedPublicationID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PublicationXClassicMutation) AddField(name string, value ent.Value) error {
	switch name {
	case publicationxclassic.FieldClassicID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddClassicID(v)
		return nil
	case publicationxclassic.FieldPublicationID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPublicationID(v)
		return nil
	}
	return fmt.Errorf("unknown PublicationXClassic numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PublicationXClassicMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(publicationxclassic.FieldClassicName) {
		fields = append(fields, publicationxclassic.FieldClassicName)
	}
	if m.FieldCleared(publicationxclassic.FieldPublicationID) {
		fields = append(fields, publicationxclassic.FieldPublicationID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PublicationXClassicMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PublicationXClassicMutation) ClearField(name string) error {
	switch name {
	case publicationxclassic.FieldClassicName:
		m.ClearClassicName()
		return nil
	case publicationxclassic.FieldPublicationID:
		m.ClearPublicationID()
		return nil
	}
	return fmt.Errorf("unknown PublicationXClassic nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PublicationXClassicMutation) ResetField(name string) error {
	switch name {
	case publicationxclassic.FieldClassicID:
		m.ResetClassicID()
		return nil
	case publicationxclassic.FieldIsbn:
		m.ResetIsbn()
		return nil
	case publicationxclassic.FieldClassicName:
		m.ResetClassicName()
		return nil
	case publicationxclassic.FieldPublicationID:
		m.ResetPublicationID()
		return nil
	}
	return fmt.Errorf("unknown PublicationXClassic field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PublicationXClassicMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PublicationXClassicMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PublicationXClassicMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PublicationXClassicMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PublicationXClassicMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PublicationXClassicMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PublicationXClassicMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown PublicationXClassic unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PublicationXClassicMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown PublicationXClassic edge %s", name)
}

// PublicationXLanguageMutation represents an operation that mutates the PublicationXLanguage nodes in the graph.
type PublicationXLanguageMutation struct {
	config
	op                Op
	typ               string
	id                *int
	language_id       *int
	addlanguage_id    *int
	isbn              *string
	language_name     *string
	publication_id    *int
	addpublication_id *int
	clearedFields     map[string]struct{}
	done              bool
	oldValue          func(context.Context) (*PublicationXLanguage, error)
	predicates        []predicate.PublicationXLanguage
}

var _ ent.Mutation = (*PublicationXLanguageMutation)(nil)

// publicationxlanguageOption allows management of the mutation configuration using functional options.
type publicationxlanguageOption func(*PublicationXLanguageMutation)

// newPublicationXLanguageMutation creates new mutation for the PublicationXLanguage entity.
func newPublicationXLanguageMutation(c config, op Op, opts ...publicationxlanguageOption) *PublicationXLanguageMutation {
	m := &PublicationXLanguageMutation{
		config:        c,
		op:            op,
		typ:           TypePublicationXLanguage,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPublicationXLanguageID sets the ID field of the mutation.
func withPublicationXLanguageID(id int) publicationxlanguageOption {
	return func(m *PublicationXLanguageMutation) {
		var (
			err   error
			once  sync.Once
			value *PublicationXLanguage
		)
		m.oldValue = func(ctx context.Context) (*PublicationXLanguage, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PublicationXLanguage.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPublicationXLanguage sets the old PublicationXLanguage of the mutation.
func withPublicationXLanguage(node *PublicationXLanguage) publicationxlanguageOption {
	return func(m *PublicationXLanguageMutation) {
		m.oldValue = func(context.Context) (*PublicationXLanguage, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PublicationXLanguageMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PublicationXLanguageMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PublicationXLanguage entities.
func (m *PublicationXLanguageMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PublicationXLanguageMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PublicationXLanguageMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PublicationXLanguage.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetLanguageID sets the "language_id" field.
func (m *PublicationXLanguageMutation) SetLanguageID(i int) {
	m.language_id = &i
	m.addlanguage_id = nil
}

// LanguageID returns the value of the "language_id" field in the mutation.
func (m *PublicationXLanguageMutation) LanguageID() (r int, exists bool) {
	v := m.language_id
	if v == nil {
		return
	}
	return *v, true
}

// OldLanguageID returns the old "language_id" field's value of the PublicationXLanguage entity.
// If the PublicationXLanguage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PublicationXLanguageMutation) OldLanguageID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLanguageID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLanguageID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLanguageID: %w", err)
	}
	return oldValue.LanguageID, nil
}

// AddLanguageID adds i to the "language_id" field.
func (m *PublicationXLanguageMutation) AddLanguageID(i int) {
	if m.addlanguage_id != nil {
		*m.addlanguage_id += i
	} else {
		m.addlanguage_id = &i
	}
}

// AddedLanguageID returns the value that was added to the "language_id" field in this mutation.
func (m *PublicationXLanguageMutation) AddedLanguageID() (r int, exists bool) {
	v := m.addlanguage_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetLanguageID resets all changes to the "language_id" field.
func (m *PublicationXLanguageMutation) ResetLanguageID() {
	m.language_id = nil
	m.addlanguage_id = nil
}

// SetIsbn sets the "isbn" field.
func (m *PublicationXLanguageMutation) SetIsbn(s string) {
	m.isbn = &s
}

// Isbn returns the value of the "isbn" field in the mutation.
func (m *PublicationXLanguageMutation) Isbn() (r string, exists bool) {
	v := m.isbn
	if v == nil {
		return
	}
	return *v, true
}

// OldIsbn returns the old "isbn" field's value of the PublicationXLanguage entity.
// If the PublicationXLanguage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PublicationXLanguageMutation) OldIsbn(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsbn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsbn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsbn: %w", err)
	}
	return oldValue.Isbn, nil
}

// ResetIsbn resets all changes to the "isbn" field.
func (m *PublicationXLanguageMutation) ResetIsbn() {
	m.isbn = nil
}

// SetLanguageName sets the "language_name" field.
func (m *PublicationXLanguageMutation) SetLanguageName(s string) {
	m.language_name = &s
}

// LanguageName returns the value of the "language_name" field in the mutation.
func (m *PublicationXLanguageMutation) LanguageName() (r string, exists bool) {
	v := m.language_name
	if v == nil {
		return
	}
	return *v, true
}

// OldLanguageName returns the old "language_name" field's value of the PublicationXLanguage entity.
// If the PublicationXLanguage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PublicationXLanguageMutation) OldLanguageName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLanguageName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLanguageName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLanguageName: %w", err)
	}
	return oldValue.LanguageName, nil
}

// ClearLanguageName clears the value of the "language_name" field.
func (m *PublicationXLanguageMutation) ClearLanguageName() {
	m.language_name = nil
	m.clearedFields[publicationxlanguage.FieldLanguageName] = struct{}{}
}

// LanguageNameCleared returns if the "language_name" field was cleared in this mutation.
func (m *PublicationXLanguageMutation) LanguageNameCleared() bool {
	_, ok := m.clearedFields[publicationxlanguage.FieldLanguageName]
	return ok
}

// ResetLanguageName resets all changes to the "language_name" field.
func (m *PublicationXLanguageMutation) ResetLanguageName() {
	m.language_name = nil
	delete(m.clearedFields, publicationxlanguage.FieldLanguageName)
}

// SetPublicationID sets the "publication_id" field.
func (m *PublicationXLanguageMutation) SetPublicationID(i int) {
	m.publication_id = &i
	m.addpublication_id = nil
}

// PublicationID returns the value of the "publication_id" field in the mutation.
func (m *PublicationXLanguageMutation) PublicationID() (r int, exists bool) {
	v := m.publication_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPublicationID returns the old "publication_id" field's value of the PublicationXLanguage entity.
// If the PublicationXLanguage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PublicationXLanguageMutation) OldPublicationID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPublicationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPublicationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublicationID: %w", err)
	}
	return oldValue.PublicationID, nil
}

// AddPublicationID adds i to the "publication_id" field.
func (m *PublicationXLanguageMutation) AddPublicationID(i int) {
	if m.addpublication_id != nil {
		*m.addpublication_id += i
	} else {
		m.addpublication_id = &i
	}
}

// AddedPublicationID returns the value that was added to the "publication_id" field in this mutation.
func (m *PublicationXLanguageMutation) AddedPublicationID() (r int, exists bool) {
	v := m.addpublication_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearPublicationID clears the value of the "publication_id" field.
func (m *PublicationXLanguageMutation) ClearPublicationID() {
	m.publication_id = nil
	m.addpublication_id = nil
	m.clearedFields[publicationxlanguage.FieldPublicationID] = struct{}{}
}

// PublicationIDCleared returns if the "publication_id" field was cleared in this mutation.
func (m *PublicationXLanguageMutation) PublicationIDCleared() bool {
	_, ok := m.clearedFields[publicationxlanguage.FieldPublicationID]
	return ok
}

// ResetPublicationID resets all changes to the "publication_id" field.
func (m *PublicationXLanguageMutation) ResetPublicationID() {
	m.publication_id = nil
	m.addpublication_id = nil
	delete(m.clearedFields, publicationxlanguage.FieldPublicationID)
}

// Where appends a list predicates to the PublicationXLanguageMutation builder.
func (m *PublicationXLanguageMutation) Where(ps ...predicate.PublicationXLanguage) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PublicationXLanguageMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PublicationXLanguageMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PublicationXLanguage, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PublicationXLanguageMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PublicationXLanguageMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PublicationXLanguage).
func (m *PublicationXLanguageMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PublicationXLanguageMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.language_id != nil {
		fields = append(fields, publicationxlanguage.FieldLanguageID)
	}
	if m.isbn != nil {
		fields = append(fields, publicationxlanguage.FieldIsbn)
	}
	if m.language_name != nil {
		fields = append(fields, publicationxlanguage.FieldLanguageName)
	}
	if m.publication_id != nil {
		fields = append(fields, publicationxlanguage.FieldPublicationID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PublicationXLanguageMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case publicationxlanguage.FieldLanguageID:
		return m.LanguageID()
	case publicationxlanguage.FieldIsbn:
		return m.Isbn()
	case publicationxlanguage.FieldLanguageName:
		return m.LanguageName()
	case publicationxlanguage.FieldPublicationID:
		return m.PublicationID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PublicationXLanguageMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case publicationxlanguage.FieldLanguageID:
		return m.OldLanguageID(ctx)
	case publicationxlanguage.FieldIsbn:
		return m.OldIsbn(ctx)
	case publicationxlanguage.FieldLanguageName:
		return m.OldLanguageName(ctx)
	case publicationxlanguage.FieldPublicationID:
		return m.OldPublicationID(ctx)
	}
	return nil, fmt.Errorf("unknown PublicationXLanguage field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PublicationXLanguageMutation) SetField(name string, value ent.Value) error {
	switch name {
	case publicationxlanguage.FieldLanguageID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLanguageID(v)
		return nil
	case publicationxlanguage.FieldIsbn:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsbn(v)
		return nil
	case publicationxlanguage.FieldLanguageName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLanguageName(v)
		return nil
	case publicationxlanguage.FieldPublicationID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublicationID(v)
		return nil
	}
	return fmt.Errorf("unknown PublicationXLanguage field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PublicationXLanguageMutation) AddedFields() []string {
	var fields []string
	if m.addlanguage_id != nil {
		fields = append(fields, publicationxlanguage.FieldLanguageID)
	}
	if m.addpublication_id != nil {
		fields = append(fields, publicationxlanguage.FieldPublicationID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PublicationXLanguageMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case publicationxlanguage.FieldLanguageID:
		return m.AddedLanguageID()
	case publicationxlanguage.FieldPublicationID:
		return m.AddedPublicationID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PublicationXLanguageMutation) AddField(name string, value ent.Value) error {
	switch name {
	case publicationxlanguage.FieldLanguageID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLanguageID(v)
		return nil
	case publicationxlanguage.FieldPublicationID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPublicationID(v)
		return nil
	}
	return fmt.Errorf("unknown PublicationXLanguage numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PublicationXLanguageMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(publicationxlanguage.FieldLanguageName) {
		fields = append(fields, publicationxlanguage.FieldLanguageName)
	}
	if m.FieldCleared(publicationxlanguage.FieldPublicationID) {
		fields = append(fields, publicationxlanguage.FieldPublicationID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PublicationXLanguageMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PublicationXLanguageMutation) ClearField(name string) error {
	switch name {
	case publicationxlanguage.FieldLanguageName:
		m.ClearLanguageName()
		return nil
	case publicationxlanguage.FieldPublicationID:
		m.ClearPublicationID()
		return nil
	}
	return fmt.Errorf("unknown PublicationXLanguage nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PublicationXLanguageMutation) ResetField(name string) error {
	switch name {
	case publicationxlanguage.FieldLanguageID:
		m.ResetLanguageID()
		return nil
	case publicationxlanguage.FieldIsbn:
		m.ResetIsbn()
		return nil
	case publicationxlanguage.FieldLanguageName:
		m.ResetLanguageName()
		return nil
	case publicationxlanguage.FieldPublicationID:
		m.ResetPublicationID()
		return nil
	}
	return fmt.Errorf("unknown PublicationXLanguage field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PublicationXLanguageMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PublicationXLanguageMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PublicationXLanguageMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PublicationXLanguageMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PublicationXLanguageMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PublicationXLanguageMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PublicationXLanguageMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown PublicationXLanguage unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PublicationXLanguageMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown PublicationXLanguage edge %s", name)
}
